#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#define _CRT_SECURE_NO_WARNINGS

#ifdef _WIN32
	#ifndef NOMINMAX
		#define NOMINMAX
	#endif
	#include <windows.h>
	#include <io.h>
	#include <sys/locking.h>
	#include <fcntl.h>
	#include <Psapi.h>
#else
	#include <unistd.h>
	#include <fcntl.h>
#endif

#include <algorithm>	// std::min/max
#include <sys/stat.h>

//#include "xo-amalgamation-freetype.h"

/***************************************************************************/
/*                                                                         */
/*  ftheader.h                                                             */
/*                                                                         */
/*    Build macros of the FreeType 2 library.                              */
/*                                                                         */
/*  Copyright 1996-2008, 2010, 2012, 2013 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

#ifndef __FT_HEADER_H__
#define __FT_HEADER_H__


  /*@***********************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_BEGIN_HEADER                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro is used in association with @FT_END_HEADER in header    */
  /*    files to ensure that the declarations within are properly          */
  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
  /*    C++ compiler.                                                      */
  /*                                                                       */
#ifdef __cplusplus
#define FT_BEGIN_HEADER  extern "C" {
#else
#define FT_BEGIN_HEADER  /* nothing */
#endif


  /*@***********************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_END_HEADER                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro is used in association with @FT_BEGIN_HEADER in header  */
  /*    files to ensure that the declarations within are properly          */
  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
  /*    C++ compiler.                                                      */
  /*                                                                       */
#ifdef __cplusplus
#define FT_END_HEADER  }
#else
#define FT_END_HEADER  /* nothing */
#endif


  /*************************************************************************/
  /*                                                                       */
  /* Aliases for the FreeType 2 public and configuration files.            */
  /*                                                                       */
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    header_file_macros                                                 */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Header File Macros                                                 */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Macro definitions used to #include specific header files.          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The following macros are defined to the name of specific           */
  /*    FreeType~2 header files.  They can be used directly in #include    */
  /*    statements as in:                                                  */
  /*                                                                       */
  /*    {                                                                  */
  /*    }                                                                  */
  /*                                                                       */
  /*    There are several reasons why we are now using macros to name      */
  /*    public header files.  The first one is that such macros are not    */
  /*    limited to the infamous 8.3~naming rule required by DOS (and       */
  /*    `FT_MULTIPLE_MASTERS_H' is a lot more meaningful than `ftmm.h').   */
  /*                                                                       */
  /*    The second reason is that it allows for more flexibility in the    */
  /*    way FreeType~2 is installed on a given system.                     */
  /*                                                                       */
  /*************************************************************************/


  /* configuration files */

  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_CONFIG_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 configuration data.
   *
   */
#ifndef FT_CONFIG_CONFIG_H
#define FT_CONFIG_CONFIG_H  <freetype/config/ftconfig.h>
#endif


  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_STANDARD_LIBRARY_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 interface to the standard C library functions.
   *
   */
#ifndef FT_CONFIG_STANDARD_LIBRARY_H
#define FT_CONFIG_STANDARD_LIBRARY_H  <freetype/config/ftstdlib.h>
#endif


  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_OPTIONS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   FreeType~2 project-specific configuration options.
   *
   */
#ifndef FT_CONFIG_OPTIONS_H
#define FT_CONFIG_OPTIONS_H  <freetype/config/ftoption.h>
#endif


  /*************************************************************************
   *
   * @macro:
   *   FT_CONFIG_MODULES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 modules that are statically linked to new library
   *   instances in @FT_Init_FreeType.
   *
   */
#ifndef FT_CONFIG_MODULES_H
#define FT_CONFIG_MODULES_H  <freetype/config/ftmodule.h>
#endif

  /* */

  /* public headers */

  /*************************************************************************
   *
   * @macro:
   *   FT_FREETYPE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   base FreeType~2 API.
   *
   */
#define FT_FREETYPE_H  <freetype/freetype.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_ERRORS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 error codes (and messages).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_ERRORS_H  <freetype/fterrors.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_MODULE_ERRORS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list of FreeType~2 module error offsets (and messages).
   *
   */
#define FT_MODULE_ERRORS_H  <freetype/ftmoderr.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_SYSTEM_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 interface to low-level operations (i.e., memory management
   *   and stream i/o).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_SYSTEM_H  <freetype/ftsystem.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_IMAGE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing type
   *   definitions related to glyph images (i.e., bitmaps, outlines,
   *   scan-converter parameters).
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_IMAGE_H  <freetype/ftimage.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TYPES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   basic data types defined by FreeType~2.
   *
   *   It is included by @FT_FREETYPE_H.
   *
   */
#define FT_TYPES_H  <freetype/fttypes.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_LIST_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   list management API of FreeType~2.
   *
   *   (Most applications will never need to include this file.)
   *
   */
#define FT_LIST_H  <freetype/ftlist.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_OUTLINE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   scalable outline management API of FreeType~2.
   *
   */
#define FT_OUTLINE_H  <freetype/ftoutln.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_SIZES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API which manages multiple @FT_Size objects per face.
   *
   */
#define FT_SIZES_H  <freetype/ftsizes.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_MODULE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   module management API of FreeType~2.
   *
   */
#define FT_MODULE_H  <freetype/ftmodapi.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_RENDER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   renderer module management API of FreeType~2.
   *
   */
#define FT_RENDER_H  <freetype/ftrender.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_AUTOHINTER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the auto-hinting module.
   *
   */
#define FT_AUTOHINTER_H  <freetype/ftautoh.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_CFF_DRIVER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the CFF driver module.
   *
   */
#define FT_CFF_DRIVER_H  <freetype/ftcffdrv.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_DRIVER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing
   *   structures and macros related to the TrueType driver module.
   *
   */
#define FT_TRUETYPE_DRIVER_H  <freetype/ftttdrv.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TYPE1_TABLES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   types and API specific to the Type~1 format.
   *
   */
#define FT_TYPE1_TABLES_H  <freetype/t1tables.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_IDS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   enumeration values which identify name strings, languages, encodings,
   *   etc.  This file really contains a _large_ set of constant macro
   *   definitions, taken from the TrueType and OpenType specifications.
   *
   */
#define FT_TRUETYPE_IDS_H  <freetype/ttnameid.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_TABLES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   types and API specific to the TrueType (as well as OpenType) format.
   *
   */
#define FT_TRUETYPE_TABLES_H  <freetype/tttables.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TRUETYPE_TAGS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of TrueType four-byte `tags' which identify blocks in
   *   SFNT-based font formats (i.e., TrueType and OpenType).
   *
   */
#define FT_TRUETYPE_TAGS_H  <freetype/tttags.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_BDF_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which accesses BDF-specific strings from a
   *   face.
   *
   */
#define FT_BDF_H  <freetype/ftbdf.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_CID_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which access CID font information from a
   *   face.
   *
   */
#define FT_CID_H  <freetype/ftcid.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_GZIP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports gzip-compressed files.
   *
   */
#define FT_GZIP_H  <freetype/ftgzip.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_LZW_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports LZW-compressed files.
   *
   */
#define FT_LZW_H  <freetype/ftlzw.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_BZIP2_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports bzip2-compressed files.
   *
   */
#define FT_BZIP2_H  <freetype/ftbzip2.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_WINFONTS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   definitions of an API which supports Windows FNT files.
   *
   */
#define FT_WINFONTS_H   <freetype/ftwinfnt.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_GLYPH_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional glyph management component.
   *
   */
#define FT_GLYPH_H  <freetype/ftglyph.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_BITMAP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional bitmap conversion component.
   *
   */
#define FT_BITMAP_H  <freetype/ftbitmap.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_BBOX_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional exact bounding box computation routines.
   *
   */
#define FT_BBOX_H  <freetype/ftbbox.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   API of the optional FreeType~2 cache sub-system.
   *
   */
#define FT_CACHE_H  <freetype/ftcache.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_IMAGE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `glyph image' API of the FreeType~2 cache sub-system.
   *
   *   It is used to define a cache for @FT_Glyph elements.  You can also
   *   use the API defined in @FT_CACHE_SMALL_BITMAPS_H if you only need to
   *   store small glyph bitmaps, as it will use less memory.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   glyph image-related cache declarations.
   *
   */
#define FT_CACHE_IMAGE_H  FT_CACHE_H


  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_SMALL_BITMAPS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `small bitmaps' API of the FreeType~2 cache sub-system.
   *
   *   It is used to define a cache for small glyph bitmaps in a relatively
   *   memory-efficient way.  You can also use the API defined in
   *   @FT_CACHE_IMAGE_H if you want to cache arbitrary glyph images,
   *   including scalable outlines.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   small bitmaps-related cache declarations.
   *
   */
#define FT_CACHE_SMALL_BITMAPS_H  FT_CACHE_H


  /*************************************************************************
   *
   * @macro:
   *   FT_CACHE_CHARMAP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   `charmap' API of the FreeType~2 cache sub-system.
   *
   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
   *   charmap-based cache declarations.
   *
   */
#define FT_CACHE_CHARMAP_H  FT_CACHE_H


  /*************************************************************************
   *
   * @macro:
   *   FT_MAC_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   Macintosh-specific FreeType~2 API.  The latter is used to access
   *   fonts embedded in resource forks.
   *
   *   This header file must be explicitly included by client applications
   *   compiled on the Mac (note that the base API still works though).
   *
   */
#define FT_MAC_H  <freetype/ftmac.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_MULTIPLE_MASTERS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional multiple-masters management API of FreeType~2.
   *
   */
#define FT_MULTIPLE_MASTERS_H  <freetype/ftmm.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_SFNT_NAMES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which accesses embedded `name' strings in
   *   SFNT-based font formats (i.e., TrueType and OpenType).
   *
   */
#define FT_SFNT_NAMES_H  <freetype/ftsnames.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_OPENTYPE_VALIDATE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which validates OpenType tables (BASE, GDEF,
   *   GPOS, GSUB, JSTF).
   *
   */
#define FT_OPENTYPE_VALIDATE_H  <freetype/ftotval.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_GX_VALIDATE_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   optional FreeType~2 API which validates TrueTypeGX/AAT tables (feat,
   *   mort, morx, bsln, just, kern, opbd, trak, prop).
   *
   */
#define FT_GX_VALIDATE_H  <freetype/ftgxval.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_PFR_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which accesses PFR-specific data.
   *
   */
#define FT_PFR_H  <freetype/ftpfr.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_STROKER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which provides functions to stroke outline paths.
   */
#define FT_STROKER_H  <freetype/ftstroke.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_SYNTHESIS_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs artificial obliquing and emboldening.
   */
#define FT_SYNTHESIS_H  <freetype/ftsynth.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_XFREE86_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which provides functions specific to the XFree86 and
   *   X.Org X11 servers.
   */
#define FT_XFREE86_H  <freetype/ftxf86.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_TRIGONOMETRY_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs trigonometric computations (e.g.,
   *   cosines and arc tangents).
   */
#define FT_TRIGONOMETRY_H  <freetype/fttrigon.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_LCD_FILTER_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs color filtering for subpixel rendering.
   */
#define FT_LCD_FILTER_H  <freetype/ftlcdfil.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_UNPATENTED_HINTING_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs color filtering for subpixel rendering.
   */
#define FT_UNPATENTED_HINTING_H  <freetype/ttunpat.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_INCREMENTAL_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which performs color filtering for subpixel rendering.
   */
#define FT_INCREMENTAL_H  <freetype/ftincrem.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_GASP_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which returns entries from the TrueType GASP table.
   */
#define FT_GASP_H  <freetype/ftgasp.h>


  /*************************************************************************
   *
   * @macro:
   *   FT_ADVANCES_H
   *
   * @description:
   *   A macro used in #include statements to name the file containing the
   *   FreeType~2 API which returns individual and ranged glyph advances.
   */
#define FT_ADVANCES_H  <freetype/ftadvanc.h>


  /* */

#define FT_ERROR_DEFINITIONS_H  <freetype/fterrdef.h>


  /* The internals of the cache sub-system are no longer exposed.  We */
  /* default to FT_CACHE_H at the moment just in case, but we know of */
  /* no rogue client that uses them.                                  */
  /*                                                                  */
#define FT_CACHE_MANAGER_H           <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_MRU_H      <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_MANAGER_H  <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_CACHE_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_GLYPH_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_IMAGE_H    <freetype/ftcache.h>
#define FT_CACHE_INTERNAL_SBITS_H    <freetype/ftcache.h>


#define FT_INCREMENTAL_H          <freetype/ftincrem.h>

#define FT_TRUETYPE_UNPATENTED_H  <freetype/ttunpat.h>


  /*
   * Include internal headers definitions from <freetype/internal/...>
   * only when building the library.
   */
#ifdef FT2_BUILD_LIBRARY
#define  FT_INTERNAL_INTERNAL_H  <freetype/internal/internal.h>
#endif /* FT2_BUILD_LIBRARY */


#endif /* __FT2_BUILD_H__ */


/* END */

/***************************************************************************/
/*                                                                         */
/*  freetype.h                                                             */
/*                                                                         */
/*    FreeType high-level API and common types (specification only).       */
/*                                                                         */
/*  Copyright 1996-2013 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef __FREETYPE_H__
#define __FREETYPE_H__


#ifndef FT_FREETYPE_H
#error "`ft2build.h' hasn't been included yet!"
#error "Please always use macros to include FreeType header files."
#error "Example:"
#error "  #include <ft2build.h>"
#endif


/***************************************************************************/
/*                                                                         */
/*  ftconfig.h                                                             */
/*                                                                         */
/*    ANSI-specific configuration file (specification only).               */
/*                                                                         */
/*  Copyright 1996-2004, 2006-2008, 2010-2011, 2013 by                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This header file contains a number of macro definitions that are used */
  /* by the rest of the engine.  Most of the macros here are automatically */
  /* determined at compile time, and you should not need to change it to   */
  /* port FreeType, except to compile the library with a non-ANSI          */
  /* compiler.                                                             */
  /*                                                                       */
  /* Note however that if some specific modifications are needed, we       */
  /* advise you to place a modified copy in your build directory.          */
  /*                                                                       */
  /* The build directory is usually `freetype/builds/<system>', and        */
  /* contains system-specific files that are always included first when    */
  /* building the library.                                                 */
  /*                                                                       */
  /* This ANSI version should stay in `include/freetype/config'.           */
  /*                                                                       */
  /*************************************************************************/

#ifndef __FTCONFIG_H__
#define __FTCONFIG_H__

/***************************************************************************/
/*                                                                         */
/*  ftstdlib.h                                                             */
/*                                                                         */
/*    ANSI-specific library and header configuration file (specification   */
/*    only).                                                               */
/*                                                                         */
/*  Copyright 2002-2007, 2009, 2011-2012 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This file is used to group all #includes to the ANSI C library that   */
  /* FreeType normally requires.  It also defines macros to rename the     */
  /* standard functions within the FreeType source code.                   */
  /*                                                                       */
  /* Load a file which defines __FTSTDLIB_H__ before this one to override  */
  /* it.                                                                   */
  /*                                                                       */
  /*************************************************************************/


#ifndef __FTSTDLIB_H__
#define __FTSTDLIB_H__


#include <stddef.h>

#define ft_ptrdiff_t  ptrdiff_t


  /**********************************************************************/
  /*                                                                    */
  /*                           integer limits                           */
  /*                                                                    */
  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
  /* of `int' and `long' in bytes at compile-time.  So far, this works  */
  /* for all platforms the library has been tested on.                  */
  /*                                                                    */
  /* Note that on the extremely rare platforms that do not provide      */
  /* integer types that are _exactly_ 16 and 32 bits wide (e.g. some    */
  /* old Crays where `int' is 36 bits), we do not make any guarantee    */
  /* about the correct behaviour of FT2 with all fonts.                 */
  /*                                                                    */
  /* In these case, `ftconfig.h' will refuse to compile anyway with a   */
  /* message like `couldn't find 32-bit type' or something similar.     */
  /*                                                                    */
  /**********************************************************************/


#include <limits.h>

#define FT_CHAR_BIT    CHAR_BIT
#define FT_USHORT_MAX  USHRT_MAX
#define FT_INT_MAX     INT_MAX
#define FT_INT_MIN     INT_MIN
#define FT_UINT_MAX    UINT_MAX
#define FT_ULONG_MAX   ULONG_MAX


  /**********************************************************************/
  /*                                                                    */
  /*                 character and string processing                    */
  /*                                                                    */
  /**********************************************************************/


#include <string.h>

#define ft_memchr   memchr
#define ft_memcmp   memcmp
#define ft_memcpy   memcpy
#define ft_memmove  memmove
#define ft_memset   memset
#define ft_strcat   strcat
#define ft_strcmp   strcmp
#define ft_strcpy   strcpy
#define ft_strlen   strlen
#define ft_strncmp  strncmp
#define ft_strncpy  strncpy
#define ft_strrchr  strrchr
#define ft_strstr   strstr


  /**********************************************************************/
  /*                                                                    */
  /*                           file handling                            */
  /*                                                                    */
  /**********************************************************************/


#include <stdio.h>

#define FT_FILE     FILE
#define ft_fclose   fclose
#define ft_fopen    fopen
#define ft_fread    fread
#define ft_fseek    fseek
#define ft_ftell    ftell
#define ft_sprintf  sprintf


  /**********************************************************************/
  /*                                                                    */
  /*                             sorting                                */
  /*                                                                    */
  /**********************************************************************/


#include <stdlib.h>

#define ft_qsort  qsort


  /**********************************************************************/
  /*                                                                    */
  /*                        memory allocation                           */
  /*                                                                    */
  /**********************************************************************/


#define ft_scalloc   calloc
#define ft_sfree     free
#define ft_smalloc   malloc
#define ft_srealloc  realloc


  /**********************************************************************/
  /*                                                                    */
  /*                          miscellaneous                             */
  /*                                                                    */
  /**********************************************************************/


#define ft_atol   atol
#define ft_labs   labs


  /**********************************************************************/
  /*                                                                    */
  /*                         execution control                          */
  /*                                                                    */
  /**********************************************************************/


#include <setjmp.h>

#define ft_jmp_buf     jmp_buf  /* note: this cannot be a typedef since */
                                /*       jmp_buf is defined as a macro  */
                                /*       on certain platforms           */

#define ft_longjmp     longjmp
#define ft_setjmp( b ) setjmp( *(ft_jmp_buf*) &(b) ) /* same thing here */


  /* the following is only used for debugging purposes, i.e., if */
  /* FT_DEBUG_LEVEL_ERROR or FT_DEBUG_LEVEL_TRACE are defined    */

#include <stdarg.h>


#endif /* __FTSTDLIB_H__ */


/* END */


FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /*               PLATFORM-SPECIFIC CONFIGURATION MACROS                  */
  /*                                                                       */
  /* These macros can be toggled to suit a specific system.  The current   */
  /* ones are defaults used to compile FreeType in an ANSI C environment   */
  /* (16bit compilers are also supported).  Copy this file to your own     */
  /* `freetype/builds/<system>' directory, and edit it to port the engine. */
  /*                                                                       */
  /*************************************************************************/


  /* There are systems (like the Texas Instruments 'C54x) where a `char' */
  /* has 16 bits.  ANSI C says that sizeof(char) is always 1.  Since an  */
  /* `int' has 16 bits also for this system, sizeof(int) gives 1 which   */
  /* is probably unexpected.                                             */
  /*                                                                     */
  /* `CHAR_BIT' (defined in limits.h) gives the number of bits in a      */
  /* `char' type.                                                        */

#ifndef FT_CHAR_BIT
#define FT_CHAR_BIT  CHAR_BIT
#endif


  /* The size of an `int' type.  */
#if                                 FT_UINT_MAX == 0xFFFFUL
#define FT_SIZEOF_INT  (16 / FT_CHAR_BIT)
#elif                               FT_UINT_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_INT  (32 / FT_CHAR_BIT)
#elif FT_UINT_MAX > 0xFFFFFFFFUL && FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_INT  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `int' type!"
#endif

  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
  /* DM642) is recognized but avoided.                                   */
#if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `long' type!"
#endif


  /* FT_UNUSED is a macro used to indicate that a given parameter is not  */
  /* used -- this is only used to get rid of unpleasant compiler warnings */
#ifndef FT_UNUSED
#define FT_UNUSED( arg )  ( (arg) = (arg) )
#endif


  /*************************************************************************/
  /*                                                                       */
  /*                     AUTOMATIC CONFIGURATION MACROS                    */
  /*                                                                       */
  /* These macros are computed from the ones defined above.  Don't touch   */
  /* their definition, unless you know precisely what you are doing.  No   */
  /* porter should need to mess with them.                                 */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* Mac support                                                           */
  /*                                                                       */
  /*   This is the only necessary change, so it is defined here instead    */
  /*   providing a new configuration file.                                 */
  /*                                                                       */
#if defined( __APPLE__ ) || ( defined( __MWERKS__ ) && defined( macintosh ) )
  /* no Carbon frameworks for 64bit 10.4.x */
  /* AvailabilityMacros.h is available since Mac OS X 10.2,        */
  /* so guess the system version by maximum errno before inclusion */
#include <errno.h>
#ifdef ECANCELED /* defined since 10.2 */
#endif
#if defined( __LP64__ ) && \
    ( MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 )
#undef FT_MACINTOSH
#endif

#elif defined( __SC__ ) || defined( __MRC__ )
  /* Classic MacOS compilers */
#if TARGET_OS_MAC
#define FT_MACINTOSH 1
#endif

#endif


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int16                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit signed integer type.                         */
  /*                                                                       */
  typedef signed short  FT_Int16;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt16                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit unsigned integer type.                       */
  /*                                                                       */
  typedef unsigned short  FT_UInt16;

  /* */


  /* this #if 0 ... #endif clause is for documentation purposes */
#if 0

  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int32                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 32bit signed integer type.  The size depends on    */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef signed XXX  FT_Int32;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt32                                                          */
  /*                                                                       */
  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt32;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int64                                                           */
  /*                                                                       */
  /*    A typedef for a 64bit signed integer type.  The size depends on    */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef signed XXX  FT_Int64;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt64                                                          */
  /*                                                                       */
  /*    A typedef for a 64bit unsigned integer type.  The size depends on  */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt64;

  /* */

#endif

#if FT_SIZEOF_INT == (32 / FT_CHAR_BIT)

  typedef signed int      FT_Int32;
  typedef unsigned int    FT_UInt32;

#elif FT_SIZEOF_LONG == (32 / FT_CHAR_BIT)

  typedef signed long     FT_Int32;
  typedef unsigned long   FT_UInt32;

#else
#error "no 32bit type found -- please check your configuration files"
#endif


  /* look up an integer type that is at least 32 bits */
#if FT_SIZEOF_INT >= (32 / FT_CHAR_BIT)

  typedef int            FT_Fast;
  typedef unsigned int   FT_UFast;

#elif FT_SIZEOF_LONG >= (32 / FT_CHAR_BIT)

  typedef long           FT_Fast;
  typedef unsigned long  FT_UFast;

#endif


  /* determine whether we have a 64-bit int type for platforms without */
  /* Autoconf                                                          */
#if FT_SIZEOF_LONG == (64 / FT_CHAR_BIT)

  /* FT_LONG64 must be defined if a 64-bit type is available */
#define FT_LONG64
#define FT_INT64   long
#define FT_UINT64  unsigned long

#elif defined( _MSC_VER ) && _MSC_VER >= 900  /* Visual C++ (and Intel C++) */

  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64

#elif defined( __BORLANDC__ )  /* Borland C++ */

  /* XXXX: We should probably check the value of __BORLANDC__ in order */
  /*       to test the compiler version.                               */

  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64

#elif defined( __WATCOMC__ )   /* Watcom C++ */

  /* Watcom doesn't provide 64-bit data types */

#elif defined( __MWERKS__ )    /* Metrowerks CodeWarrior */

#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int

#elif defined( __GNUC__ )

  /* GCC provides the `long long' type */
#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int

#endif /* FT_SIZEOF_LONG == (64 / FT_CHAR_BIT) */


  /*************************************************************************/
  /*                                                                       */
  /* A 64-bit data type will create compilation problems if you compile    */
  /* in strict ANSI mode.  To avoid them, we disable its use if __STDC__   */
  /* is defined.  You can however ignore this rule by defining the         */
  /* FT_CONFIG_OPTION_FORCE_INT64 configuration macro.                     */
  /*                                                                       */
#if defined( FT_LONG64 ) && !defined( FT_CONFIG_OPTION_FORCE_INT64 )

#ifdef __STDC__

  /* undefine the 64-bit macros in strict ANSI compilation mode */
#undef FT_LONG64
#undef FT_INT64

#endif /* __STDC__ */

#endif /* FT_LONG64 && !FT_CONFIG_OPTION_FORCE_INT64 */

#ifdef FT_LONG64
  typedef FT_INT64   FT_Int64;
  typedef FT_UINT64  FT_UInt64;
#endif


#define FT_BEGIN_STMNT  do {
#define FT_END_STMNT    } while ( 0 )
#define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT


#ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
  /* Provide assembler fragments for performance-critical functions. */
  /* These must be defined `static __inline__' with GCC.             */

#if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm

  /* documentation is in freetype.h */

  static __inline FT_Int32
  FT_MulFix_arm( FT_Int32  a,
                 FT_Int32  b )
  {
    register FT_Int32  t, t2;


    __asm
    {
      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
      mov   a,  t,  asr #31         /* a   = (hi >> 31) */
      add   a,  a,  #0x8000         /* a  += 0x8000 */
      adds  t2, t2, a               /* t2 += a */
      adc   t,  t,  #0              /* t  += carry */
      mov   a,  t2, lsr #16         /* a   = t2 >> 16 */
      orr   a,  a,  t,  lsl #16     /* a  |= t << 16 */
    }
    return a;
  }

#endif /* __CC_ARM || __ARMCC__ */


#ifdef __GNUC__

#if defined( __arm__ ) && !defined( __thumb__ )    && \
    !( defined( __CC_ARM ) || defined( __ARMCC__ ) )
#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm

  /* documentation is in freetype.h */

  static __inline__ FT_Int32
  FT_MulFix_arm( FT_Int32  a,
                 FT_Int32  b )
  {
    register FT_Int32  t, t2;


    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"       /* (lo=%1,hi=%2) = a*b */
      "mov    %0, %2, asr #31\n\t"      /* %0  = (hi >> 31) */
      "add    %0, %0, #0x8000\n\t"      /* %0 += 0x8000 */
      "adds   %1, %1, %0\n\t"           /* %1 += %0 */
      "adc    %2, %2, #0\n\t"           /* %2 += carry */
      "mov    %0, %1, lsr #16\n\t"      /* %0  = %1 >> 16 */
      "orr    %0, %0, %2, lsl #16\n\t"  /* %0 |= %2 << 16 */
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );
    return a;
  }

#endif /* __arm__ && !__thumb__ && !( __CC_ARM || __ARMCC__ ) */

#if defined( __i386__ )
#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386

  /* documentation is in freetype.h */

  static __inline__ FT_Int32
  FT_MulFix_i386( FT_Int32  a,
                  FT_Int32  b )
  {
    register FT_Int32  result;


    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      : "=a"(result), "=d"(b)
      : "a"(a), "d"(b)
      : "%ecx", "cc" );
    return result;
  }

#endif /* i386 */

#endif /* __GNUC__ */


#ifdef _MSC_VER /* Visual C++ */

#ifdef _M_IX86

#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386

  /* documentation is in freetype.h */

  static __inline FT_Int32
  FT_MulFix_i386( FT_Int32  a,
                  FT_Int32  b )
  {
    register FT_Int32  result;

    __asm
    {
      mov eax, a
      mov edx, b
      imul edx
      mov ecx, edx
      sar ecx, 31
      add ecx, 8000h
      add eax, ecx
      adc edx, 0
      shr eax, 16
      shl edx, 16
      add eax, edx
      mov result, eax
    }
    return result;
  }

#endif /* _M_IX86 */

#endif /* _MSC_VER */

#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */


#ifdef FT_CONFIG_OPTION_INLINE_MULFIX
#ifdef FT_MULFIX_ASSEMBLER
#define FT_MULFIX_INLINED  FT_MULFIX_ASSEMBLER
#endif
#endif


#ifdef FT_MAKE_OPTION_SINGLE_OBJECT

#define FT_LOCAL( x )      static  x
#define FT_LOCAL_DEF( x )  static  x

#else

#ifdef __cplusplus
#define FT_LOCAL( x )      extern "C"  x
#define FT_LOCAL_DEF( x )  extern "C"  x
#else
#define FT_LOCAL( x )      extern  x
#define FT_LOCAL_DEF( x )  x
#endif

#endif /* FT_MAKE_OPTION_SINGLE_OBJECT */


#ifndef FT_BASE

#ifdef __cplusplus
#define FT_BASE( x )  extern "C"  x
#else
#define FT_BASE( x )  extern  x
#endif

#endif /* !FT_BASE */


#ifndef FT_BASE_DEF

#ifdef __cplusplus
#define FT_BASE_DEF( x )  x
#else
#define FT_BASE_DEF( x )  x
#endif

#endif /* !FT_BASE_DEF */


#ifndef FT_EXPORT

#ifdef __cplusplus
#define FT_EXPORT( x )  extern "C"  x
#else
#define FT_EXPORT( x )  extern  x
#endif

#endif /* !FT_EXPORT */


#ifndef FT_EXPORT_DEF

#ifdef __cplusplus
#define FT_EXPORT_DEF( x )  extern "C"  x
#else
#define FT_EXPORT_DEF( x )  extern  x
#endif

#endif /* !FT_EXPORT_DEF */


#ifndef FT_EXPORT_VAR

#ifdef __cplusplus
#define FT_EXPORT_VAR( x )  extern "C"  x
#else
#define FT_EXPORT_VAR( x )  extern  x
#endif

#endif /* !FT_EXPORT_VAR */

  /* The following macros are needed to compile the library with a   */
  /* C++ compiler and with 16bit compilers.                          */
  /*                                                                 */

  /* This is special.  Within C++, you must specify `extern "C"' for */
  /* functions which are used via function pointers, and you also    */
  /* must do that for structures which contain function pointers to  */
  /* assure C linkage -- it's not possible to have (local) anonymous */
  /* functions which are accessed by (global) function pointers.     */
  /*                                                                 */
  /*                                                                 */
  /* FT_CALLBACK_DEF is used to _define_ a callback function.        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
  /* contains pointers to callback functions.                        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
  /* that contains pointers to callback functions.                   */
  /*                                                                 */
  /*                                                                 */
  /* Some 16bit compilers have to redefine these macros to insert    */
  /* the infamous `_cdecl' or `__fastcall' declarations.             */
  /*                                                                 */
#ifndef FT_CALLBACK_DEF
#ifdef __cplusplus
#define FT_CALLBACK_DEF( x )  extern "C"  x
#else
#define FT_CALLBACK_DEF( x )  static  x
#endif
#endif /* FT_CALLBACK_DEF */

#ifndef FT_CALLBACK_TABLE
#ifdef __cplusplus
#define FT_CALLBACK_TABLE      extern "C"
#define FT_CALLBACK_TABLE_DEF  extern "C"
#else
#define FT_CALLBACK_TABLE      extern
#define FT_CALLBACK_TABLE_DEF  /* nothing */
#endif
#endif /* FT_CALLBACK_TABLE */


FT_END_HEADER


#endif /* __FTCONFIG_H__ */


/* END */
/***************************************************************************/
/*                                                                         */
/*  fttypes.h                                                              */
/*                                                                         */
/*    FreeType simple types definitions (specification only).              */
/*                                                                         */
/*  Copyright 1996-2002, 2004, 2006-2009, 2012, 2013 by                    */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef __FTTYPES_H__
#define __FTTYPES_H__


/***************************************************************************/
/*                                                                         */
/*  ftconfig.h                                                             */
/*                                                                         */
/*    ANSI-specific configuration file (specification only).               */
/*                                                                         */
/*  Copyright 1996-2004, 2006-2008, 2010-2011, 2013 by                     */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This header file contains a number of macro definitions that are used */
  /* by the rest of the engine.  Most of the macros here are automatically */
  /* determined at compile time, and you should not need to change it to   */
  /* port FreeType, except to compile the library with a non-ANSI          */
  /* compiler.                                                             */
  /*                                                                       */
  /* Note however that if some specific modifications are needed, we       */
  /* advise you to place a modified copy in your build directory.          */
  /*                                                                       */
  /* The build directory is usually `freetype/builds/<system>', and        */
  /* contains system-specific files that are always included first when    */
  /* building the library.                                                 */
  /*                                                                       */
  /* This ANSI version should stay in `include/freetype/config'.           */
  /*                                                                       */
  /*************************************************************************/

#ifndef __FTCONFIG_H__
#define __FTCONFIG_H__

/***************************************************************************/
/*                                                                         */
/*  ftstdlib.h                                                             */
/*                                                                         */
/*    ANSI-specific library and header configuration file (specification   */
/*    only).                                                               */
/*                                                                         */
/*  Copyright 2002-2007, 2009, 2011-2012 by                                */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This file is used to group all #includes to the ANSI C library that   */
  /* FreeType normally requires.  It also defines macros to rename the     */
  /* standard functions within the FreeType source code.                   */
  /*                                                                       */
  /* Load a file which defines __FTSTDLIB_H__ before this one to override  */
  /* it.                                                                   */
  /*                                                                       */
  /*************************************************************************/


#ifndef __FTSTDLIB_H__
#define __FTSTDLIB_H__


#include <stddef.h>

#define ft_ptrdiff_t  ptrdiff_t


  /**********************************************************************/
  /*                                                                    */
  /*                           integer limits                           */
  /*                                                                    */
  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
  /* of `int' and `long' in bytes at compile-time.  So far, this works  */
  /* for all platforms the library has been tested on.                  */
  /*                                                                    */
  /* Note that on the extremely rare platforms that do not provide      */
  /* integer types that are _exactly_ 16 and 32 bits wide (e.g. some    */
  /* old Crays where `int' is 36 bits), we do not make any guarantee    */
  /* about the correct behaviour of FT2 with all fonts.                 */
  /*                                                                    */
  /* In these case, `ftconfig.h' will refuse to compile anyway with a   */
  /* message like `couldn't find 32-bit type' or something similar.     */
  /*                                                                    */
  /**********************************************************************/


#include <limits.h>

#define FT_CHAR_BIT    CHAR_BIT
#define FT_USHORT_MAX  USHRT_MAX
#define FT_INT_MAX     INT_MAX
#define FT_INT_MIN     INT_MIN
#define FT_UINT_MAX    UINT_MAX
#define FT_ULONG_MAX   ULONG_MAX


  /**********************************************************************/
  /*                                                                    */
  /*                 character and string processing                    */
  /*                                                                    */
  /**********************************************************************/


#include <string.h>

#define ft_memchr   memchr
#define ft_memcmp   memcmp
#define ft_memcpy   memcpy
#define ft_memmove  memmove
#define ft_memset   memset
#define ft_strcat   strcat
#define ft_strcmp   strcmp
#define ft_strcpy   strcpy
#define ft_strlen   strlen
#define ft_strncmp  strncmp
#define ft_strncpy  strncpy
#define ft_strrchr  strrchr
#define ft_strstr   strstr


  /**********************************************************************/
  /*                                                                    */
  /*                           file handling                            */
  /*                                                                    */
  /**********************************************************************/


#include <stdio.h>

#define FT_FILE     FILE
#define ft_fclose   fclose
#define ft_fopen    fopen
#define ft_fread    fread
#define ft_fseek    fseek
#define ft_ftell    ftell
#define ft_sprintf  sprintf


  /**********************************************************************/
  /*                                                                    */
  /*                             sorting                                */
  /*                                                                    */
  /**********************************************************************/


#include <stdlib.h>

#define ft_qsort  qsort


  /**********************************************************************/
  /*                                                                    */
  /*                        memory allocation                           */
  /*                                                                    */
  /**********************************************************************/


#define ft_scalloc   calloc
#define ft_sfree     free
#define ft_smalloc   malloc
#define ft_srealloc  realloc


  /**********************************************************************/
  /*                                                                    */
  /*                          miscellaneous                             */
  /*                                                                    */
  /**********************************************************************/


#define ft_atol   atol
#define ft_labs   labs


  /**********************************************************************/
  /*                                                                    */
  /*                         execution control                          */
  /*                                                                    */
  /**********************************************************************/


#include <setjmp.h>

#define ft_jmp_buf     jmp_buf  /* note: this cannot be a typedef since */
                                /*       jmp_buf is defined as a macro  */
                                /*       on certain platforms           */

#define ft_longjmp     longjmp
#define ft_setjmp( b ) setjmp( *(ft_jmp_buf*) &(b) ) /* same thing here */


  /* the following is only used for debugging purposes, i.e., if */
  /* FT_DEBUG_LEVEL_ERROR or FT_DEBUG_LEVEL_TRACE are defined    */

#include <stdarg.h>


#endif /* __FTSTDLIB_H__ */


/* END */


FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /*               PLATFORM-SPECIFIC CONFIGURATION MACROS                  */
  /*                                                                       */
  /* These macros can be toggled to suit a specific system.  The current   */
  /* ones are defaults used to compile FreeType in an ANSI C environment   */
  /* (16bit compilers are also supported).  Copy this file to your own     */
  /* `freetype/builds/<system>' directory, and edit it to port the engine. */
  /*                                                                       */
  /*************************************************************************/


  /* There are systems (like the Texas Instruments 'C54x) where a `char' */
  /* has 16 bits.  ANSI C says that sizeof(char) is always 1.  Since an  */
  /* `int' has 16 bits also for this system, sizeof(int) gives 1 which   */
  /* is probably unexpected.                                             */
  /*                                                                     */
  /* `CHAR_BIT' (defined in limits.h) gives the number of bits in a      */
  /* `char' type.                                                        */

#ifndef FT_CHAR_BIT
#define FT_CHAR_BIT  CHAR_BIT
#endif


  /* The size of an `int' type.  */
#if                                 FT_UINT_MAX == 0xFFFFUL
#define FT_SIZEOF_INT  (16 / FT_CHAR_BIT)
#elif                               FT_UINT_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_INT  (32 / FT_CHAR_BIT)
#elif FT_UINT_MAX > 0xFFFFFFFFUL && FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_INT  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `int' type!"
#endif

  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
  /* DM642) is recognized but avoided.                                   */
#if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
#define FT_SIZEOF_LONG  (64 / FT_CHAR_BIT)
#else
#error "Unsupported size of `long' type!"
#endif


  /* FT_UNUSED is a macro used to indicate that a given parameter is not  */
  /* used -- this is only used to get rid of unpleasant compiler warnings */
#ifndef FT_UNUSED
#define FT_UNUSED( arg )  ( (arg) = (arg) )
#endif


  /*************************************************************************/
  /*                                                                       */
  /*                     AUTOMATIC CONFIGURATION MACROS                    */
  /*                                                                       */
  /* These macros are computed from the ones defined above.  Don't touch   */
  /* their definition, unless you know precisely what you are doing.  No   */
  /* porter should need to mess with them.                                 */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* Mac support                                                           */
  /*                                                                       */
  /*   This is the only necessary change, so it is defined here instead    */
  /*   providing a new configuration file.                                 */
  /*                                                                       */
#if defined( __APPLE__ ) || ( defined( __MWERKS__ ) && defined( macintosh ) )
  /* no Carbon frameworks for 64bit 10.4.x */
  /* AvailabilityMacros.h is available since Mac OS X 10.2,        */
  /* so guess the system version by maximum errno before inclusion */
#include <errno.h>
#ifdef ECANCELED /* defined since 10.2 */
#endif
#if defined( __LP64__ ) && \
    ( MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 )
#undef FT_MACINTOSH
#endif

#elif defined( __SC__ ) || defined( __MRC__ )
  /* Classic MacOS compilers */
#if TARGET_OS_MAC
#define FT_MACINTOSH 1
#endif

#endif


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int16                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit signed integer type.                         */
  /*                                                                       */
  typedef signed short  FT_Int16;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt16                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 16bit unsigned integer type.                       */
  /*                                                                       */
  typedef unsigned short  FT_UInt16;

  /* */


  /* this #if 0 ... #endif clause is for documentation purposes */
#if 0

  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int32                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for a 32bit signed integer type.  The size depends on    */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef signed XXX  FT_Int32;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt32                                                          */
  /*                                                                       */
  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
  /*    the configuration.                                                 */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt32;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int64                                                           */
  /*                                                                       */
  /*    A typedef for a 64bit signed integer type.  The size depends on    */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef signed XXX  FT_Int64;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt64                                                          */
  /*                                                                       */
  /*    A typedef for a 64bit unsigned integer type.  The size depends on  */
  /*    the configuration.  Only defined if there is real 64bit support;   */
  /*    otherwise, it gets emulated with a structure (if necessary).       */
  /*                                                                       */
  typedef unsigned XXX  FT_UInt64;

  /* */

#endif

#if FT_SIZEOF_INT == (32 / FT_CHAR_BIT)

  typedef signed int      FT_Int32;
  typedef unsigned int    FT_UInt32;

#elif FT_SIZEOF_LONG == (32 / FT_CHAR_BIT)

  typedef signed long     FT_Int32;
  typedef unsigned long   FT_UInt32;

#else
#error "no 32bit type found -- please check your configuration files"
#endif


  /* look up an integer type that is at least 32 bits */
#if FT_SIZEOF_INT >= (32 / FT_CHAR_BIT)

  typedef int            FT_Fast;
  typedef unsigned int   FT_UFast;

#elif FT_SIZEOF_LONG >= (32 / FT_CHAR_BIT)

  typedef long           FT_Fast;
  typedef unsigned long  FT_UFast;

#endif


  /* determine whether we have a 64-bit int type for platforms without */
  /* Autoconf                                                          */
#if FT_SIZEOF_LONG == (64 / FT_CHAR_BIT)

  /* FT_LONG64 must be defined if a 64-bit type is available */
#define FT_LONG64
#define FT_INT64   long
#define FT_UINT64  unsigned long

#elif defined( _MSC_VER ) && _MSC_VER >= 900  /* Visual C++ (and Intel C++) */

  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64

#elif defined( __BORLANDC__ )  /* Borland C++ */

  /* XXXX: We should probably check the value of __BORLANDC__ in order */
  /*       to test the compiler version.                               */

  /* this compiler provides the __int64 type */
#define FT_LONG64
#define FT_INT64   __int64
#define FT_UINT64  unsigned __int64

#elif defined( __WATCOMC__ )   /* Watcom C++ */

  /* Watcom doesn't provide 64-bit data types */

#elif defined( __MWERKS__ )    /* Metrowerks CodeWarrior */

#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int

#elif defined( __GNUC__ )

  /* GCC provides the `long long' type */
#define FT_LONG64
#define FT_INT64   long long int
#define FT_UINT64  unsigned long long int

#endif /* FT_SIZEOF_LONG == (64 / FT_CHAR_BIT) */


  /*************************************************************************/
  /*                                                                       */
  /* A 64-bit data type will create compilation problems if you compile    */
  /* in strict ANSI mode.  To avoid them, we disable its use if __STDC__   */
  /* is defined.  You can however ignore this rule by defining the         */
  /* FT_CONFIG_OPTION_FORCE_INT64 configuration macro.                     */
  /*                                                                       */
#if defined( FT_LONG64 ) && !defined( FT_CONFIG_OPTION_FORCE_INT64 )

#ifdef __STDC__

  /* undefine the 64-bit macros in strict ANSI compilation mode */
#undef FT_LONG64
#undef FT_INT64

#endif /* __STDC__ */

#endif /* FT_LONG64 && !FT_CONFIG_OPTION_FORCE_INT64 */

#ifdef FT_LONG64
  typedef FT_INT64   FT_Int64;
  typedef FT_UINT64  FT_UInt64;
#endif


#define FT_BEGIN_STMNT  do {
#define FT_END_STMNT    } while ( 0 )
#define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT


#ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
  /* Provide assembler fragments for performance-critical functions. */
  /* These must be defined `static __inline__' with GCC.             */

#if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm

  /* documentation is in freetype.h */

  static __inline FT_Int32
  FT_MulFix_arm( FT_Int32  a,
                 FT_Int32  b )
  {
    register FT_Int32  t, t2;


    __asm
    {
      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
      mov   a,  t,  asr #31         /* a   = (hi >> 31) */
      add   a,  a,  #0x8000         /* a  += 0x8000 */
      adds  t2, t2, a               /* t2 += a */
      adc   t,  t,  #0              /* t  += carry */
      mov   a,  t2, lsr #16         /* a   = t2 >> 16 */
      orr   a,  a,  t,  lsl #16     /* a  |= t << 16 */
    }
    return a;
  }

#endif /* __CC_ARM || __ARMCC__ */


#ifdef __GNUC__

#if defined( __arm__ ) && !defined( __thumb__ )    && \
    !( defined( __CC_ARM ) || defined( __ARMCC__ ) )
#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm

  /* documentation is in freetype.h */

  static __inline__ FT_Int32
  FT_MulFix_arm( FT_Int32  a,
                 FT_Int32  b )
  {
    register FT_Int32  t, t2;


    __asm__ __volatile__ (
      "smull  %1, %2, %4, %3\n\t"       /* (lo=%1,hi=%2) = a*b */
      "mov    %0, %2, asr #31\n\t"      /* %0  = (hi >> 31) */
      "add    %0, %0, #0x8000\n\t"      /* %0 += 0x8000 */
      "adds   %1, %1, %0\n\t"           /* %1 += %0 */
      "adc    %2, %2, #0\n\t"           /* %2 += carry */
      "mov    %0, %1, lsr #16\n\t"      /* %0  = %1 >> 16 */
      "orr    %0, %0, %2, lsl #16\n\t"  /* %0 |= %2 << 16 */
      : "=r"(a), "=&r"(t2), "=&r"(t)
      : "r"(a), "r"(b)
      : "cc" );
    return a;
  }

#endif /* __arm__ && !__thumb__ && !( __CC_ARM || __ARMCC__ ) */

#if defined( __i386__ )
#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386

  /* documentation is in freetype.h */

  static __inline__ FT_Int32
  FT_MulFix_i386( FT_Int32  a,
                  FT_Int32  b )
  {
    register FT_Int32  result;


    __asm__ __volatile__ (
      "imul  %%edx\n"
      "movl  %%edx, %%ecx\n"
      "sarl  $31, %%ecx\n"
      "addl  $0x8000, %%ecx\n"
      "addl  %%ecx, %%eax\n"
      "adcl  $0, %%edx\n"
      "shrl  $16, %%eax\n"
      "shll  $16, %%edx\n"
      "addl  %%edx, %%eax\n"
      : "=a"(result), "=d"(b)
      : "a"(a), "d"(b)
      : "%ecx", "cc" );
    return result;
  }

#endif /* i386 */

#endif /* __GNUC__ */


#ifdef _MSC_VER /* Visual C++ */

#ifdef _M_IX86

#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386

  /* documentation is in freetype.h */

  static __inline FT_Int32
  FT_MulFix_i386( FT_Int32  a,
                  FT_Int32  b )
  {
    register FT_Int32  result;

    __asm
    {
      mov eax, a
      mov edx, b
      imul edx
      mov ecx, edx
      sar ecx, 31
      add ecx, 8000h
      add eax, ecx
      adc edx, 0
      shr eax, 16
      shl edx, 16
      add eax, edx
      mov result, eax
    }
    return result;
  }

#endif /* _M_IX86 */

#endif /* _MSC_VER */

#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */


#ifdef FT_CONFIG_OPTION_INLINE_MULFIX
#ifdef FT_MULFIX_ASSEMBLER
#define FT_MULFIX_INLINED  FT_MULFIX_ASSEMBLER
#endif
#endif


#ifdef FT_MAKE_OPTION_SINGLE_OBJECT

#define FT_LOCAL( x )      static  x
#define FT_LOCAL_DEF( x )  static  x

#else

#ifdef __cplusplus
#define FT_LOCAL( x )      extern "C"  x
#define FT_LOCAL_DEF( x )  extern "C"  x
#else
#define FT_LOCAL( x )      extern  x
#define FT_LOCAL_DEF( x )  x
#endif

#endif /* FT_MAKE_OPTION_SINGLE_OBJECT */


#ifndef FT_BASE

#ifdef __cplusplus
#define FT_BASE( x )  extern "C"  x
#else
#define FT_BASE( x )  extern  x
#endif

#endif /* !FT_BASE */


#ifndef FT_BASE_DEF

#ifdef __cplusplus
#define FT_BASE_DEF( x )  x
#else
#define FT_BASE_DEF( x )  x
#endif

#endif /* !FT_BASE_DEF */


#ifndef FT_EXPORT

#ifdef __cplusplus
#define FT_EXPORT( x )  extern "C"  x
#else
#define FT_EXPORT( x )  extern  x
#endif

#endif /* !FT_EXPORT */


#ifndef FT_EXPORT_DEF

#ifdef __cplusplus
#define FT_EXPORT_DEF( x )  extern "C"  x
#else
#define FT_EXPORT_DEF( x )  extern  x
#endif

#endif /* !FT_EXPORT_DEF */


#ifndef FT_EXPORT_VAR

#ifdef __cplusplus
#define FT_EXPORT_VAR( x )  extern "C"  x
#else
#define FT_EXPORT_VAR( x )  extern  x
#endif

#endif /* !FT_EXPORT_VAR */

  /* The following macros are needed to compile the library with a   */
  /* C++ compiler and with 16bit compilers.                          */
  /*                                                                 */

  /* This is special.  Within C++, you must specify `extern "C"' for */
  /* functions which are used via function pointers, and you also    */
  /* must do that for structures which contain function pointers to  */
  /* assure C linkage -- it's not possible to have (local) anonymous */
  /* functions which are accessed by (global) function pointers.     */
  /*                                                                 */
  /*                                                                 */
  /* FT_CALLBACK_DEF is used to _define_ a callback function.        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
  /* contains pointers to callback functions.                        */
  /*                                                                 */
  /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
  /* that contains pointers to callback functions.                   */
  /*                                                                 */
  /*                                                                 */
  /* Some 16bit compilers have to redefine these macros to insert    */
  /* the infamous `_cdecl' or `__fastcall' declarations.             */
  /*                                                                 */
#ifndef FT_CALLBACK_DEF
#ifdef __cplusplus
#define FT_CALLBACK_DEF( x )  extern "C"  x
#else
#define FT_CALLBACK_DEF( x )  static  x
#endif
#endif /* FT_CALLBACK_DEF */

#ifndef FT_CALLBACK_TABLE
#ifdef __cplusplus
#define FT_CALLBACK_TABLE      extern "C"
#define FT_CALLBACK_TABLE_DEF  extern "C"
#else
#define FT_CALLBACK_TABLE      extern
#define FT_CALLBACK_TABLE_DEF  /* nothing */
#endif
#endif /* FT_CALLBACK_TABLE */


FT_END_HEADER


#endif /* __FTCONFIG_H__ */


/* END */
/***************************************************************************/
/*                                                                         */
/*  ftsystem.h                                                             */
/*                                                                         */
/*    FreeType low-level system interface definition (specification).      */
/*                                                                         */
/*  Copyright 1996-2001, 2002, 2005, 2010 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef __FTSYSTEM_H__
#define __FTSYSTEM_H__




FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*   system_interface                                                    */
  /*                                                                       */
  /* <Title>                                                               */
  /*   System Interface                                                    */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*   How FreeType manages memory and i/o.                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*   This section contains various definitions related to memory         */
  /*   management and i/o access.  You need to understand this             */
  /*   information if you want to use a custom memory manager or you own   */
  /*   i/o streams.                                                        */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /*                  M E M O R Y   M A N A G E M E N T                    */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************
   *
   * @type:
   *   FT_Memory
   *
   * @description:
   *   A handle to a given memory manager object, defined with an
   *   @FT_MemoryRec structure.
   *
   */
  typedef struct FT_MemoryRec_*  FT_Memory;


  /*************************************************************************
   *
   * @functype:
   *   FT_Alloc_Func
   *
   * @description:
   *   A function used to allocate `size' bytes from `memory'.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   size ::
   *     The size in bytes to allocate.
   *
   * @return:
   *   Address of new memory block.  0~in case of failure.
   *
   */
  typedef void*
  (*FT_Alloc_Func)( FT_Memory  memory,
                    long       size );


  /*************************************************************************
   *
   * @functype:
   *   FT_Free_Func
   *
   * @description:
   *   A function used to release a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   block ::
   *     The address of the target memory block.
   *
   */
  typedef void
  (*FT_Free_Func)( FT_Memory  memory,
                   void*      block );


  /*************************************************************************
   *
   * @functype:
   *   FT_Realloc_Func
   *
   * @description:
   *   A function used to re-allocate a given block of memory.
   *
   * @input:
   *   memory ::
   *     A handle to the source memory manager.
   *
   *   cur_size ::
   *     The block's current size in bytes.
   *
   *   new_size ::
   *     The block's requested new size.
   *
   *   block ::
   *     The block's current address.
   *
   * @return:
   *   New block address.  0~in case of memory shortage.
   *
   * @note:
   *   In case of error, the old block must still be available.
   *
   */
  typedef void*
  (*FT_Realloc_Func)( FT_Memory  memory,
                      long       cur_size,
                      long       new_size,
                      void*      block );


  /*************************************************************************
   *
   * @struct:
   *   FT_MemoryRec
   *
   * @description:
   *   A structure used to describe a given memory manager to FreeType~2.
   *
   * @fields:
   *   user ::
   *     A generic typeless pointer for user data.
   *
   *   alloc ::
   *     A pointer type to an allocation function.
   *
   *   free ::
   *     A pointer type to an memory freeing function.
   *
   *   realloc ::
   *     A pointer type to a reallocation function.
   *
   */
  struct  FT_MemoryRec_
  {
    void*            user;
    FT_Alloc_Func    alloc;
    FT_Free_Func     free;
    FT_Realloc_Func  realloc;
  };


  /*************************************************************************/
  /*                                                                       */
  /*                       I / O   M A N A G E M E N T                     */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************
   *
   * @type:
   *   FT_Stream
   *
   * @description:
   *   A handle to an input stream.
   *
   */
  typedef struct FT_StreamRec_*  FT_Stream;


  /*************************************************************************
   *
   * @struct:
   *   FT_StreamDesc
   *
   * @description:
   *   A union type used to store either a long or a pointer.  This is used
   *   to store a file descriptor or a `FILE*' in an input stream.
   *
   */
  typedef union  FT_StreamDesc_
  {
    long   value;
    void*  pointer;

  } FT_StreamDesc;


  /*************************************************************************
   *
   * @functype:
   *   FT_Stream_IoFunc
   *
   * @description:
   *   A function used to seek and read data from a given input stream.
   *
   * @input:
   *   stream ::
   *     A handle to the source stream.
   *
   *   offset ::
   *     The offset of read in stream (always from start).
   *
   *   buffer ::
   *     The address of the read buffer.
   *
   *   count ::
   *     The number of bytes to read from the stream.
   *
   * @return:
   *   The number of bytes effectively read by the stream.
   *
   * @note:
   *   This function might be called to perform a seek or skip operation
   *   with a `count' of~0.  A non-zero return value then indicates an
   *   error.
   *
   */
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream       stream,
                       unsigned long   offset,
                       unsigned char*  buffer,
                       unsigned long   count );


  /*************************************************************************
   *
   * @functype:
   *   FT_Stream_CloseFunc
   *
   * @description:
   *   A function used to close a given input stream.
   *
   * @input:
   *  stream ::
   *     A handle to the target stream.
   *
   */
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream  stream );


  /*************************************************************************
   *
   * @struct:
   *   FT_StreamRec
   *
   * @description:
   *   A structure used to describe an input stream.
   *
   * @input:
   *   base ::
   *     For memory-based streams, this is the address of the first stream
   *     byte in memory.  This field should always be set to NULL for
   *     disk-based streams.
   *
   *   size ::
   *     The stream size in bytes.
   *
   *   pos ::
   *     The current position within the stream.
   *
   *   descriptor ::
   *     This field is a union that can hold an integer or a pointer.  It is
   *     used by stream implementations to store file descriptors or `FILE*'
   *     pointers.
   *
   *   pathname ::
   *     This field is completely ignored by FreeType.  However, it is often
   *     useful during debugging to use it to store the stream's filename
   *     (where available).
   *
   *   read ::
   *     The stream's input function.
   *
   *   close ::
   *     The stream's close function.
   *
   *   memory ::
   *     The memory manager to use to preload frames.  This is set
   *     internally by FreeType and shouldn't be touched by stream
   *     implementations.
   *
   *   cursor ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   *   limit ::
   *     This field is set and used internally by FreeType when parsing
   *     frames.
   *
   */
  typedef struct  FT_StreamRec_
  {
    unsigned char*       base;
    unsigned long        size;
    unsigned long        pos;

    FT_StreamDesc        descriptor;
    FT_StreamDesc        pathname;
    FT_Stream_IoFunc     read;
    FT_Stream_CloseFunc  close;

    FT_Memory            memory;
    unsigned char*       cursor;
    unsigned char*       limit;

  } FT_StreamRec;


  /* */


FT_END_HEADER

#endif /* __FTSYSTEM_H__ */


/* END */
/***************************************************************************/
/*                                                                         */
/*  ftimage.h                                                              */
/*                                                                         */
/*    FreeType glyph image formats and default raster interface            */
/*    (specification).                                                     */
/*                                                                         */
/*  Copyright 1996-2010, 2013 by                                           */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* Note: A `raster' is simply a scan-line converter, used to render      */
  /*       FT_Outlines into FT_Bitmaps.                                    */
  /*                                                                       */
  /*************************************************************************/


#ifndef __FTIMAGE_H__
#define __FTIMAGE_H__


  /* _STANDALONE_ is from ftgrays.c */
#ifndef _STANDALONE_
#endif


FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Pos                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The type FT_Pos is used to store vectorial coordinates.  Depending */
  /*    on the context, these can represent distances in integer font      */
  /*    units, or 16.16, or 26.6 fixed-point pixel coordinates.            */
  /*                                                                       */
  typedef signed long  FT_Pos;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Vector                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2D vector; coordinates are of   */
  /*    the FT_Pos type.                                                   */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x :: The horizontal coordinate.                                    */
  /*    y :: The vertical coordinate.                                      */
  /*                                                                       */
  typedef struct  FT_Vector_
  {
    FT_Pos  x;
    FT_Pos  y;

  } FT_Vector;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_BBox                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold an outline's bounding box, i.e., the      */
  /*    coordinates of its extrema in the horizontal and vertical          */
  /*    directions.                                                        */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    xMin :: The horizontal minimum (left-most).                        */
  /*                                                                       */
  /*    yMin :: The vertical minimum (bottom-most).                        */
  /*                                                                       */
  /*    xMax :: The horizontal maximum (right-most).                       */
  /*                                                                       */
  /*    yMax :: The vertical maximum (top-most).                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The bounding box is specified with the coordinates of the lower    */
  /*    left and the upper right corner.  In PostScript, those values are  */
  /*    often called (llx,lly) and (urx,ury), respectively.                */
  /*                                                                       */
  /*    If `yMin' is negative, this value gives the glyph's descender.     */
  /*    Otherwise, the glyph doesn't descend below the baseline.           */
  /*    Similarly, if `ymax' is positive, this value gives the glyph's     */
  /*    ascender.                                                          */
  /*                                                                       */
  /*    `xMin' gives the horizontal distance from the glyph's origin to    */
  /*    the left edge of the glyph's bounding box.  If `xMin' is negative, */
  /*    the glyph extends to the left of the origin.                       */
  /*                                                                       */
  typedef struct  FT_BBox_
  {
    FT_Pos  xMin, yMin;
    FT_Pos  xMax, yMax;

  } FT_BBox;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Pixel_Mode                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type used to describe the format of pixels in a     */
  /*    given bitmap.  Note that additional formats may be added in the    */
  /*    future.                                                            */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_PIXEL_MODE_NONE ::                                              */
  /*      Value~0 is reserved.                                             */
  /*                                                                       */
  /*    FT_PIXEL_MODE_MONO ::                                              */
  /*      A monochrome bitmap, using 1~bit per pixel.  Note that pixels    */
  /*      are stored in most-significant order (MSB), which means that     */
  /*      the left-most pixel in a byte has value 128.                     */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY ::                                              */
  /*      An 8-bit bitmap, generally used to represent anti-aliased glyph  */
  /*      images.  Each pixel is stored in one byte.  Note that the number */
  /*      of `gray' levels is stored in the `num_grays' field of the       */
  /*      @FT_Bitmap structure (it generally is 256).                      */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY2 ::                                             */
  /*      A 2-bit per pixel bitmap, used to represent embedded             */
  /*      anti-aliased bitmaps in font files according to the OpenType     */
  /*      specification.  We haven't found a single font using this        */
  /*      format, however.                                                 */
  /*                                                                       */
  /*    FT_PIXEL_MODE_GRAY4 ::                                             */
  /*      A 4-bit per pixel bitmap, representing embedded anti-aliased     */
  /*      bitmaps in font files according to the OpenType specification.   */
  /*      We haven't found a single font using this format, however.       */
  /*                                                                       */
  /*    FT_PIXEL_MODE_LCD ::                                               */
  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
  /*      used for display on LCD displays; the bitmap is three times      */
  /*      wider than the original glyph image.  See also                   */
  /*      @FT_RENDER_MODE_LCD.                                             */
  /*                                                                       */
  /*    FT_PIXEL_MODE_LCD_V ::                                             */
  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
  /*      used for display on rotated LCD displays; the bitmap is three    */
  /*      times taller than the original glyph image.  See also            */
  /*      @FT_RENDER_MODE_LCD_V.                                           */
  /*                                                                       */
  /*    FT_PIXEL_MODE_BGRA ::                                              */
  /*      An image with four 8-bit channels per pixel, representing a      */
  /*      color image (such as emoticons) with alpha channel.  For each    */
  /*      pixel, the format is BGRA, which means, the blue channel comes   */
  /*      first in memory.  The color channels are pre-multiplied and in   */
  /*      the sRGB colorspace.  For example, full red at half-translucent  */
  /*      opacity will be represented as `00,00,80,80', not `00,00,FF,80'. */
  /*      See also @FT_LOAD_COLOR.                                         */
  /*                                                                       */
  typedef enum  FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX      /* do not remove */

  } FT_Pixel_Mode;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    ft_pixel_mode_xxx                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of deprecated constants.  Use the corresponding             */
  /*    @FT_Pixel_Mode values instead.                                     */
  /*                                                                       */
  /* <Values>                                                              */
  /*    ft_pixel_mode_none  :: See @FT_PIXEL_MODE_NONE.                    */
  /*    ft_pixel_mode_mono  :: See @FT_PIXEL_MODE_MONO.                    */
  /*    ft_pixel_mode_grays :: See @FT_PIXEL_MODE_GRAY.                    */
  /*    ft_pixel_mode_pal2  :: See @FT_PIXEL_MODE_GRAY2.                   */
  /*    ft_pixel_mode_pal4  :: See @FT_PIXEL_MODE_GRAY4.                   */
  /*                                                                       */
#define ft_pixel_mode_none   FT_PIXEL_MODE_NONE
#define ft_pixel_mode_mono   FT_PIXEL_MODE_MONO
#define ft_pixel_mode_grays  FT_PIXEL_MODE_GRAY
#define ft_pixel_mode_pal2   FT_PIXEL_MODE_GRAY2
#define ft_pixel_mode_pal4   FT_PIXEL_MODE_GRAY4

 /* */

#if 0

  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Palette_Mode                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT!                           */
  /*                                                                       */
  /*    An enumeration type to describe the format of a bitmap palette,    */
  /*    used with ft_pixel_mode_pal4 and ft_pixel_mode_pal8.               */
  /*                                                                       */
  /* <Values>                                                              */
  /*    ft_palette_mode_rgb  :: The palette is an array of 3-byte RGB      */
  /*                            records.                                   */
  /*                                                                       */
  /*    ft_palette_mode_rgba :: The palette is an array of 4-byte RGBA     */
  /*                            records.                                   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    As ft_pixel_mode_pal2, pal4 and pal8 are currently unused by       */
  /*    FreeType, these types are not handled by the library itself.       */
  /*                                                                       */
  typedef enum  FT_Palette_Mode_
  {
    ft_palette_mode_rgb = 0,
    ft_palette_mode_rgba,

    ft_palette_mode_max   /* do not remove */

  } FT_Palette_Mode;

  /* */

#endif


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Bitmap                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to describe a bitmap or pixmap to the raster.     */
  /*    Note that we now manage pixmaps of various depths through the      */
  /*    `pixel_mode' field.                                                */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    rows         :: The number of bitmap rows.                         */
  /*                                                                       */
  /*    width        :: The number of pixels in bitmap row.                */
  /*                                                                       */
  /*    pitch        :: The pitch's absolute value is the number of bytes  */
  /*                    taken by one bitmap row, including padding.        */
  /*                    However, the pitch is positive when the bitmap has */
  /*                    a `down' flow, and negative when it has an `up'    */
  /*                    flow.  In all cases, the pitch is an offset to add */
  /*                    to a bitmap pointer in order to go down one row.   */
  /*                                                                       */
  /*                    Note that `padding' means the alignment of a       */
  /*                    bitmap to a byte border, and FreeType functions    */
  /*                    normally align to the smallest possible integer    */
  /*                    value.                                             */
  /*                                                                       */
  /*                    For the B/W rasterizer, `pitch' is always an even  */
  /*                    number.                                            */
  /*                                                                       */
  /*                    To change the pitch of a bitmap (say, to make it a */
  /*                    multiple of 4), use @FT_Bitmap_Convert.            */
  /*                    Alternatively, you might use callback functions to */
  /*                    directly render to the application's surface; see  */
  /*                    the file `example2.cpp' in the tutorial for a      */
  /*                    demonstration.                                     */
  /*                                                                       */
  /*    buffer       :: A typeless pointer to the bitmap buffer.  This     */
  /*                    value should be aligned on 32-bit boundaries in    */
  /*                    most cases.                                        */
  /*                                                                       */
  /*    num_grays    :: This field is only used with                       */
  /*                    @FT_PIXEL_MODE_GRAY; it gives the number of gray   */
  /*                    levels used in the bitmap.                         */
  /*                                                                       */
  /*    pixel_mode   :: The pixel mode, i.e., how pixel bits are stored.   */
  /*                    See @FT_Pixel_Mode for possible values.            */
  /*                                                                       */
  /*    palette_mode :: This field is intended for paletted pixel modes;   */
  /*                    it indicates how the palette is stored.  Not       */
  /*                    used currently.                                    */
  /*                                                                       */
  /*    palette      :: A typeless pointer to the bitmap palette; this     */
  /*                    field is intended for paletted pixel modes.  Not   */
  /*                    used currently.                                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*   For now, the only pixel modes supported by FreeType are mono and    */
  /*   grays.  However, drivers might be added in the future to support    */
  /*   more `colorful' options.                                            */
  /*                                                                       */
  typedef struct  FT_Bitmap_
  {
    int             rows;
    int             width;
    int             pitch;
    unsigned char*  buffer;
    short           num_grays;
    char            pixel_mode;
    char            palette_mode;
    void*           palette;

  } FT_Bitmap;


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    outline_processing                                                 */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Outline                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This structure is used to describe an outline to the scan-line     */
  /*    converter.                                                         */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    n_contours :: The number of contours in the outline.               */
  /*                                                                       */
  /*    n_points   :: The number of points in the outline.                 */
  /*                                                                       */
  /*    points     :: A pointer to an array of `n_points' @FT_Vector       */
  /*                  elements, giving the outline's point coordinates.    */
  /*                                                                       */
  /*    tags       :: A pointer to an array of `n_points' chars, giving    */
  /*                  each outline point's type.                           */
  /*                                                                       */
  /*                  If bit~0 is unset, the point is `off' the curve,     */
  /*                  i.e., a Bzier control point, while it is `on' if    */
  /*                  set.                                                 */
  /*                                                                       */
  /*                  Bit~1 is meaningful for `off' points only.  If set,  */
  /*                  it indicates a third-order Bzier arc control point; */
  /*                  and a second-order control point if unset.           */
  /*                                                                       */
  /*                  If bit~2 is set, bits 5-7 contain the drop-out mode  */
  /*                  (as defined in the OpenType specification; the value */
  /*                  is the same as the argument to the SCANMODE          */
  /*                  instruction).                                        */
  /*                                                                       */
  /*                  Bits 3 and~4 are reserved for internal purposes.     */
  /*                                                                       */
  /*    contours   :: An array of `n_contours' shorts, giving the end      */
  /*                  point of each contour within the outline.  For       */
  /*                  example, the first contour is defined by the points  */
  /*                  `0' to `contours[0]', the second one is defined by   */
  /*                  the points `contours[0]+1' to `contours[1]', etc.    */
  /*                                                                       */
  /*    flags      :: A set of bit flags used to characterize the outline  */
  /*                  and give hints to the scan-converter and hinter on   */
  /*                  how to convert/grid-fit it.  See @FT_OUTLINE_FLAGS.  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The B/W rasterizer only checks bit~2 in the `tags' array for the   */
  /*    first point of each contour.  The drop-out mode as given with      */
  /*    @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and       */
  /*    @FT_OUTLINE_INCLUDE_STUBS in `flags' is then overridden.           */
  /*                                                                       */
  typedef struct  FT_Outline_
  {
    short       n_contours;      /* number of contours in glyph        */
    short       n_points;        /* number of points in the glyph      */

    FT_Vector*  points;          /* the outline's points               */
    char*       tags;            /* the points flags                   */
    short*      contours;        /* the contour end points             */

    int         flags;           /* outline masks                      */

  } FT_Outline;

  /* Following limits must be consistent with */
  /* FT_Outline.{n_contours,n_points}         */
#define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX
#define FT_OUTLINE_POINTS_MAX    SHRT_MAX


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_OUTLINE_FLAGS                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit-field constants use for the flags in an outline's    */
  /*    `flags' field.                                                     */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_OUTLINE_NONE ::                                                 */
  /*      Value~0 is reserved.                                             */
  /*                                                                       */
  /*    FT_OUTLINE_OWNER ::                                                */
  /*      If set, this flag indicates that the outline's field arrays      */
  /*      (i.e., `points', `flags', and `contours') are `owned' by the     */
  /*      outline object, and should thus be freed when it is destroyed.   */
  /*                                                                       */
  /*    FT_OUTLINE_EVEN_ODD_FILL ::                                        */
  /*      By default, outlines are filled using the non-zero winding rule. */
  /*      If set to 1, the outline will be filled using the even-odd fill  */
  /*      rule (only works with the smooth rasterizer).                    */
  /*                                                                       */
  /*    FT_OUTLINE_REVERSE_FILL ::                                         */
  /*      By default, outside contours of an outline are oriented in       */
  /*      clock-wise direction, as defined in the TrueType specification.  */
  /*      This flag is set if the outline uses the opposite direction      */
  /*      (typically for Type~1 fonts).  This flag is ignored by the scan  */
  /*      converter.                                                       */
  /*                                                                       */
  /*    FT_OUTLINE_IGNORE_DROPOUTS ::                                      */
  /*      By default, the scan converter will try to detect drop-outs in   */
  /*      an outline and correct the glyph bitmap to ensure consistent     */
  /*      shape continuity.  If set, this flag hints the scan-line         */
  /*      converter to ignore such cases.  See below for more information. */
  /*                                                                       */
  /*    FT_OUTLINE_SMART_DROPOUTS ::                                       */
  /*      Select smart dropout control.  If unset, use simple dropout      */
  /*      control.  Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See    */
  /*      below for more information.                                      */
  /*                                                                       */
  /*    FT_OUTLINE_INCLUDE_STUBS ::                                        */
  /*      If set, turn pixels on for `stubs', otherwise exclude them.      */
  /*      Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See below for    */
  /*      more information.                                                */
  /*                                                                       */
  /*    FT_OUTLINE_HIGH_PRECISION ::                                       */
  /*      This flag indicates that the scan-line converter should try to   */
  /*      convert this outline to bitmaps with the highest possible        */
  /*      quality.  It is typically set for small character sizes.  Note   */
  /*      that this is only a hint that might be completely ignored by a   */
  /*      given scan-converter.                                            */
  /*                                                                       */
  /*    FT_OUTLINE_SINGLE_PASS ::                                          */
  /*      This flag is set to force a given scan-converter to only use a   */
  /*      single pass over the outline to render a bitmap glyph image.     */
  /*      Normally, it is set for very large character sizes.  It is only  */
  /*      a hint that might be completely ignored by a given               */
  /*      scan-converter.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The flags @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, */
  /*    and @FT_OUTLINE_INCLUDE_STUBS are ignored by the smooth            */
  /*    rasterizer.                                                        */
  /*                                                                       */
  /*    There exists a second mechanism to pass the drop-out mode to the   */
  /*    B/W rasterizer; see the `tags' field in @FT_Outline.               */
  /*                                                                       */
  /*    Please refer to the description of the `SCANTYPE' instruction in   */
  /*    the OpenType specification (in file `ttinst1.doc') how simple      */
  /*    drop-outs, smart drop-outs, and stubs are defined.                 */
  /*                                                                       */
#define FT_OUTLINE_NONE             0x0
#define FT_OUTLINE_OWNER            0x1
#define FT_OUTLINE_EVEN_ODD_FILL    0x2
#define FT_OUTLINE_REVERSE_FILL     0x4
#define FT_OUTLINE_IGNORE_DROPOUTS  0x8
#define FT_OUTLINE_SMART_DROPOUTS   0x10
#define FT_OUTLINE_INCLUDE_STUBS    0x20

#define FT_OUTLINE_HIGH_PRECISION   0x100
#define FT_OUTLINE_SINGLE_PASS      0x200


 /*************************************************************************
  *
  * @enum:
  *   ft_outline_flags
  *
  * @description:
  *   These constants are deprecated.  Please use the corresponding
  *   @FT_OUTLINE_FLAGS values.
  *
  * @values:
  *   ft_outline_none            :: See @FT_OUTLINE_NONE.
  *   ft_outline_owner           :: See @FT_OUTLINE_OWNER.
  *   ft_outline_even_odd_fill   :: See @FT_OUTLINE_EVEN_ODD_FILL.
  *   ft_outline_reverse_fill    :: See @FT_OUTLINE_REVERSE_FILL.
  *   ft_outline_ignore_dropouts :: See @FT_OUTLINE_IGNORE_DROPOUTS.
  *   ft_outline_high_precision  :: See @FT_OUTLINE_HIGH_PRECISION.
  *   ft_outline_single_pass     :: See @FT_OUTLINE_SINGLE_PASS.
  */
#define ft_outline_none             FT_OUTLINE_NONE
#define ft_outline_owner            FT_OUTLINE_OWNER
#define ft_outline_even_odd_fill    FT_OUTLINE_EVEN_ODD_FILL
#define ft_outline_reverse_fill     FT_OUTLINE_REVERSE_FILL
#define ft_outline_ignore_dropouts  FT_OUTLINE_IGNORE_DROPOUTS
#define ft_outline_high_precision   FT_OUTLINE_HIGH_PRECISION
#define ft_outline_single_pass      FT_OUTLINE_SINGLE_PASS

  /* */

#define FT_CURVE_TAG( flag )  ( flag & 3 )

#define FT_CURVE_TAG_ON            1
#define FT_CURVE_TAG_CONIC         0
#define FT_CURVE_TAG_CUBIC         2

#define FT_CURVE_TAG_HAS_SCANMODE  4

#define FT_CURVE_TAG_TOUCH_X       8  /* reserved for the TrueType hinter */
#define FT_CURVE_TAG_TOUCH_Y      16  /* reserved for the TrueType hinter */

#define FT_CURVE_TAG_TOUCH_BOTH    ( FT_CURVE_TAG_TOUCH_X | \
                                     FT_CURVE_TAG_TOUCH_Y )

#define FT_Curve_Tag_On       FT_CURVE_TAG_ON
#define FT_Curve_Tag_Conic    FT_CURVE_TAG_CONIC
#define FT_Curve_Tag_Cubic    FT_CURVE_TAG_CUBIC
#define FT_Curve_Tag_Touch_X  FT_CURVE_TAG_TOUCH_X
#define FT_Curve_Tag_Touch_Y  FT_CURVE_TAG_TOUCH_Y


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_MoveToFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `move  */
  /*    to' function during outline walking/decomposition.                 */
  /*                                                                       */
  /*    A `move to' is emitted to start a new contour in an outline.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    to   :: A pointer to the target point of the `move to'.            */
  /*                                                                       */
  /*    user :: A typeless pointer which is passed from the caller of the  */
  /*            decomposition function.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector*  to,
                            void*             user );

#define FT_Outline_MoveTo_Func  FT_Outline_MoveToFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_LineToFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `line  */
  /*    to' function during outline walking/decomposition.                 */
  /*                                                                       */
  /*    A `line to' is emitted to indicate a segment in the outline.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    to   :: A pointer to the target point of the `line to'.            */
  /*                                                                       */
  /*    user :: A typeless pointer which is passed from the caller of the  */
  /*            decomposition function.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector*  to,
                            void*             user );

#define FT_Outline_LineTo_Func  FT_Outline_LineToFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_ConicToFunc                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `conic */
  /*    to' function during outline walking or decomposition.              */
  /*                                                                       */
  /*    A `conic to' is emitted to indicate a second-order Bzier arc in   */
  /*    the outline.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    control :: An intermediate control point between the last position */
  /*               and the new target in `to'.                             */
  /*                                                                       */
  /*    to      :: A pointer to the target end point of the conic arc.     */
  /*                                                                       */
  /*    user    :: A typeless pointer which is passed from the caller of   */
  /*               the decomposition function.                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector*  control,
                             const FT_Vector*  to,
                             void*             user );

#define FT_Outline_ConicTo_Func  FT_Outline_ConicToFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Outline_CubicToFunc                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function pointer type used to describe the signature of a `cubic */
  /*    to' function during outline walking or decomposition.              */
  /*                                                                       */
  /*    A `cubic to' is emitted to indicate a third-order Bzier arc.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    control1 :: A pointer to the first Bzier control point.           */
  /*                                                                       */
  /*    control2 :: A pointer to the second Bzier control point.          */
  /*                                                                       */
  /*    to       :: A pointer to the target end point.                     */
  /*                                                                       */
  /*    user     :: A typeless pointer which is passed from the caller of  */
  /*                the decomposition function.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector*  control1,
                             const FT_Vector*  control2,
                             const FT_Vector*  to,
                             void*             user );

#define FT_Outline_CubicTo_Func  FT_Outline_CubicToFunc


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Outline_Funcs                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to hold various function pointers used during outline  */
  /*    decomposition in order to emit segments, conic, and cubic Bziers. */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    move_to  :: The `move to' emitter.                                 */
  /*                                                                       */
  /*    line_to  :: The segment emitter.                                   */
  /*                                                                       */
  /*    conic_to :: The second-order Bzier arc emitter.                   */
  /*                                                                       */
  /*    cubic_to :: The third-order Bzier arc emitter.                    */
  /*                                                                       */
  /*    shift    :: The shift that is applied to coordinates before they   */
  /*                are sent to the emitter.                               */
  /*                                                                       */
  /*    delta    :: The delta that is applied to coordinates before they   */
  /*                are sent to the emitter, but after the shift.          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The point coordinates sent to the emitters are the transformed     */
  /*    version of the original coordinates (this is important for high    */
  /*    accuracy during scan-conversion).  The transformation is simple:   */
  /*                                                                       */
  /*    {                                                                  */
  /*      x' = (x << shift) - delta                                        */
  /*      y' = (x << shift) - delta                                        */
  /*    }                                                                  */
  /*                                                                       */
  /*    Set the values of `shift' and `delta' to~0 to get the original     */
  /*    point coordinates.                                                 */
  /*                                                                       */
  typedef struct  FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc   move_to;
    FT_Outline_LineToFunc   line_to;
    FT_Outline_ConicToFunc  conic_to;
    FT_Outline_CubicToFunc  cubic_to;

    int                     shift;
    FT_Pos                  delta;

  } FT_Outline_Funcs;


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_IMAGE_TAG                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags to an unsigned long type.     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
  /*    should redefine this macro in case of problems to something like   */
  /*    this:                                                              */
  /*                                                                       */
  /*    {                                                                  */
  /*      #define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  value         */
  /*    }                                                                  */
  /*                                                                       */
  /*    to get a simple enumeration without assigning special numbers.     */
  /*                                                                       */
#ifndef FT_IMAGE_TAG
#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  \
          value = ( ( (unsigned long)_x1 << 24 ) | \
                    ( (unsigned long)_x2 << 16 ) | \
                    ( (unsigned long)_x3 << 8  ) | \
                      (unsigned long)_x4         )
#endif /* FT_IMAGE_TAG */


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Glyph_Format                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type used to describe the format of a given glyph   */
  /*    image.  Note that this version of FreeType only supports two image */
  /*    formats, even though future font drivers will be able to register  */
  /*    their own format.                                                  */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_GLYPH_FORMAT_NONE ::                                            */
  /*      The value~0 is reserved.                                         */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_COMPOSITE ::                                       */
  /*      The glyph image is a composite of several other images.  This    */
  /*      format is _only_ used with @FT_LOAD_NO_RECURSE, and is used to   */
  /*      report compound glyphs (like accented characters).               */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_BITMAP ::                                          */
  /*      The glyph image is a bitmap, and can be described as an          */
  /*      @FT_Bitmap.  You generally need to access the `bitmap' field of  */
  /*      the @FT_GlyphSlotRec structure to read it.                       */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_OUTLINE ::                                         */
  /*      The glyph image is a vectorial outline made of line segments     */
  /*      and Bzier arcs; it can be described as an @FT_Outline; you      */
  /*      generally want to access the `outline' field of the              */
  /*      @FT_GlyphSlotRec structure to read it.                           */
  /*                                                                       */
  /*    FT_GLYPH_FORMAT_PLOTTER ::                                         */
  /*      The glyph image is a vectorial path with no inside and outside   */
  /*      contours.  Some Type~1 fonts, like those in the Hershey family,  */
  /*      contain glyphs in this format.  These are described as           */
  /*      @FT_Outline, but FreeType isn't currently capable of rendering   */
  /*      them correctly.                                                  */
  /*                                                                       */
  typedef enum  FT_Glyph_Format_
  {
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_NONE, 0, 0, 0, 0 ),

    FT_IMAGE_TAG( FT_GLYPH_FORMAT_COMPOSITE, 'c', 'o', 'm', 'p' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_BITMAP,    'b', 'i', 't', 's' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_OUTLINE,   'o', 'u', 't', 'l' ),
    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' )

  } FT_Glyph_Format;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    ft_glyph_format_xxx                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of deprecated constants.  Use the corresponding             */
  /*    @FT_Glyph_Format values instead.                                   */
  /*                                                                       */
  /* <Values>                                                              */
  /*    ft_glyph_format_none      :: See @FT_GLYPH_FORMAT_NONE.            */
  /*    ft_glyph_format_composite :: See @FT_GLYPH_FORMAT_COMPOSITE.       */
  /*    ft_glyph_format_bitmap    :: See @FT_GLYPH_FORMAT_BITMAP.          */
  /*    ft_glyph_format_outline   :: See @FT_GLYPH_FORMAT_OUTLINE.         */
  /*    ft_glyph_format_plotter   :: See @FT_GLYPH_FORMAT_PLOTTER.         */
  /*                                                                       */
#define ft_glyph_format_none       FT_GLYPH_FORMAT_NONE
#define ft_glyph_format_composite  FT_GLYPH_FORMAT_COMPOSITE
#define ft_glyph_format_bitmap     FT_GLYPH_FORMAT_BITMAP
#define ft_glyph_format_outline    FT_GLYPH_FORMAT_OUTLINE
#define ft_glyph_format_plotter    FT_GLYPH_FORMAT_PLOTTER


  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****            R A S T E R   D E F I N I T I O N S                *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* A raster is a scan converter, in charge of rendering an outline into  */
  /* a a bitmap.  This section contains the public API for rasters.        */
  /*                                                                       */
  /* Note that in FreeType 2, all rasters are now encapsulated within      */
  /* specific modules called `renderers'.  See `freetype/ftrender.h' for   */
  /* more details on renderers.                                            */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    raster                                                             */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Scanline Converter                                                 */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    How vectorial outlines are converted into bitmaps and pixmaps.     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains technical definitions.                       */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Raster                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle (pointer) to a raster object.  Each object can be used    */
  /*    independently to convert an outline into a bitmap or pixmap.       */
  /*                                                                       */
  typedef struct FT_RasterRec_*  FT_Raster;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Span                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to model a single span of gray (or black) pixels  */
  /*    when rendering a monochrome or anti-aliased bitmap.                */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x        :: The span's horizontal start position.                  */
  /*                                                                       */
  /*    len      :: The span's length in pixels.                           */
  /*                                                                       */
  /*    coverage :: The span color/coverage, ranging from 0 (background)   */
  /*                to 255 (foreground).  Only used for anti-aliased       */
  /*                rendering.                                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This structure is used by the span drawing callback type named     */
  /*    @FT_SpanFunc which takes the y~coordinate of the span as a         */
  /*    a parameter.                                                       */
  /*                                                                       */
  /*    The coverage value is always between 0 and 255.  If you want less  */
  /*    gray values, the callback function has to reduce them.             */
  /*                                                                       */
  typedef struct  FT_Span_
  {
    short           x;
    unsigned short  len;
    unsigned char   coverage;

  } FT_Span;


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_SpanFunc                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used as a call-back by the anti-aliased renderer in     */
  /*    order to let client applications draw themselves the gray pixel    */
  /*    spans on each scan line.                                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    y     :: The scanline's y~coordinate.                              */
  /*                                                                       */
  /*    count :: The number of spans to draw on this scanline.             */
  /*                                                                       */
  /*    spans :: A table of `count' spans to draw on the scanline.         */
  /*                                                                       */
  /*    user  :: User-supplied data that is passed to the callback.        */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This callback allows client applications to directly render the    */
  /*    gray spans of the anti-aliased bitmap to any kind of surfaces.     */
  /*                                                                       */
  /*    This can be used to write anti-aliased outlines directly to a      */
  /*    given background bitmap, and even perform translucency.            */
  /*                                                                       */
  /*    Note that the `count' field cannot be greater than a fixed value   */
  /*    defined by the `FT_MAX_GRAY_SPANS' configuration macro in          */
  /*    `ftoption.h'.  By default, this value is set to~32, which means    */
  /*    that if there are more than 32~spans on a given scanline, the      */
  /*    callback is called several times with the same `y' parameter in    */
  /*    order to draw all callbacks.                                       */
  /*                                                                       */
  /*    Otherwise, the callback is only called once per scan-line, and     */
  /*    only for those scanlines that do have `gray' pixels on them.       */
  /*                                                                       */
  typedef void
  (*FT_SpanFunc)( int             y,
                  int             count,
                  const FT_Span*  spans,
                  void*           user );

#define FT_Raster_Span_Func  FT_SpanFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_BitTest_Func                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT.                           */
  /*                                                                       */
  /*    A function used as a call-back by the monochrome scan-converter    */
  /*    to test whether a given target pixel is already set to the drawing */
  /*    `color'.  These tests are crucial to implement drop-out control    */
  /*    per-se the TrueType spec.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    y     :: The pixel's y~coordinate.                                 */
  /*                                                                       */
  /*    x     :: The pixel's x~coordinate.                                 */
  /*                                                                       */
  /*    user  :: User-supplied data that is passed to the callback.        */
  /*                                                                       */
  /* <Return>                                                              */
  /*   1~if the pixel is `set', 0~otherwise.                               */
  /*                                                                       */
  typedef int
  (*FT_Raster_BitTest_Func)( int    y,
                             int    x,
                             void*  user );


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_BitSet_Func                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT.                           */
  /*                                                                       */
  /*    A function used as a call-back by the monochrome scan-converter    */
  /*    to set an individual target pixel.  This is crucial to implement   */
  /*    drop-out control according to the TrueType specification.          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    y     :: The pixel's y~coordinate.                                 */
  /*                                                                       */
  /*    x     :: The pixel's x~coordinate.                                 */
  /*                                                                       */
  /*    user  :: User-supplied data that is passed to the callback.        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    1~if the pixel is `set', 0~otherwise.                              */
  /*                                                                       */
  typedef void
  (*FT_Raster_BitSet_Func)( int    y,
                            int    x,
                            void*  user );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_RASTER_FLAG_XXX                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flag constants as used in the `flags' field of a     */
  /*    @FT_Raster_Params structure.                                       */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_RASTER_FLAG_DEFAULT :: This value is 0.                         */
  /*                                                                       */
  /*    FT_RASTER_FLAG_AA      :: This flag is set to indicate that an     */
  /*                              anti-aliased glyph image should be       */
  /*                              generated.  Otherwise, it will be        */
  /*                              monochrome (1-bit).                      */
  /*                                                                       */
  /*    FT_RASTER_FLAG_DIRECT  :: This flag is set to indicate direct      */
  /*                              rendering.  In this mode, client         */
  /*                              applications must provide their own span */
  /*                              callback.  This lets them directly       */
  /*                              draw or compose over an existing bitmap. */
  /*                              If this bit is not set, the target       */
  /*                              pixmap's buffer _must_ be zeroed before  */
  /*                              rendering.                               */
  /*                                                                       */
  /*                              Note that for now, direct rendering is   */
  /*                              only possible with anti-aliased glyphs.  */
  /*                                                                       */
  /*    FT_RASTER_FLAG_CLIP    :: This flag is only used in direct         */
  /*                              rendering mode.  If set, the output will */
  /*                              be clipped to a box specified in the     */
  /*                              `clip_box' field of the                  */
  /*                              @FT_Raster_Params structure.             */
  /*                                                                       */
  /*                              Note that by default, the glyph bitmap   */
  /*                              is clipped to the target pixmap, except  */
  /*                              in direct rendering mode where all spans */
  /*                              are generated if no clipping box is set. */
  /*                                                                       */
#define FT_RASTER_FLAG_DEFAULT  0x0
#define FT_RASTER_FLAG_AA       0x1
#define FT_RASTER_FLAG_DIRECT   0x2
#define FT_RASTER_FLAG_CLIP     0x4

  /* deprecated */
#define ft_raster_flag_default  FT_RASTER_FLAG_DEFAULT
#define ft_raster_flag_aa       FT_RASTER_FLAG_AA
#define ft_raster_flag_direct   FT_RASTER_FLAG_DIRECT
#define ft_raster_flag_clip     FT_RASTER_FLAG_CLIP


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Raster_Params                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure to hold the arguments used by a raster's render        */
  /*    function.                                                          */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    target      :: The target bitmap.                                  */
  /*                                                                       */
  /*    source      :: A pointer to the source glyph image (e.g., an       */
  /*                   @FT_Outline).                                       */
  /*                                                                       */
  /*    flags       :: The rendering flags.                                */
  /*                                                                       */
  /*    gray_spans  :: The gray span drawing callback.                     */
  /*                                                                       */
  /*    black_spans :: The black span drawing callback.  UNIMPLEMENTED!    */
  /*                                                                       */
  /*    bit_test    :: The bit test callback.  UNIMPLEMENTED!              */
  /*                                                                       */
  /*    bit_set     :: The bit set callback.  UNIMPLEMENTED!               */
  /*                                                                       */
  /*    user        :: User-supplied data that is passed to each drawing   */
  /*                   callback.                                           */
  /*                                                                       */
  /*    clip_box    :: An optional clipping box.  It is only used in       */
  /*                   direct rendering mode.  Note that coordinates here  */
  /*                   should be expressed in _integer_ pixels (and not in */
  /*                   26.6 fixed-point units).                            */
  /*                                                                       */
  /* <Note>                                                                */
  /*    An anti-aliased glyph bitmap is drawn if the @FT_RASTER_FLAG_AA    */
  /*    bit flag is set in the `flags' field, otherwise a monochrome       */
  /*    bitmap is generated.                                               */
  /*                                                                       */
  /*    If the @FT_RASTER_FLAG_DIRECT bit flag is set in `flags', the      */
  /*    raster will call the `gray_spans' callback to draw gray pixel      */
  /*    spans, in the case of an aa glyph bitmap, it will call             */
  /*    `black_spans', and `bit_test' and `bit_set' in the case of a       */
  /*    monochrome bitmap.  This allows direct composition over a          */
  /*    pre-existing bitmap through user-provided callbacks to perform the */
  /*    span drawing/composition.                                          */
  /*                                                                       */
  /*    Note that the `bit_test' and `bit_set' callbacks are required when */
  /*    rendering a monochrome bitmap, as they are crucial to implement    */
  /*    correct drop-out control as defined in the TrueType specification. */
  /*                                                                       */
  typedef struct  FT_Raster_Params_
  {
    const FT_Bitmap*        target;
    const void*             source;
    int                     flags;
    FT_SpanFunc             gray_spans;
    FT_SpanFunc             black_spans;  /* doesn't work! */
    FT_Raster_BitTest_Func  bit_test;     /* doesn't work! */
    FT_Raster_BitSet_Func   bit_set;      /* doesn't work! */
    void*                   user;
    FT_BBox                 clip_box;

  } FT_Raster_Params;


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_NewFunc                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to create a new raster object.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    memory :: A handle to the memory allocator.                        */
  /*                                                                       */
  /* <Output>                                                              */
  /*    raster :: A handle to the new raster object.                       */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The `memory' parameter is a typeless pointer in order to avoid     */
  /*    un-wanted dependencies on the rest of the FreeType code.  In       */
  /*    practice, it is an @FT_Memory object, i.e., a handle to the        */
  /*    standard FreeType memory allocator.  However, this field can be    */
  /*    completely ignored by a given raster implementation.               */
  /*                                                                       */
  typedef int
  (*FT_Raster_NewFunc)( void*       memory,
                        FT_Raster*  raster );

#define FT_Raster_New_Func  FT_Raster_NewFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_DoneFunc                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to destroy a given raster object.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the raster object.                           */
  /*                                                                       */
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster  raster );

#define FT_Raster_Done_Func  FT_Raster_DoneFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_ResetFunc                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType provides an area of memory called the `render pool',      */
  /*    available to all registered rasters.  This pool can be freely used */
  /*    during a given scan-conversion but is shared by all rasters.  Its  */
  /*    content is thus transient.                                         */
  /*                                                                       */
  /*    This function is called each time the render pool changes, or just */
  /*    after a new raster object is created.                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster    :: A handle to the new raster object.                    */
  /*                                                                       */
  /*    pool_base :: The address in memory of the render pool.             */
  /*                                                                       */
  /*    pool_size :: The size in bytes of the render pool.                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Rasters can ignore the render pool and rely on dynamic memory      */
  /*    allocation if they want to (a handle to the memory allocator is    */
  /*    passed to the raster constructor).  However, this is not           */
  /*    recommended for efficiency purposes.                               */
  /*                                                                       */
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster       raster,
                          unsigned char*  pool_base,
                          unsigned long   pool_size );

#define FT_Raster_Reset_Func  FT_Raster_ResetFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_SetModeFunc                                              */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function is a generic facility to change modes or attributes  */
  /*    in a given raster.  This can be used for debugging purposes, or    */
  /*    simply to allow implementation-specific `features' in a given      */
  /*    raster module.                                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the new raster object.                       */
  /*                                                                       */
  /*    mode   :: A 4-byte tag used to name the mode or property.          */
  /*                                                                       */
  /*    args   :: A pointer to the new mode/property to use.               */
  /*                                                                       */
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster      raster,
                            unsigned long  mode,
                            void*          args );

#define FT_Raster_Set_Mode_Func  FT_Raster_SetModeFunc


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Raster_RenderFunc                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Invoke a given raster to scan-convert a given glyph image into a   */
  /*    target bitmap.                                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    raster :: A handle to the raster object.                           */
  /*                                                                       */
  /*    params :: A pointer to an @FT_Raster_Params structure used to      */
  /*              store the rendering parameters.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Error code.  0~means success.                                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The exact format of the source image depends on the raster's glyph */
  /*    format defined in its @FT_Raster_Funcs structure.  It can be an    */
  /*    @FT_Outline or anything else in order to support a large array of  */
  /*    glyph formats.                                                     */
  /*                                                                       */
  /*    Note also that the render function can fail and return a           */
  /*    `FT_Err_Unimplemented_Feature' error code if the raster used does  */
  /*    not support direct composition.                                    */
  /*                                                                       */
  /*    XXX: For now, the standard raster doesn't support direct           */
  /*         composition but this should change for the final release (see */
  /*         the files `demos/src/ftgrays.c' and `demos/src/ftgrays2.c'    */
  /*         for examples of distinct implementations which support direct */
  /*         composition).                                                 */
  /*                                                                       */
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster                raster,
                           const FT_Raster_Params*  params );

#define FT_Raster_Render_Func  FT_Raster_RenderFunc


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Raster_Funcs                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*   A structure used to describe a given raster class to the library.   */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    glyph_format  :: The supported glyph format for this raster.       */
  /*                                                                       */
  /*    raster_new    :: The raster constructor.                           */
  /*                                                                       */
  /*    raster_reset  :: Used to reset the render pool within the raster.  */
  /*                                                                       */
  /*    raster_render :: A function to render a glyph into a given bitmap. */
  /*                                                                       */
  /*    raster_done   :: The raster destructor.                            */
  /*                                                                       */
  typedef struct  FT_Raster_Funcs_
  {
    FT_Glyph_Format        glyph_format;
    FT_Raster_NewFunc      raster_new;
    FT_Raster_ResetFunc    raster_reset;
    FT_Raster_SetModeFunc  raster_set_mode;
    FT_Raster_RenderFunc   raster_render;
    FT_Raster_DoneFunc     raster_done;

  } FT_Raster_Funcs;


  /* */


FT_END_HEADER

#endif /* __FTIMAGE_H__ */


/* END */


/* Local Variables: */
/* coding: utf-8    */
/* End:             */

#include <stddef.h>


FT_BEGIN_HEADER


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    basic_types                                                        */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Basic Data Types                                                   */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The basic data types defined by the library.                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains the basic data types defined by FreeType~2,  */
  /*    ranging from simple scalar types to bitmap descriptors.  More      */
  /*    font-specific structures are defined in a different section.       */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Byte                                                            */
  /*    FT_Bytes                                                           */
  /*    FT_Char                                                            */
  /*    FT_Int                                                             */
  /*    FT_UInt                                                            */
  /*    FT_Int16                                                           */
  /*    FT_UInt16                                                          */
  /*    FT_Int32                                                           */
  /*    FT_UInt32                                                          */
  /*    FT_Short                                                           */
  /*    FT_UShort                                                          */
  /*    FT_Long                                                            */
  /*    FT_ULong                                                           */
  /*    FT_Bool                                                            */
  /*    FT_Offset                                                          */
  /*    FT_PtrDist                                                         */
  /*    FT_String                                                          */
  /*    FT_Tag                                                             */
  /*    FT_Error                                                           */
  /*    FT_Fixed                                                           */
  /*    FT_Pointer                                                         */
  /*    FT_Pos                                                             */
  /*    FT_Vector                                                          */
  /*    FT_BBox                                                            */
  /*    FT_Matrix                                                          */
  /*    FT_FWord                                                           */
  /*    FT_UFWord                                                          */
  /*    FT_F2Dot14                                                         */
  /*    FT_UnitVector                                                      */
  /*    FT_F26Dot6                                                         */
  /*                                                                       */
  /*                                                                       */
  /*    FT_Generic                                                         */
  /*    FT_Generic_Finalizer                                               */
  /*                                                                       */
  /*    FT_Bitmap                                                          */
  /*    FT_Pixel_Mode                                                      */
  /*    FT_Palette_Mode                                                    */
  /*    FT_Glyph_Format                                                    */
  /*    FT_IMAGE_TAG                                                       */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Bool                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef of unsigned char, used for simple booleans.  As usual,   */
  /*    values 1 and~0 represent true and false, respectively.             */
  /*                                                                       */
  typedef unsigned char  FT_Bool;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_FWord                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 16-bit integer used to store a distance in original font  */
  /*    units.                                                             */
  /*                                                                       */
  typedef signed short  FT_FWord;   /* distance in FUnits */


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UFWord                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An unsigned 16-bit integer used to store a distance in original    */
  /*    font units.                                                        */
  /*                                                                       */
  typedef unsigned short  FT_UFWord;  /* unsigned distance */


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Char                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the _signed_ char type.                       */
  /*                                                                       */
  typedef signed char  FT_Char;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Byte                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the _unsigned_ char type.                     */
  /*                                                                       */
  typedef unsigned char  FT_Byte;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Bytes                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for constant memory areas.                               */
  /*                                                                       */
  typedef const FT_Byte*  FT_Bytes;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Tag                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for 32-bit tags (as used in the SFNT format).            */
  /*                                                                       */
  typedef FT_UInt32  FT_Tag;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_String                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for the char type, usually used for strings.      */
  /*                                                                       */
  typedef char  FT_String;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Short                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for signed short.                                        */
  /*                                                                       */
  typedef signed short  FT_Short;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UShort                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for unsigned short.                                      */
  /*                                                                       */
  typedef unsigned short  FT_UShort;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Int                                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for the int type.                                        */
  /*                                                                       */
  typedef signed int  FT_Int;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_UInt                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for the unsigned int type.                               */
  /*                                                                       */
  typedef unsigned int  FT_UInt;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Long                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for signed long.                                         */
  /*                                                                       */
  typedef signed long  FT_Long;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_ULong                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A typedef for unsigned long.                                       */
  /*                                                                       */
  typedef unsigned long  FT_ULong;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_F2Dot14                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 2.14 fixed-point type used for unit vectors.              */
  /*                                                                       */
  typedef signed short  FT_F2Dot14;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_F26Dot6                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A signed 26.6 fixed-point type used for vectorial pixel            */
  /*    coordinates.                                                       */
  /*                                                                       */
  typedef signed long  FT_F26Dot6;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Fixed                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This type is used to store 16.16 fixed-point values, like scaling  */
  /*    values or matrix coefficients.                                     */
  /*                                                                       */
  typedef signed long  FT_Fixed;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Error                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The FreeType error code type.  A value of~0 is always interpreted  */
  /*    as a successful operation.                                         */
  /*                                                                       */
  typedef int  FT_Error;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Pointer                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple typedef for a typeless pointer.                           */
  /*                                                                       */
  typedef void*  FT_Pointer;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Offset                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is equivalent to the ANSI~C `size_t' type, i.e., the largest  */
  /*    _unsigned_ integer type used to express a file size or position,   */
  /*    or a memory block size.                                            */
  /*                                                                       */
  typedef size_t  FT_Offset;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_PtrDist                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This is equivalent to the ANSI~C `ptrdiff_t' type, i.e., the       */
  /*    largest _signed_ integer type used to express the distance         */
  /*    between two pointers.                                              */
  /*                                                                       */
  typedef ft_ptrdiff_t  FT_PtrDist;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_UnitVector                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2D vector unit vector.  Uses    */
  /*    FT_F2Dot14 types.                                                  */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x :: Horizontal coordinate.                                        */
  /*                                                                       */
  /*    y :: Vertical coordinate.                                          */
  /*                                                                       */
  typedef struct  FT_UnitVector_
  {
    FT_F2Dot14  x;
    FT_F2Dot14  y;

  } FT_UnitVector;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Matrix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to store a 2x2 matrix.  Coefficients are   */
  /*    in 16.16 fixed-point format.  The computation performed is:        */
  /*                                                                       */
  /*       {                                                               */
  /*          x' = x*xx + y*xy                                             */
  /*          y' = x*yx + y*yy                                             */
  /*       }                                                               */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    xx :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    xy :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    yx :: Matrix coefficient.                                          */
  /*                                                                       */
  /*    yy :: Matrix coefficient.                                          */
  /*                                                                       */
  typedef struct  FT_Matrix_
  {
    FT_Fixed  xx, xy;
    FT_Fixed  yx, yy;

  } FT_Matrix;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Data                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Read-only binary data represented as a pointer and a length.       */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    pointer :: The data.                                               */
  /*                                                                       */
  /*    length  :: The length of the data in bytes.                        */
  /*                                                                       */
  typedef struct  FT_Data_
  {
    const FT_Byte*  pointer;
    FT_Int          length;

  } FT_Data;


  /*************************************************************************/
  /*                                                                       */
  /* <FuncType>                                                            */
  /*    FT_Generic_Finalizer                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Describe a function used to destroy the `client' data of any       */
  /*    FreeType object.  See the description of the @FT_Generic type for  */
  /*    details of usage.                                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    The address of the FreeType object which is under finalization.    */
  /*    Its client data is accessed through its `generic' field.           */
  /*                                                                       */
  typedef void  (*FT_Generic_Finalizer)(void*  object);


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Generic                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Client applications often need to associate their own data to a    */
  /*    variety of FreeType core objects.  For example, a text layout API  */
  /*    might want to associate a glyph cache to a given size object.      */
  /*                                                                       */
  /*    Some FreeType object contains a `generic' field, of type           */
  /*    FT_Generic, which usage is left to client applications and font    */
  /*    servers.                                                           */
  /*                                                                       */
  /*    It can be used to store a pointer to client-specific data, as well */
  /*    as the address of a `finalizer' function, which will be called by  */
  /*    FreeType when the object is destroyed (for example, the previous   */
  /*    client example would put the address of the glyph cache destructor */
  /*    in the `finalizer' field).                                         */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    data      :: A typeless pointer to any client-specified data. This */
  /*                 field is completely ignored by the FreeType library.  */
  /*                                                                       */
  /*    finalizer :: A pointer to a `generic finalizer' function, which    */
  /*                 will be called when the object is destroyed.  If this */
  /*                 field is set to NULL, no code will be called.         */
  /*                                                                       */
  typedef struct  FT_Generic_
  {
    void*                 data;
    FT_Generic_Finalizer  finalizer;

  } FT_Generic;


  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_MAKE_TAG                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags which are used to label       */
  /*    TrueType tables into an unsigned long to be used within FreeType.  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The produced values *must* be 32-bit integers.  Don't redefine     */
  /*    this macro.                                                        */
  /*                                                                       */
#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \
          (FT_Tag)                        \
          ( ( (FT_ULong)_x1 << 24 ) |     \
            ( (FT_ULong)_x2 << 16 ) |     \
            ( (FT_ULong)_x3 <<  8 ) |     \
              (FT_ULong)_x4         )


  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                    L I S T   M A N A G E M E N T                      */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    list_processing                                                    */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_ListNode                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*     Many elements and objects in FreeType are listed through an       */
  /*     @FT_List record (see @FT_ListRec).  As its name suggests, an      */
  /*     FT_ListNode is a handle to a single list element.                 */
  /*                                                                       */
  typedef struct FT_ListNodeRec_*  FT_ListNode;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_List                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a list record (see @FT_ListRec).                       */
  /*                                                                       */
  typedef struct FT_ListRec_*  FT_List;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_ListNodeRec                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold a single list element.                    */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    prev :: The previous element in the list.  NULL if first.          */
  /*                                                                       */
  /*    next :: The next element in the list.  NULL if last.               */
  /*                                                                       */
  /*    data :: A typeless pointer to the listed object.                   */
  /*                                                                       */
  typedef struct  FT_ListNodeRec_
  {
    FT_ListNode  prev;
    FT_ListNode  next;
    void*        data;

  } FT_ListNodeRec;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_ListRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to hold a simple doubly-linked list.  These are   */
  /*    used in many parts of FreeType.                                    */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    head :: The head (first element) of doubly-linked list.            */
  /*                                                                       */
  /*    tail :: The tail (last element) of doubly-linked list.             */
  /*                                                                       */
  typedef struct  FT_ListRec_
  {
    FT_ListNode  head;
    FT_ListNode  tail;

  } FT_ListRec;


  /* */

#define FT_IS_EMPTY( list )  ( (list).head == 0 )
#define FT_BOOL( x )  ( (FT_Bool)( x ) )

  /* concatenate C tokens */
#define FT_ERR_XCAT( x, y )  x ## y
#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )

  /* see `ftmoderr.h' for descriptions of the following macros */

#define FT_ERR( e )  FT_ERR_CAT( FT_ERR_PREFIX, e )

#define FT_ERROR_BASE( x )    ( (x) & 0xFF )
#define FT_ERROR_MODULE( x )  ( (x) & 0xFF00U )

#define FT_ERR_EQ( x, e )                                        \
          ( FT_ERROR_BASE( x ) == FT_ERROR_BASE( FT_ERR( e ) ) )
#define FT_ERR_NEQ( x, e )                                       \
          ( FT_ERROR_BASE( x ) != FT_ERROR_BASE( FT_ERR( e ) ) )


FT_END_HEADER

#endif /* __FTTYPES_H__ */


/* END */
/***************************************************************************/
/*                                                                         */
/*  fterrors.h                                                             */
/*                                                                         */
/*    FreeType error code handling (specification).                        */
/*                                                                         */
/*  Copyright 1996-2002, 2004, 2007, 2013 by                               */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* This special header file is used to define the handling of FT2        */
  /* enumeration constants.  It can also be used to generate error message */
  /* strings with a small macro trick explained below.                     */
  /*                                                                       */
  /* I - Error Formats                                                     */
  /* -----------------                                                     */
  /*                                                                       */
  /*   The configuration macro FT_CONFIG_OPTION_USE_MODULE_ERRORS can be   */
  /*   defined in ftoption.h in order to make the higher byte indicate     */
  /*   the module where the error has happened (this is not compatible     */
  /*   with standard builds of FreeType 2).  See the file `ftmoderr.h' for */
  /*   more details.                                                       */
  /*                                                                       */
  /*                                                                       */
  /* II - Error Message strings                                            */
  /* --------------------------                                            */
  /*                                                                       */
  /*   The error definitions below are made through special macros that    */
  /*   allow client applications to build a table of error message strings */
  /*   if they need it.  The strings are not included in a normal build of */
  /*   FreeType 2 to save space (most client applications do not use       */
  /*   them).                                                              */
  /*                                                                       */
  /*   To do so, you have to define the following macros before including  */
  /*   this file:                                                          */
  /*                                                                       */
  /*   FT_ERROR_START_LIST ::                                              */
  /*     This macro is called before anything else to define the start of  */
  /*     the error list.  It is followed by several FT_ERROR_DEF calls     */
  /*     (see below).                                                      */
  /*                                                                       */
  /*   FT_ERROR_DEF( e, v, s ) ::                                          */
  /*     This macro is called to define one single error.                  */
  /*     `e' is the error code identifier (e.g. FT_Err_Invalid_Argument).  */
  /*     `v' is the error numerical value.                                 */
  /*     `s' is the corresponding error string.                            */
  /*                                                                       */
  /*   FT_ERROR_END_LIST ::                                                */
  /*     This macro ends the list.                                         */
  /*                                                                       */
  /*   Additionally, you have to undefine __FTERRORS_H__ before #including */
  /*   this file.                                                          */
  /*                                                                       */
  /*   Here is a simple example:                                           */
  /*                                                                       */
  /*     {                                                                 */
  /*       #undef __FTERRORS_H__                                           */
  /*       #define FT_ERRORDEF( e, v, s )  { e, s },                       */
  /*       #define FT_ERROR_START_LIST     {                               */
  /*       #define FT_ERROR_END_LIST       { 0, 0 } };                     */
  /*                                                                       */
  /*       const struct                                                    */
  /*       {                                                               */
  /*         int          err_code;                                        */
  /*         const char*  err_msg;                                         */
  /*       } ft_errors[] =                                                 */
  /*                                                                       */
  /*     }                                                                 */
  /*                                                                       */
  /*************************************************************************/


#ifndef __FTERRORS_H__
#define __FTERRORS_H__


  /* include module base error codes */


  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                       SETUP MACROS                      *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/


#undef  FT_NEED_EXTERN_C


  /* FT_ERR_PREFIX is used as a prefix for error identifiers. */
  /* By default, we use `FT_Err_'.                            */
  /*                                                          */
#ifndef FT_ERR_PREFIX
#define FT_ERR_PREFIX  FT_Err_
#endif


  /* FT_ERR_BASE is used as the base for module-specific errors. */
  /*                                                             */
#ifdef FT_CONFIG_OPTION_USE_MODULE_ERRORS

#ifndef FT_ERR_BASE
#undef FT_ERR_BASE
#define FT_ERR_BASE  FT_Mod_Err_Base
#endif

#else

#undef FT_ERR_BASE
#define FT_ERR_BASE  0

#endif /* FT_CONFIG_OPTION_USE_MODULE_ERRORS */


  /* If FT_ERRORDEF is not defined, we need to define a simple */
  /* enumeration type.                                         */
  /*                                                           */
#ifndef FT_ERRORDEF

#define FT_ERRORDEF( e, v, s )  e = v,
#define FT_ERROR_START_LIST     enum {
#define FT_ERROR_END_LIST       FT_ERR_CAT( FT_ERR_PREFIX, Max ) };

#ifdef __cplusplus
#define FT_NEED_EXTERN_C
  extern "C" {
#endif

#endif /* !FT_ERRORDEF */


  /* this macro is used to define an error */
#define FT_ERRORDEF_( e, v, s )                                             \
          FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v + FT_ERR_BASE, s )

  /* this is only used for <module>_Err_Ok, which must be 0! */
#define FT_NOERRORDEF_( e, v, s )                             \
          FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v, s )


#ifdef FT_ERROR_START_LIST
  FT_ERROR_START_LIST
#endif


  /* now include the error codes */
/***************************************************************************/
/*                                                                         */
/*  fterrdef.h                                                             */
/*                                                                         */
/*    FreeType error codes (specification).                                */
/*                                                                         */
/*  Copyright 2002, 2004, 2006, 2007, 2010-2013 by                         */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                LIST OF ERROR CODES/MESSAGES             *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/


  /* You need to define both FT_ERRORDEF_ and FT_NOERRORDEF_ before */
  /* including this file.                                           */


  /* generic errors */

  FT_NOERRORDEF_( Ok,                                        0x00, \
                  "no error" )

  FT_ERRORDEF_( Cannot_Open_Resource,                        0x01, \
                "cannot open resource" )
  FT_ERRORDEF_( Unknown_File_Format,                         0x02, \
                "unknown file format" )
  FT_ERRORDEF_( Invalid_File_Format,                         0x03, \
                "broken file" )
  FT_ERRORDEF_( Invalid_Version,                             0x04, \
                "invalid FreeType version" )
  FT_ERRORDEF_( Lower_Module_Version,                        0x05, \
                "module version is too low" )
  FT_ERRORDEF_( Invalid_Argument,                            0x06, \
                "invalid argument" )
  FT_ERRORDEF_( Unimplemented_Feature,                       0x07, \
                "unimplemented feature" )
  FT_ERRORDEF_( Invalid_Table,                               0x08, \
                "broken table" )
  FT_ERRORDEF_( Invalid_Offset,                              0x09, \
                "broken offset within table" )
  FT_ERRORDEF_( Array_Too_Large,                             0x0A, \
                "array allocation size too large" )
  FT_ERRORDEF_( Missing_Module,                              0x0B, \
                "missing module" )
  FT_ERRORDEF_( Missing_Property,                            0x0C, \
                "missing property" )

  /* glyph/character errors */

  FT_ERRORDEF_( Invalid_Glyph_Index,                         0x10, \
                "invalid glyph index" )
  FT_ERRORDEF_( Invalid_Character_Code,                      0x11, \
                "invalid character code" )
  FT_ERRORDEF_( Invalid_Glyph_Format,                        0x12, \
                "unsupported glyph image format" )
  FT_ERRORDEF_( Cannot_Render_Glyph,                         0x13, \
                "cannot render this glyph format" )
  FT_ERRORDEF_( Invalid_Outline,                             0x14, \
                "invalid outline" )
  FT_ERRORDEF_( Invalid_Composite,                           0x15, \
                "invalid composite glyph" )
  FT_ERRORDEF_( Too_Many_Hints,                              0x16, \
                "too many hints" )
  FT_ERRORDEF_( Invalid_Pixel_Size,                          0x17, \
                "invalid pixel size" )

  /* handle errors */

  FT_ERRORDEF_( Invalid_Handle,                              0x20, \
                "invalid object handle" )
  FT_ERRORDEF_( Invalid_Library_Handle,                      0x21, \
                "invalid library handle" )
  FT_ERRORDEF_( Invalid_Driver_Handle,                       0x22, \
                "invalid module handle" )
  FT_ERRORDEF_( Invalid_Face_Handle,                         0x23, \
                "invalid face handle" )
  FT_ERRORDEF_( Invalid_Size_Handle,                         0x24, \
                "invalid size handle" )
  FT_ERRORDEF_( Invalid_Slot_Handle,                         0x25, \
                "invalid glyph slot handle" )
  FT_ERRORDEF_( Invalid_CharMap_Handle,                      0x26, \
                "invalid charmap handle" )
  FT_ERRORDEF_( Invalid_Cache_Handle,                        0x27, \
                "invalid cache manager handle" )
  FT_ERRORDEF_( Invalid_Stream_Handle,                       0x28, \
                "invalid stream handle" )

  /* driver errors */

  FT_ERRORDEF_( Too_Many_Drivers,                            0x30, \
                "too many modules" )
  FT_ERRORDEF_( Too_Many_Extensions,                         0x31, \
                "too many extensions" )

  /* memory errors */

  FT_ERRORDEF_( Out_Of_Memory,                               0x40, \
                "out of memory" )
  FT_ERRORDEF_( Unlisted_Object,                             0x41, \
                "unlisted object" )

  /* stream errors */

  FT_ERRORDEF_( Cannot_Open_Stream,                          0x51, \
                "cannot open stream" )
  FT_ERRORDEF_( Invalid_Stream_Seek,                         0x52, \
                "invalid stream seek" )
  FT_ERRORDEF_( Invalid_Stream_Skip,                         0x53, \
                "invalid stream skip" )
  FT_ERRORDEF_( Invalid_Stream_Read,                         0x54, \
                "invalid stream read" )
  FT_ERRORDEF_( Invalid_Stream_Operation,                    0x55, \
                "invalid stream operation" )
  FT_ERRORDEF_( Invalid_Frame_Operation,                     0x56, \
                "invalid frame operation" )
  FT_ERRORDEF_( Nested_Frame_Access,                         0x57, \
                "nested frame access" )
  FT_ERRORDEF_( Invalid_Frame_Read,                          0x58, \
                "invalid frame read" )

  /* raster errors */

  FT_ERRORDEF_( Raster_Uninitialized,                        0x60, \
                "raster uninitialized" )
  FT_ERRORDEF_( Raster_Corrupted,                            0x61, \
                "raster corrupted" )
  FT_ERRORDEF_( Raster_Overflow,                             0x62, \
                "raster overflow" )
  FT_ERRORDEF_( Raster_Negative_Height,                      0x63, \
                "negative height while rastering" )

  /* cache errors */

  FT_ERRORDEF_( Too_Many_Caches,                             0x70, \
                "too many registered caches" )

  /* TrueType and SFNT errors */

  FT_ERRORDEF_( Invalid_Opcode,                              0x80, \
                "invalid opcode" )
  FT_ERRORDEF_( Too_Few_Arguments,                           0x81, \
                "too few arguments" )
  FT_ERRORDEF_( Stack_Overflow,                              0x82, \
                "stack overflow" )
  FT_ERRORDEF_( Code_Overflow,                               0x83, \
                "code overflow" )
  FT_ERRORDEF_( Bad_Argument,                                0x84, \
                "bad argument" )
  FT_ERRORDEF_( Divide_By_Zero,                              0x85, \
                "division by zero" )
  FT_ERRORDEF_( Invalid_Reference,                           0x86, \
                "invalid reference" )
  FT_ERRORDEF_( Debug_OpCode,                                0x87, \
                "found debug opcode" )
  FT_ERRORDEF_( ENDF_In_Exec_Stream,                         0x88, \
                "found ENDF opcode in execution stream" )
  FT_ERRORDEF_( Nested_DEFS,                                 0x89, \
                "nested DEFS" )
  FT_ERRORDEF_( Invalid_CodeRange,                           0x8A, \
                "invalid code range" )
  FT_ERRORDEF_( Execution_Too_Long,                          0x8B, \
                "execution context too long" )
  FT_ERRORDEF_( Too_Many_Function_Defs,                      0x8C, \
                "too many function definitions" )
  FT_ERRORDEF_( Too_Many_Instruction_Defs,                   0x8D, \
                "too many instruction definitions" )
  FT_ERRORDEF_( Table_Missing,                               0x8E, \
                "SFNT font table missing" )
  FT_ERRORDEF_( Horiz_Header_Missing,                        0x8F, \
                "horizontal header (hhea) table missing" )
  FT_ERRORDEF_( Locations_Missing,                           0x90, \
                "locations (loca) table missing" )
  FT_ERRORDEF_( Name_Table_Missing,                          0x91, \
                "name table missing" )
  FT_ERRORDEF_( CMap_Table_Missing,                          0x92, \
                "character map (cmap) table missing" )
  FT_ERRORDEF_( Hmtx_Table_Missing,                          0x93, \
                "horizontal metrics (hmtx) table missing" )
  FT_ERRORDEF_( Post_Table_Missing,                          0x94, \
                "PostScript (post) table missing" )
  FT_ERRORDEF_( Invalid_Horiz_Metrics,                       0x95, \
                "invalid horizontal metrics" )
  FT_ERRORDEF_( Invalid_CharMap_Format,                      0x96, \
                "invalid character map (cmap) format" )
  FT_ERRORDEF_( Invalid_PPem,                                0x97, \
                "invalid ppem value" )
  FT_ERRORDEF_( Invalid_Vert_Metrics,                        0x98, \
                "invalid vertical metrics" )
  FT_ERRORDEF_( Could_Not_Find_Context,                      0x99, \
                "could not find context" )
  FT_ERRORDEF_( Invalid_Post_Table_Format,                   0x9A, \
                "invalid PostScript (post) table format" )
  FT_ERRORDEF_( Invalid_Post_Table,                          0x9B, \
                "invalid PostScript (post) table" )

  /* CFF, CID, and Type 1 errors */

  FT_ERRORDEF_( Syntax_Error,                                0xA0, \
                "opcode syntax error" )
  FT_ERRORDEF_( Stack_Underflow,                             0xA1, \
                "argument stack underflow" )
  FT_ERRORDEF_( Ignore,                                      0xA2, \
                "ignore" )
  FT_ERRORDEF_( No_Unicode_Glyph_Name,                       0xA3, \
                "no Unicode glyph name found" )
  FT_ERRORDEF_( Glyph_Too_Big,                               0xA4, \
                "glyph to big for hinting" )

  /* BDF errors */

  FT_ERRORDEF_( Missing_Startfont_Field,                     0xB0, \
                "`STARTFONT' field missing" )
  FT_ERRORDEF_( Missing_Font_Field,                          0xB1, \
                "`FONT' field missing" )
  FT_ERRORDEF_( Missing_Size_Field,                          0xB2, \
                "`SIZE' field missing" )
  FT_ERRORDEF_( Missing_Fontboundingbox_Field,               0xB3, \
                "`FONTBOUNDINGBOX' field missing" )
  FT_ERRORDEF_( Missing_Chars_Field,                         0xB4, \
                "`CHARS' field missing" )
  FT_ERRORDEF_( Missing_Startchar_Field,                     0xB5, \
                "`STARTCHAR' field missing" )
  FT_ERRORDEF_( Missing_Encoding_Field,                      0xB6, \
                "`ENCODING' field missing" )
  FT_ERRORDEF_( Missing_Bbx_Field,                           0xB7, \
                "`BBX' field missing" )
  FT_ERRORDEF_( Bbx_Too_Big,                                 0xB8, \
                "`BBX' too big" )
  FT_ERRORDEF_( Corrupted_Font_Header,                       0xB9, \
                "Font header corrupted or missing fields" )
  FT_ERRORDEF_( Corrupted_Font_Glyphs,                       0xBA, \
                "Font glyphs corrupted or missing fields" )


/* END */


#ifdef FT_ERROR_END_LIST
  FT_ERROR_END_LIST
#endif


  /*******************************************************************/
  /*******************************************************************/
  /*****                                                         *****/
  /*****                      SIMPLE CLEANUP                     *****/
  /*****                                                         *****/
  /*******************************************************************/
  /*******************************************************************/

#ifdef FT_NEED_EXTERN_C
  }
#endif

#undef FT_ERROR_START_LIST
#undef FT_ERROR_END_LIST

#undef FT_ERRORDEF
#undef FT_ERRORDEF_
#undef FT_NOERRORDEF_

#undef FT_NEED_EXTERN_C
#undef FT_ERR_BASE

  /* FT_ERR_PREFIX is needed internally */
#ifndef FT2_BUILD_LIBRARY
#undef FT_ERR_PREFIX
#endif

#endif /* __FTERRORS_H__ */


/* END */


FT_BEGIN_HEADER



  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    user_allocation                                                    */
  /*                                                                       */
  /* <Title>                                                               */
  /*    User allocation                                                    */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    How client applications should allocate FreeType data structures.  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType assumes that structures allocated by the user and passed  */
  /*    as arguments are zeroed out except for the actual data.  In other  */
  /*    words, it is recommended to use `calloc' (or variants of it)       */
  /*    instead of `malloc' for allocation.                                */
  /*                                                                       */
  /*************************************************************************/



  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                        B A S I C   T Y P E S                          */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    base_interface                                                     */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Base Interface                                                     */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The FreeType~2 base font interface.                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section describes the public high-level API of FreeType~2.    */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_Library                                                         */
  /*    FT_Face                                                            */
  /*    FT_Size                                                            */
  /*    FT_GlyphSlot                                                       */
  /*    FT_CharMap                                                         */
  /*    FT_Encoding                                                        */
  /*                                                                       */
  /*    FT_FaceRec                                                         */
  /*                                                                       */
  /*    FT_FACE_FLAG_SCALABLE                                              */
  /*    FT_FACE_FLAG_FIXED_SIZES                                           */
  /*    FT_FACE_FLAG_FIXED_WIDTH                                           */
  /*    FT_FACE_FLAG_HORIZONTAL                                            */
  /*    FT_FACE_FLAG_VERTICAL                                              */
  /*    FT_FACE_FLAG_SFNT                                                  */
  /*    FT_FACE_FLAG_KERNING                                               */
  /*    FT_FACE_FLAG_MULTIPLE_MASTERS                                      */
  /*    FT_FACE_FLAG_GLYPH_NAMES                                           */
  /*    FT_FACE_FLAG_EXTERNAL_STREAM                                       */
  /*    FT_FACE_FLAG_FAST_GLYPHS                                           */
  /*    FT_FACE_FLAG_HINTER                                                */
  /*                                                                       */
  /*    FT_STYLE_FLAG_BOLD                                                 */
  /*    FT_STYLE_FLAG_ITALIC                                               */
  /*                                                                       */
  /*    FT_SizeRec                                                         */
  /*    FT_Size_Metrics                                                    */
  /*                                                                       */
  /*    FT_GlyphSlotRec                                                    */
  /*    FT_Glyph_Metrics                                                   */
  /*    FT_SubGlyph                                                        */
  /*                                                                       */
  /*    FT_Bitmap_Size                                                     */
  /*                                                                       */
  /*    FT_Init_FreeType                                                   */
  /*    FT_Done_FreeType                                                   */
  /*                                                                       */
  /*    FT_New_Face                                                        */
  /*    FT_Done_Face                                                       */
  /*    FT_New_Memory_Face                                                 */
  /*    FT_Open_Face                                                       */
  /*    FT_Open_Args                                                       */
  /*    FT_Parameter                                                       */
  /*    FT_Attach_File                                                     */
  /*    FT_Attach_Stream                                                   */
  /*                                                                       */
  /*    FT_Set_Char_Size                                                   */
  /*    FT_Set_Pixel_Sizes                                                 */
  /*    FT_Request_Size                                                    */
  /*    FT_Select_Size                                                     */
  /*    FT_Size_Request_Type                                               */
  /*    FT_Size_Request                                                    */
  /*    FT_Set_Transform                                                   */
  /*    FT_Load_Glyph                                                      */
  /*    FT_Get_Char_Index                                                  */
  /*    FT_Get_Name_Index                                                  */
  /*    FT_Load_Char                                                       */
  /*                                                                       */
  /*    FT_OPEN_MEMORY                                                     */
  /*    FT_OPEN_STREAM                                                     */
  /*    FT_OPEN_PATHNAME                                                   */
  /*    FT_OPEN_DRIVER                                                     */
  /*    FT_OPEN_PARAMS                                                     */
  /*                                                                       */
  /*    FT_LOAD_DEFAULT                                                    */
  /*    FT_LOAD_RENDER                                                     */
  /*    FT_LOAD_MONOCHROME                                                 */
  /*    FT_LOAD_LINEAR_DESIGN                                              */
  /*    FT_LOAD_NO_SCALE                                                   */
  /*    FT_LOAD_NO_HINTING                                                 */
  /*    FT_LOAD_NO_BITMAP                                                  */
  /*    FT_LOAD_CROP_BITMAP                                                */
  /*                                                                       */
  /*    FT_LOAD_VERTICAL_LAYOUT                                            */
  /*    FT_LOAD_IGNORE_TRANSFORM                                           */
  /*    FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH                                */
  /*    FT_LOAD_FORCE_AUTOHINT                                             */
  /*    FT_LOAD_NO_RECURSE                                                 */
  /*    FT_LOAD_PEDANTIC                                                   */
  /*                                                                       */
  /*    FT_LOAD_TARGET_NORMAL                                              */
  /*    FT_LOAD_TARGET_LIGHT                                               */
  /*    FT_LOAD_TARGET_MONO                                                */
  /*    FT_LOAD_TARGET_LCD                                                 */
  /*    FT_LOAD_TARGET_LCD_V                                               */
  /*                                                                       */
  /*    FT_Render_Glyph                                                    */
  /*    FT_Render_Mode                                                     */
  /*    FT_Get_Kerning                                                     */
  /*    FT_Kerning_Mode                                                    */
  /*    FT_Get_Track_Kerning                                               */
  /*    FT_Get_Glyph_Name                                                  */
  /*    FT_Get_Postscript_Name                                             */
  /*                                                                       */
  /*    FT_CharMapRec                                                      */
  /*    FT_Select_Charmap                                                  */
  /*    FT_Set_Charmap                                                     */
  /*    FT_Get_Charmap_Index                                               */
  /*                                                                       */
  /*    FT_FSTYPE_INSTALLABLE_EMBEDDING                                    */
  /*    FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING                             */
  /*    FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING                              */
  /*    FT_FSTYPE_EDITABLE_EMBEDDING                                       */
  /*    FT_FSTYPE_NO_SUBSETTING                                            */
  /*    FT_FSTYPE_BITMAP_EMBEDDING_ONLY                                    */
  /*                                                                       */
  /*    FT_Get_FSType_Flags                                                */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Glyph_Metrics                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to model the metrics of a single glyph.  The      */
  /*    values are expressed in 26.6 fractional pixel format; if the flag  */
  /*    @FT_LOAD_NO_SCALE has been used while loading the glyph, values    */
  /*    are expressed in font units instead.                               */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    width ::                                                           */
  /*      The glyph's width.                                               */
  /*                                                                       */
  /*    height ::                                                          */
  /*      The glyph's height.                                              */
  /*                                                                       */
  /*    horiBearingX ::                                                    */
  /*      Left side bearing for horizontal layout.                         */
  /*                                                                       */
  /*    horiBearingY ::                                                    */
  /*      Top side bearing for horizontal layout.                          */
  /*                                                                       */
  /*    horiAdvance ::                                                     */
  /*      Advance width for horizontal layout.                             */
  /*                                                                       */
  /*    vertBearingX ::                                                    */
  /*      Left side bearing for vertical layout.                           */
  /*                                                                       */
  /*    vertBearingY ::                                                    */
  /*      Top side bearing for vertical layout.  Larger positive values    */
  /*      mean further below the vertical glyph origin.                    */
  /*                                                                       */
  /*    vertAdvance ::                                                     */
  /*      Advance height for vertical layout.  Positive values mean the    */
  /*      glyph has a positive advance downward.                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If not disabled with @FT_LOAD_NO_HINTING, the values represent     */
  /*    dimensions of the hinted glyph (in case hinting is applicable).    */
  /*                                                                       */
  /*    Stroking a glyph with an outside border does not increase          */
  /*    `horiAdvance' or `vertAdvance'; you have to manually adjust these  */
  /*    values to account for the added width and height.                  */
  /*                                                                       */
  typedef struct  FT_Glyph_Metrics_
  {
    FT_Pos  width;
    FT_Pos  height;

    FT_Pos  horiBearingX;
    FT_Pos  horiBearingY;
    FT_Pos  horiAdvance;

    FT_Pos  vertBearingX;
    FT_Pos  vertBearingY;
    FT_Pos  vertAdvance;

  } FT_Glyph_Metrics;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Bitmap_Size                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This structure models the metrics of a bitmap strike (i.e., a set  */
  /*    of glyphs for a given point size and resolution) in a bitmap font. */
  /*    It is used for the `available_sizes' field of @FT_Face.            */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    height :: The vertical distance, in pixels, between two            */
  /*              consecutive baselines.  It is always positive.           */
  /*                                                                       */
  /*    width  :: The average width, in pixels, of all glyphs in the       */
  /*              strike.                                                  */
  /*                                                                       */
  /*    size   :: The nominal size of the strike in 26.6 fractional        */
  /*              points.  This field is not very useful.                  */
  /*                                                                       */
  /*    x_ppem :: The horizontal ppem (nominal width) in 26.6 fractional   */
  /*              pixels.                                                  */
  /*                                                                       */
  /*    y_ppem :: The vertical ppem (nominal height) in 26.6 fractional    */
  /*              pixels.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Windows FNT:                                                       */
  /*      The nominal size given in a FNT font is not reliable.  Thus when */
  /*      the driver finds it incorrect, it sets `size' to some calculated */
  /*      values and sets `x_ppem' and `y_ppem' to the pixel width and     */
  /*      height given in the font, respectively.                          */
  /*                                                                       */
  /*    TrueType embedded bitmaps:                                         */
  /*      `size', `width', and `height' values are not contained in the    */
  /*      bitmap strike itself.  They are computed from the global font    */
  /*      parameters.                                                      */
  /*                                                                       */
  typedef struct  FT_Bitmap_Size_
  {
    FT_Short  height;
    FT_Short  width;

    FT_Pos    size;

    FT_Pos    x_ppem;
    FT_Pos    y_ppem;

  } FT_Bitmap_Size;


  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                     O B J E C T   C L A S S E S                       */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/

  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Library                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a FreeType library instance.  Each `library' is        */
  /*    completely independent from the others; it is the `root' of a set  */
  /*    of objects like fonts, faces, sizes, etc.                          */
  /*                                                                       */
  /*    It also embeds a memory manager (see @FT_Memory), as well as a     */
  /*    scan-line converter object (see @FT_Raster).                       */
  /*                                                                       */
  /*    In multi-threaded applications, make sure that the same FT_Library */
  /*    object or any of its children doesn't get accessed in parallel.    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Library objects are normally created by @FT_Init_FreeType, and     */
  /*    destroyed with @FT_Done_FreeType.  If you need reference-counting  */
  /*    (cf. @FT_Reference_Library), use @FT_New_Library and               */
  /*    @FT_Done_Library.                                                  */
  /*                                                                       */
  typedef struct FT_LibraryRec_  *FT_Library;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Module                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType module object.  Each module can be a  */
  /*    font driver, a renderer, or anything else that provides services   */
  /*    to the formers.                                                    */
  /*                                                                       */
  typedef struct FT_ModuleRec_*  FT_Module;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Driver                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType font driver object.  Each font driver */
  /*    is a special module capable of creating faces from font files.     */
  /*                                                                       */
  typedef struct FT_DriverRec_*  FT_Driver;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Renderer                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given FreeType renderer.  A renderer is a special    */
  /*    module in charge of converting a glyph image to a bitmap, when     */
  /*    necessary.  Each renderer supports a given glyph image format, and */
  /*    one or more target surface depths.                                 */
  /*                                                                       */
  typedef struct FT_RendererRec_*  FT_Renderer;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Face                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given typographic face object.  A face object models */
  /*    a given typeface, in a given style.                                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Each face object also owns a single @FT_GlyphSlot object, as well  */
  /*    as one or more @FT_Size objects.                                   */
  /*                                                                       */
  /*    Use @FT_New_Face or @FT_Open_Face to create a new face object from */
  /*    a given filepathname or a custom input stream.                     */
  /*                                                                       */
  /*    Use @FT_Done_Face to destroy it (along with its slot and sizes).   */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_FaceRec for the publicly accessible fields of a given face */
  /*    object.                                                            */
  /*                                                                       */
  typedef struct FT_FaceRec_*  FT_Face;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Size                                                            */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to an object used to model a face scaled to a given       */
  /*    character size.                                                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Each @FT_Face has an _active_ @FT_Size object that is used by      */
  /*    functions like @FT_Load_Glyph to determine the scaling             */
  /*    transformation which is used to load and hint glyphs and metrics.  */
  /*                                                                       */
  /*    You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes,                */
  /*    @FT_Request_Size or even @FT_Select_Size to change the content     */
  /*    (i.e., the scaling values) of the active @FT_Size.                 */
  /*                                                                       */
  /*    You can use @FT_New_Size to create additional size objects for a   */
  /*    given @FT_Face, but they won't be used by other functions until    */
  /*    you activate it through @FT_Activate_Size.  Only one size can be   */
  /*    activated at any given time per face.                              */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_SizeRec for the publicly accessible fields of a given size */
  /*    object.                                                            */
  /*                                                                       */
  typedef struct FT_SizeRec_*  FT_Size;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_GlyphSlot                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given `glyph slot'.  A slot is a container where it  */
  /*    is possible to load any of the glyphs contained in its parent      */
  /*    face.                                                              */
  /*                                                                       */
  /*    In other words, each time you call @FT_Load_Glyph or               */
  /*    @FT_Load_Char, the slot's content is erased by the new glyph data, */
  /*    i.e., the glyph's metrics, its image (bitmap or outline), and      */
  /*    other control information.                                         */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_GlyphSlotRec for the publicly accessible glyph fields.     */
  /*                                                                       */
  typedef struct FT_GlyphSlotRec_*  FT_GlyphSlot;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_CharMap                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a given character map.  A charmap is used to translate */
  /*    character codes in a given encoding into glyph indexes for its     */
  /*    parent's face.  Some font formats may provide several charmaps per */
  /*    font.                                                              */
  /*                                                                       */
  /*    Each face object owns zero or more charmaps, but only one of them  */
  /*    can be `active' and used by @FT_Get_Char_Index or @FT_Load_Char.   */
  /*                                                                       */
  /*    The list of available charmaps in a face is available through the  */
  /*    `face->num_charmaps' and `face->charmaps' fields of @FT_FaceRec.   */
  /*                                                                       */
  /*    The currently active charmap is available as `face->charmap'.      */
  /*    You should call @FT_Set_Charmap to change it.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    When a new face is created (either through @FT_New_Face or         */
  /*    @FT_Open_Face), the library looks for a Unicode charmap within     */
  /*    the list and automatically activates it.                           */
  /*                                                                       */
  /* <Also>                                                                */
  /*    See @FT_CharMapRec for the publicly accessible fields of a given   */
  /*    character map.                                                     */
  /*                                                                       */
  typedef struct FT_CharMapRec_*  FT_CharMap;


  /*************************************************************************/
  /*                                                                       */
  /* <Macro>                                                               */
  /*    FT_ENC_TAG                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This macro converts four-letter tags into an unsigned long.  It is */
  /*    used to define `encoding' identifiers (see @FT_Encoding).          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
  /*    should redefine this macro in case of problems to something like   */
  /*    this:                                                              */
  /*                                                                       */
  /*    {                                                                  */
  /*      #define FT_ENC_TAG( value, a, b, c, d )  value                   */
  /*    }                                                                  */
  /*                                                                       */
  /*    to get a simple enumeration without assigning special numbers.     */
  /*                                                                       */

#ifndef FT_ENC_TAG
#define FT_ENC_TAG( value, a, b, c, d )         \
          value = ( ( (FT_UInt32)(a) << 24 ) |  \
                    ( (FT_UInt32)(b) << 16 ) |  \
                    ( (FT_UInt32)(c) <<  8 ) |  \
                      (FT_UInt32)(d)         )

#endif /* FT_ENC_TAG */


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Encoding                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration used to specify character sets supported by         */
  /*    charmaps.  Used in the @FT_Select_Charmap API function.            */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Despite the name, this enumeration lists specific character        */
  /*    repertories (i.e., charsets), and not text encoding methods (e.g., */
  /*    UTF-8, UTF-16, etc.).                                              */
  /*                                                                       */
  /*    Other encodings might be defined in the future.                    */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_ENCODING_NONE ::                                                */
  /*      The encoding value~0 is reserved.                                */
  /*                                                                       */
  /*    FT_ENCODING_UNICODE ::                                             */
  /*      Corresponds to the Unicode character set.  This value covers     */
  /*      all versions of the Unicode repertoire, including ASCII and      */
  /*      Latin-1.  Most fonts include a Unicode charmap, but not all      */
  /*      of them.                                                         */
  /*                                                                       */
  /*      For example, if you want to access Unicode value U+1F028 (and    */
  /*      the font contains it), use value 0x1F028 as the input value for  */
  /*      @FT_Get_Char_Index.                                              */
  /*                                                                       */
  /*    FT_ENCODING_MS_SYMBOL ::                                           */
  /*      Corresponds to the Microsoft Symbol encoding, used to encode     */
  /*      mathematical symbols in the 32..255 character code range.  For   */
  /*      more information, see `http://www.ceviz.net/symbol.htm'.         */
  /*                                                                       */
  /*    FT_ENCODING_SJIS ::                                                */
  /*      Corresponds to Japanese SJIS encoding.  More info at             */
  /*      at `http://langsupport.japanreference.com/encoding.shtml'.       */
  /*      See note on multi-byte encodings below.                          */
  /*                                                                       */
  /*    FT_ENCODING_GB2312 ::                                              */
  /*      Corresponds to an encoding system for Simplified Chinese as used */
  /*      used in mainland China.                                          */
  /*                                                                       */
  /*    FT_ENCODING_BIG5 ::                                                */
  /*      Corresponds to an encoding system for Traditional Chinese as     */
  /*      used in Taiwan and Hong Kong.                                    */
  /*                                                                       */
  /*    FT_ENCODING_WANSUNG ::                                             */
  /*      Corresponds to the Korean encoding system known as Wansung.      */
  /*      For more information see                                         */
  /*      `http://www.microsoft.com/typography/unicode/949.txt'.           */
  /*                                                                       */
  /*    FT_ENCODING_JOHAB ::                                               */
  /*      The Korean standard character set (KS~C 5601-1992), which        */
  /*      corresponds to MS Windows code page 1361.  This character set    */
  /*      includes all possible Hangeul character combinations.            */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_LATIN_1 ::                                       */
  /*      Corresponds to a Latin-1 encoding as defined in a Type~1         */
  /*      PostScript font.  It is limited to 256 character codes.          */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_STANDARD ::                                      */
  /*      Corresponds to the Adobe Standard encoding, as found in Type~1,  */
  /*      CFF, and OpenType/CFF fonts.  It is limited to 256 character     */
  /*      codes.                                                           */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_EXPERT ::                                        */
  /*      Corresponds to the Adobe Expert encoding, as found in Type~1,    */
  /*      CFF, and OpenType/CFF fonts.  It is limited to 256 character     */
  /*      codes.                                                           */
  /*                                                                       */
  /*    FT_ENCODING_ADOBE_CUSTOM ::                                        */
  /*      Corresponds to a custom encoding, as found in Type~1, CFF, and   */
  /*      OpenType/CFF fonts.  It is limited to 256 character codes.       */
  /*                                                                       */
  /*    FT_ENCODING_APPLE_ROMAN ::                                         */
  /*      Corresponds to the 8-bit Apple roman encoding.  Many TrueType    */
  /*      and OpenType fonts contain a charmap for this encoding, since    */
  /*      older versions of Mac OS are able to use it.                     */
  /*                                                                       */
  /*    FT_ENCODING_OLD_LATIN_2 ::                                         */
  /*      This value is deprecated and was never used nor reported by      */
  /*      FreeType.  Don't use or test for it.                             */
  /*                                                                       */
  /*    FT_ENCODING_MS_SJIS ::                                             */
  /*      Same as FT_ENCODING_SJIS.  Deprecated.                           */
  /*                                                                       */
  /*    FT_ENCODING_MS_GB2312 ::                                           */
  /*      Same as FT_ENCODING_GB2312.  Deprecated.                         */
  /*                                                                       */
  /*    FT_ENCODING_MS_BIG5 ::                                             */
  /*      Same as FT_ENCODING_BIG5.  Deprecated.                           */
  /*                                                                       */
  /*    FT_ENCODING_MS_WANSUNG ::                                          */
  /*      Same as FT_ENCODING_WANSUNG.  Deprecated.                        */
  /*                                                                       */
  /*    FT_ENCODING_MS_JOHAB ::                                            */
  /*      Same as FT_ENCODING_JOHAB.  Deprecated.                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    By default, FreeType automatically synthesizes a Unicode charmap   */
  /*    for PostScript fonts, using their glyph names dictionaries.        */
  /*    However, it also reports the encodings defined explicitly in the   */
  /*    font file, for the cases when they are needed, with the Adobe      */
  /*    values as well.                                                    */
  /*                                                                       */
  /*    FT_ENCODING_NONE is set by the BDF and PCF drivers if the charmap  */
  /*    is neither Unicode nor ISO-8859-1 (otherwise it is set to          */
  /*    FT_ENCODING_UNICODE).  Use @FT_Get_BDF_Charset_ID to find out      */
  /*    which encoding is really present.  If, for example, the            */
  /*    `cs_registry' field is `KOI8' and the `cs_encoding' field is `R',  */
  /*    the font is encoded in KOI8-R.                                     */
  /*                                                                       */
  /*    FT_ENCODING_NONE is always set (with a single exception) by the    */
  /*    winfonts driver.  Use @FT_Get_WinFNT_Header and examine the        */
  /*    `charset' field of the @FT_WinFNT_HeaderRec structure to find out  */
  /*    which encoding is really present.  For example,                    */
  /*    @FT_WinFNT_ID_CP1251 (204) means Windows code page 1251 (for       */
  /*    Russian).                                                          */
  /*                                                                       */
  /*    FT_ENCODING_NONE is set if `platform_id' is @TT_PLATFORM_MACINTOSH */
  /*    and `encoding_id' is not @TT_MAC_ID_ROMAN (otherwise it is set to  */
  /*    FT_ENCODING_APPLE_ROMAN).                                          */
  /*                                                                       */
  /*    If `platform_id' is @TT_PLATFORM_MACINTOSH, use the function       */
  /*    @FT_Get_CMap_Language_ID  to query the Mac language ID which may   */
  /*    be needed to be able to distinguish Apple encoding variants.  See  */
  /*                                                                       */
  /*      http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/README.TXT  */
  /*                                                                       */
  /*    to get an idea how to do that.  Basically, if the language ID      */
  /*    is~0, don't use it, otherwise subtract 1 from the language ID.     */
  /*    Then examine `encoding_id'.  If, for example, `encoding_id' is     */
  /*    @TT_MAC_ID_ROMAN and the language ID (minus~1) is                  */
  /*    `TT_MAC_LANGID_GREEK', it is the Greek encoding, not Roman.        */
  /*    @TT_MAC_ID_ARABIC with `TT_MAC_LANGID_FARSI' means the Farsi       */
  /*    variant the Arabic encoding.                                       */
  /*                                                                       */
  typedef enum  FT_Encoding_
  {
    FT_ENC_TAG( FT_ENCODING_NONE, 0, 0, 0, 0 ),

    FT_ENC_TAG( FT_ENCODING_MS_SYMBOL, 's', 'y', 'm', 'b' ),
    FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' ),

    FT_ENC_TAG( FT_ENCODING_SJIS,    's', 'j', 'i', 's' ),
    FT_ENC_TAG( FT_ENCODING_GB2312,  'g', 'b', ' ', ' ' ),
    FT_ENC_TAG( FT_ENCODING_BIG5,    'b', 'i', 'g', '5' ),
    FT_ENC_TAG( FT_ENCODING_WANSUNG, 'w', 'a', 'n', 's' ),
    FT_ENC_TAG( FT_ENCODING_JOHAB,   'j', 'o', 'h', 'a' ),

    /* for backwards compatibility */
    FT_ENCODING_MS_SJIS    = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312  = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5    = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB   = FT_ENCODING_JOHAB,

    FT_ENC_TAG( FT_ENCODING_ADOBE_STANDARD, 'A', 'D', 'O', 'B' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_EXPERT,   'A', 'D', 'B', 'E' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_CUSTOM,   'A', 'D', 'B', 'C' ),
    FT_ENC_TAG( FT_ENCODING_ADOBE_LATIN_1,  'l', 'a', 't', '1' ),

    FT_ENC_TAG( FT_ENCODING_OLD_LATIN_2, 'l', 'a', 't', '2' ),

    FT_ENC_TAG( FT_ENCODING_APPLE_ROMAN, 'a', 'r', 'm', 'n' )

  } FT_Encoding;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    ft_encoding_xxx                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    These constants are deprecated; use the corresponding @FT_Encoding */
  /*    values instead.                                                    */
  /*                                                                       */
#define ft_encoding_none            FT_ENCODING_NONE
#define ft_encoding_unicode         FT_ENCODING_UNICODE
#define ft_encoding_symbol          FT_ENCODING_MS_SYMBOL
#define ft_encoding_latin_1         FT_ENCODING_ADOBE_LATIN_1
#define ft_encoding_latin_2         FT_ENCODING_OLD_LATIN_2
#define ft_encoding_sjis            FT_ENCODING_SJIS
#define ft_encoding_gb2312          FT_ENCODING_GB2312
#define ft_encoding_big5            FT_ENCODING_BIG5
#define ft_encoding_wansung         FT_ENCODING_WANSUNG
#define ft_encoding_johab           FT_ENCODING_JOHAB

#define ft_encoding_adobe_standard  FT_ENCODING_ADOBE_STANDARD
#define ft_encoding_adobe_expert    FT_ENCODING_ADOBE_EXPERT
#define ft_encoding_adobe_custom    FT_ENCODING_ADOBE_CUSTOM
#define ft_encoding_apple_roman     FT_ENCODING_APPLE_ROMAN


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_CharMapRec                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The base charmap structure.                                        */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    face        :: A handle to the parent face object.                 */
  /*                                                                       */
  /*    encoding    :: An @FT_Encoding tag identifying the charmap.  Use   */
  /*                   this with @FT_Select_Charmap.                       */
  /*                                                                       */
  /*    platform_id :: An ID number describing the platform for the        */
  /*                   following encoding ID.  This comes directly from    */
  /*                   the TrueType specification and should be emulated   */
  /*                   for other formats.                                  */
  /*                                                                       */
  /*    encoding_id :: A platform specific encoding number.  This also     */
  /*                   comes from the TrueType specification and should be */
  /*                   emulated similarly.                                 */
  /*                                                                       */
  typedef struct  FT_CharMapRec_
  {
    FT_Face      face;
    FT_Encoding  encoding;
    FT_UShort    platform_id;
    FT_UShort    encoding_id;

  } FT_CharMapRec;


  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                 B A S E   O B J E C T   C L A S S E S                 */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Face_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Face_InternalRec' structure, used to    */
  /*    model private data of a given @FT_Face object.                     */
  /*                                                                       */
  /*    This structure might change between releases of FreeType~2 and is  */
  /*    not generally available to client applications.                    */
  /*                                                                       */
  typedef struct FT_Face_InternalRec_*  FT_Face_Internal;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_FaceRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root face class structure.  A face object models a        */
  /*    typeface in a font file.                                           */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    num_faces           :: The number of faces in the font file.  Some */
  /*                           font formats can have multiple faces in     */
  /*                           a font file.                                */
  /*                                                                       */
  /*    face_index          :: The index of the face in the font file.  It */
  /*                           is set to~0 if there is only one face in    */
  /*                           the font file.                              */
  /*                                                                       */
  /*    face_flags          :: A set of bit flags that give important      */
  /*                           information about the face; see             */
  /*                           @FT_FACE_FLAG_XXX for the details.          */
  /*                                                                       */
  /*    style_flags         :: A set of bit flags indicating the style of  */
  /*                           the face; see @FT_STYLE_FLAG_XXX for the    */
  /*                           details.                                    */
  /*                                                                       */
  /*    num_glyphs          :: The number of glyphs in the face.  If the   */
  /*                           face is scalable and has sbits (see         */
  /*                           `num_fixed_sizes'), it is set to the number */
  /*                           of outline glyphs.                          */
  /*                                                                       */
  /*                           For CID-keyed fonts, this value gives the   */
  /*                           highest CID used in the font.               */
  /*                                                                       */
  /*    family_name         :: The face's family name.  This is an ASCII   */
  /*                           string, usually in English, which describes */
  /*                           the typeface's family (like `Times New      */
  /*                           Roman', `Bodoni', `Garamond', etc).  This   */
  /*                           is a least common denominator used to list  */
  /*                           fonts.  Some formats (TrueType & OpenType)  */
  /*                           provide localized and Unicode versions of   */
  /*                           this string.  Applications should use the   */
  /*                           format specific interface to access them.   */
  /*                           Can be NULL (e.g., in fonts embedded in a   */
  /*                           PDF file).                                  */
  /*                                                                       */
  /*    style_name          :: The face's style name.  This is an ASCII    */
  /*                           string, usually in English, which describes */
  /*                           the typeface's style (like `Italic',        */
  /*                           `Bold', `Condensed', etc).  Not all font    */
  /*                           formats provide a style name, so this field */
  /*                           is optional, and can be set to NULL.  As    */
  /*                           for `family_name', some formats provide     */
  /*                           localized and Unicode versions of this      */
  /*                           string.  Applications should use the format */
  /*                           specific interface to access them.          */
  /*                                                                       */
  /*    num_fixed_sizes     :: The number of bitmap strikes in the face.   */
  /*                           Even if the face is scalable, there might   */
  /*                           still be bitmap strikes, which are called   */
  /*                           `sbits' in that case.                       */
  /*                                                                       */
  /*    available_sizes     :: An array of @FT_Bitmap_Size for all bitmap  */
  /*                           strikes in the face.  It is set to NULL if  */
  /*                           there is no bitmap strike.                  */
  /*                                                                       */
  /*    num_charmaps        :: The number of charmaps in the face.         */
  /*                                                                       */
  /*    charmaps            :: An array of the charmaps of the face.       */
  /*                                                                       */
  /*    generic             :: A field reserved for client uses.  See the  */
  /*                           @FT_Generic type description.               */
  /*                                                                       */
  /*    bbox                :: The font bounding box.  Coordinates are     */
  /*                           expressed in font units (see                */
  /*                           `units_per_EM').  The box is large enough   */
  /*                           to contain any glyph from the font.  Thus,  */
  /*                           `bbox.yMax' can be seen as the `maximum     */
  /*                           ascender', and `bbox.yMin' as the `minimum  */
  /*                           descender'.  Only relevant for scalable     */
  /*                           formats.                                    */
  /*                                                                       */
  /*                           Note that the bounding box might be off by  */
  /*                           (at least) one pixel for hinted fonts.  See */
  /*                           @FT_Size_Metrics for further discussion.    */
  /*                                                                       */
  /*    units_per_EM        :: The number of font units per EM square for  */
  /*                           this face.  This is typically 2048 for      */
  /*                           TrueType fonts, and 1000 for Type~1 fonts.  */
  /*                           Only relevant for scalable formats.         */
  /*                                                                       */
  /*    ascender            :: The typographic ascender of the face,       */
  /*                           expressed in font units.  For font formats  */
  /*                           not having this information, it is set to   */
  /*                           `bbox.yMax'.  Only relevant for scalable    */
  /*                           formats.                                    */
  /*                                                                       */
  /*    descender           :: The typographic descender of the face,      */
  /*                           expressed in font units.  For font formats  */
  /*                           not having this information, it is set to   */
  /*                           `bbox.yMin'.  Note that this field is       */
  /*                           usually negative.  Only relevant for        */
  /*                           scalable formats.                           */
  /*                                                                       */
  /*    height              :: This value is the vertical distance         */
  /*                           between two consecutive baselines,          */
  /*                           expressed in font units.  It is always      */
  /*                           positive.  Only relevant for scalable       */
  /*                           formats.                                    */
  /*                                                                       */
  /*                           If you want the global glyph height, use    */
  /*                           `ascender - descender'.                     */
  /*                                                                       */
  /*    max_advance_width   :: The maximum advance width, in font units,   */
  /*                           for all glyphs in this face.  This can be   */
  /*                           used to make word wrapping computations     */
  /*                           faster.  Only relevant for scalable         */
  /*                           formats.                                    */
  /*                                                                       */
  /*    max_advance_height  :: The maximum advance height, in font units,  */
  /*                           for all glyphs in this face.  This is only  */
  /*                           relevant for vertical layouts, and is set   */
  /*                           to `height' for fonts that do not provide   */
  /*                           vertical metrics.  Only relevant for        */
  /*                           scalable formats.                           */
  /*                                                                       */
  /*    underline_position  :: The position, in font units, of the         */
  /*                           underline line for this face.  It is the    */
  /*                           center of the underlining stem.  Only       */
  /*                           relevant for scalable formats.              */
  /*                                                                       */
  /*    underline_thickness :: The thickness, in font units, of the        */
  /*                           underline for this face.  Only relevant for */
  /*                           scalable formats.                           */
  /*                                                                       */
  /*    glyph               :: The face's associated glyph slot(s).        */
  /*                                                                       */
  /*    size                :: The current active size for this face.      */
  /*                                                                       */
  /*    charmap             :: The current active charmap for this face.   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Fields may be changed after a call to @FT_Attach_File or           */
  /*    @FT_Attach_Stream.                                                 */
  /*                                                                       */
  typedef struct  FT_FaceRec_
  {
    FT_Long           num_faces;
    FT_Long           face_index;

    FT_Long           face_flags;
    FT_Long           style_flags;

    FT_Long           num_glyphs;

    FT_String*        family_name;
    FT_String*        style_name;

    FT_Int            num_fixed_sizes;
    FT_Bitmap_Size*   available_sizes;

    FT_Int            num_charmaps;
    FT_CharMap*       charmaps;

    FT_Generic        generic;

    /*# The following member variables (down to `underline_thickness') */
    /*# are only relevant to scalable outlines; cf. @FT_Bitmap_Size    */
    /*# for bitmap fonts.                                              */
    FT_BBox           bbox;

    FT_UShort         units_per_EM;
    FT_Short          ascender;
    FT_Short          descender;
    FT_Short          height;

    FT_Short          max_advance_width;
    FT_Short          max_advance_height;

    FT_Short          underline_position;
    FT_Short          underline_thickness;

    FT_GlyphSlot      glyph;
    FT_Size           size;
    FT_CharMap        charmap;

    /*@private begin */

    FT_Driver         driver;
    FT_Memory         memory;
    FT_Stream         stream;

    FT_ListRec        sizes_list;

    FT_Generic        autohint;   /* face-specific auto-hinter data */
    void*             extensions; /* unused                         */

    FT_Face_Internal  internal;

    /*@private end */

  } FT_FaceRec;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_FACE_FLAG_XXX                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flags used in the `face_flags' field of the          */
  /*    @FT_FaceRec structure.  They inform client applications of         */
  /*    properties of the corresponding face.                              */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_FACE_FLAG_SCALABLE ::                                           */
  /*      Indicates that the face contains outline glyphs.  This doesn't   */
  /*      prevent bitmap strikes, i.e., a face can have both this and      */
  /*      and @FT_FACE_FLAG_FIXED_SIZES set.                               */
  /*                                                                       */
  /*    FT_FACE_FLAG_FIXED_SIZES ::                                        */
  /*      Indicates that the face contains bitmap strikes.  See also the   */
  /*      `num_fixed_sizes' and `available_sizes' fields of @FT_FaceRec.   */
  /*                                                                       */
  /*    FT_FACE_FLAG_FIXED_WIDTH ::                                        */
  /*      Indicates that the face contains fixed-width characters (like    */
  /*      Courier, Lucido, MonoType, etc.).                                */
  /*                                                                       */
  /*    FT_FACE_FLAG_SFNT ::                                               */
  /*      Indicates that the face uses the `sfnt' storage scheme.  For     */
  /*      now, this means TrueType and OpenType.                           */
  /*                                                                       */
  /*    FT_FACE_FLAG_HORIZONTAL ::                                         */
  /*      Indicates that the face contains horizontal glyph metrics.  This */
  /*      should be set for all common formats.                            */
  /*                                                                       */
  /*    FT_FACE_FLAG_VERTICAL ::                                           */
  /*      Indicates that the face contains vertical glyph metrics.  This   */
  /*      is only available in some formats, not all of them.              */
  /*                                                                       */
  /*    FT_FACE_FLAG_KERNING ::                                            */
  /*      Indicates that the face contains kerning information.  If set,   */
  /*      the kerning distance can be retrieved through the function       */
  /*      @FT_Get_Kerning.  Otherwise the function always return the       */
  /*      vector (0,0).  Note that FreeType doesn't handle kerning data    */
  /*      from the `GPOS' table (as present in some OpenType fonts).       */
  /*                                                                       */
  /*    FT_FACE_FLAG_FAST_GLYPHS ::                                        */
  /*      THIS FLAG IS DEPRECATED.  DO NOT USE OR TEST IT.                 */
  /*                                                                       */
  /*    FT_FACE_FLAG_MULTIPLE_MASTERS ::                                   */
  /*      Indicates that the font contains multiple masters and is capable */
  /*      of interpolating between them.  See the multiple-masters         */
  /*      specific API for details.                                        */
  /*                                                                       */
  /*    FT_FACE_FLAG_GLYPH_NAMES ::                                        */
  /*      Indicates that the font contains glyph names that can be         */
  /*      retrieved through @FT_Get_Glyph_Name.  Note that some TrueType   */
  /*      fonts contain broken glyph name tables.  Use the function        */
  /*      @FT_Has_PS_Glyph_Names when needed.                              */
  /*                                                                       */
  /*    FT_FACE_FLAG_EXTERNAL_STREAM ::                                    */
  /*      Used internally by FreeType to indicate that a face's stream was */
  /*      provided by the client application and should not be destroyed   */
  /*      when @FT_Done_Face is called.  Don't read or test this flag.     */
  /*                                                                       */
  /*    FT_FACE_FLAG_HINTER ::                                             */
  /*      Set if the font driver has a hinting machine of its own.  For    */
  /*      example, with TrueType fonts, it makes sense to use data from    */
  /*      the SFNT `gasp' table only if the native TrueType hinting engine */
  /*      (with the bytecode interpreter) is available and active.         */
  /*                                                                       */
  /*    FT_FACE_FLAG_CID_KEYED ::                                          */
  /*      Set if the font is CID-keyed.  In that case, the font is not     */
  /*      accessed by glyph indices but by CID values.  For subsetted      */
  /*      CID-keyed fonts this has the consequence that not all index      */
  /*      values are a valid argument to FT_Load_Glyph.  Only the CID      */
  /*      values for which corresponding glyphs in the subsetted font      */
  /*      exist make FT_Load_Glyph return successfully; in all other cases */
  /*      you get an `FT_Err_Invalid_Argument' error.                      */
  /*                                                                       */
  /*      Note that CID-keyed fonts which are in an SFNT wrapper don't     */
  /*      have this flag set since the glyphs are accessed in the normal   */
  /*      way (using contiguous indices); the `CID-ness' isn't visible to  */
  /*      the application.                                                 */
  /*                                                                       */
  /*    FT_FACE_FLAG_TRICKY ::                                             */
  /*      Set if the font is `tricky', this is, it always needs the        */
  /*      font format's native hinting engine to get a reasonable result.  */
  /*      A typical example is the Chinese font `mingli.ttf' which uses    */
  /*      TrueType bytecode instructions to move and scale all of its      */
  /*      subglyphs.                                                       */
  /*                                                                       */
  /*      It is not possible to autohint such fonts using                  */
  /*      @FT_LOAD_FORCE_AUTOHINT; it will also ignore                     */
  /*      @FT_LOAD_NO_HINTING.  You have to set both @FT_LOAD_NO_HINTING   */
  /*      and @FT_LOAD_NO_AUTOHINT to really disable hinting; however, you */
  /*      probably never want this except for demonstration purposes.      */
  /*                                                                       */
  /*      Currently, there are about a dozen TrueType fonts in the list of */
  /*      tricky fonts; they are hard-coded in file `ttobjs.c'.            */
  /*                                                                       */
#define FT_FACE_FLAG_SCALABLE          ( 1L <<  0 )
#define FT_FACE_FLAG_FIXED_SIZES       ( 1L <<  1 )
#define FT_FACE_FLAG_FIXED_WIDTH       ( 1L <<  2 )
#define FT_FACE_FLAG_SFNT              ( 1L <<  3 )
#define FT_FACE_FLAG_HORIZONTAL        ( 1L <<  4 )
#define FT_FACE_FLAG_VERTICAL          ( 1L <<  5 )
#define FT_FACE_FLAG_KERNING           ( 1L <<  6 )
#define FT_FACE_FLAG_FAST_GLYPHS       ( 1L <<  7 )
#define FT_FACE_FLAG_MULTIPLE_MASTERS  ( 1L <<  8 )
#define FT_FACE_FLAG_GLYPH_NAMES       ( 1L <<  9 )
#define FT_FACE_FLAG_EXTERNAL_STREAM   ( 1L << 10 )
#define FT_FACE_FLAG_HINTER            ( 1L << 11 )
#define FT_FACE_FLAG_CID_KEYED         ( 1L << 12 )
#define FT_FACE_FLAG_TRICKY            ( 1L << 13 )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_HORIZONTAL( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains
   *   horizontal metrics (this is true for all font formats though).
   *
   * @also:
   *   @FT_HAS_VERTICAL can be used to check for vertical metrics.
   *
   */
#define FT_HAS_HORIZONTAL( face ) \
          ( face->face_flags & FT_FACE_FLAG_HORIZONTAL )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_VERTICAL( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains real
   *   vertical metrics (and not only synthesized ones).
   *
   */
#define FT_HAS_VERTICAL( face ) \
          ( face->face_flags & FT_FACE_FLAG_VERTICAL )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_KERNING( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains kerning
   *   data that can be accessed with @FT_Get_Kerning.
   *
   */
#define FT_HAS_KERNING( face ) \
          ( face->face_flags & FT_FACE_FLAG_KERNING )


  /*************************************************************************
   *
   * @macro:
   *   FT_IS_SCALABLE( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a scalable
   *   font face (true for TrueType, Type~1, Type~42, CID, OpenType/CFF,
   *   and PFR font formats.
   *
   */
#define FT_IS_SCALABLE( face ) \
          ( face->face_flags & FT_FACE_FLAG_SCALABLE )


  /*************************************************************************
   *
   * @macro:
   *   FT_IS_SFNT( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a font
   *   whose format is based on the SFNT storage scheme.  This usually
   *   means: TrueType fonts, OpenType fonts, as well as SFNT-based embedded
   *   bitmap fonts.
   *
   *   If this macro is true, all functions defined in @FT_SFNT_NAMES_H and
   *   @FT_TRUETYPE_TABLES_H are available.
   *
   */
#define FT_IS_SFNT( face ) \
          ( face->face_flags & FT_FACE_FLAG_SFNT )


  /*************************************************************************
   *
   * @macro:
   *   FT_IS_FIXED_WIDTH( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a font face
   *   that contains fixed-width (or `monospace', `fixed-pitch', etc.)
   *   glyphs.
   *
   */
#define FT_IS_FIXED_WIDTH( face ) \
          ( face->face_flags & FT_FACE_FLAG_FIXED_WIDTH )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_FIXED_SIZES( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some
   *   embedded bitmaps.  See the `available_sizes' field of the
   *   @FT_FaceRec structure.
   *
   */
#define FT_HAS_FIXED_SIZES( face ) \
          ( face->face_flags & FT_FACE_FLAG_FIXED_SIZES )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_FAST_GLYPHS( face )
   *
   * @description:
   *   Deprecated.
   *
   */
#define FT_HAS_FAST_GLYPHS( face )  0


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_GLYPH_NAMES( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some glyph
   *   names that can be accessed through @FT_Get_Glyph_Name.
   *
   */
#define FT_HAS_GLYPH_NAMES( face ) \
          ( face->face_flags & FT_FACE_FLAG_GLYPH_NAMES )


  /*************************************************************************
   *
   * @macro:
   *   FT_HAS_MULTIPLE_MASTERS( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains some
   *   multiple masters.  The functions provided by @FT_MULTIPLE_MASTERS_H
   *   are then available to choose the exact design you want.
   *
   */
#define FT_HAS_MULTIPLE_MASTERS( face ) \
          ( face->face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS )


  /*************************************************************************
   *
   * @macro:
   *   FT_IS_CID_KEYED( face )
   *
   * @description:
   *   A macro that returns true whenever a face object contains a CID-keyed
   *   font.  See the discussion of @FT_FACE_FLAG_CID_KEYED for more
   *   details.
   *
   *   If this macro is true, all functions defined in @FT_CID_H are
   *   available.
   *
   */
#define FT_IS_CID_KEYED( face ) \
          ( face->face_flags & FT_FACE_FLAG_CID_KEYED )


  /*************************************************************************
   *
   * @macro:
   *   FT_IS_TRICKY( face )
   *
   * @description:
   *   A macro that returns true whenever a face represents a `tricky' font.
   *   See the discussion of @FT_FACE_FLAG_TRICKY for more details.
   *
   */
#define FT_IS_TRICKY( face ) \
          ( face->face_flags & FT_FACE_FLAG_TRICKY )


  /*************************************************************************/
  /*                                                                       */
  /* <Const>                                                               */
  /*    FT_STYLE_FLAG_XXX                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit-flags used to indicate the style of a given face.    */
  /*    These are used in the `style_flags' field of @FT_FaceRec.          */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_STYLE_FLAG_ITALIC ::                                            */
  /*      Indicates that a given face style is italic or oblique.          */
  /*                                                                       */
  /*    FT_STYLE_FLAG_BOLD ::                                              */
  /*      Indicates that a given face is bold.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The style information as provided by FreeType is very basic.  More */
  /*    details are beyond the scope and should be done on a higher level  */
  /*    (for example, by analyzing various fields of the `OS/2' table in   */
  /*    SFNT based fonts).                                                 */
  /*                                                                       */
#define FT_STYLE_FLAG_ITALIC  ( 1 << 0 )
#define FT_STYLE_FLAG_BOLD    ( 1 << 1 )


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Size_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Size_InternalRec' structure, used to    */
  /*    model private data of a given @FT_Size object.                     */
  /*                                                                       */
  typedef struct FT_Size_InternalRec_*  FT_Size_Internal;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_Metrics                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The size metrics structure gives the metrics of a size object.     */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    x_ppem       :: The width of the scaled EM square in pixels, hence */
  /*                    the term `ppem' (pixels per EM).  It is also       */
  /*                    referred to as `nominal width'.                    */
  /*                                                                       */
  /*    y_ppem       :: The height of the scaled EM square in pixels,      */
  /*                    hence the term `ppem' (pixels per EM).  It is also */
  /*                    referred to as `nominal height'.                   */
  /*                                                                       */
  /*    x_scale      :: A 16.16 fractional scaling value used to convert   */
  /*                    horizontal metrics from font units to 26.6         */
  /*                    fractional pixels.  Only relevant for scalable     */
  /*                    font formats.                                      */
  /*                                                                       */
  /*    y_scale      :: A 16.16 fractional scaling value used to convert   */
  /*                    vertical metrics from font units to 26.6           */
  /*                    fractional pixels.  Only relevant for scalable     */
  /*                    font formats.                                      */
  /*                                                                       */
  /*    ascender     :: The ascender in 26.6 fractional pixels.  See       */
  /*                    @FT_FaceRec for the details.                       */
  /*                                                                       */
  /*    descender    :: The descender in 26.6 fractional pixels.  See      */
  /*                    @FT_FaceRec for the details.                       */
  /*                                                                       */
  /*    height       :: The height in 26.6 fractional pixels.  See         */
  /*                    @FT_FaceRec for the details.                       */
  /*                                                                       */
  /*    max_advance  :: The maximum advance width in 26.6 fractional       */
  /*                    pixels.  See @FT_FaceRec for the details.          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The scaling values, if relevant, are determined first during a     */
  /*    size changing operation.  The remaining fields are then set by the */
  /*    driver.  For scalable formats, they are usually set to scaled      */
  /*    values of the corresponding fields in @FT_FaceRec.                 */
  /*                                                                       */
  /*    Note that due to glyph hinting, these values might not be exact    */
  /*    for certain fonts.  Thus they must be treated as unreliable        */
  /*    with an error margin of at least one pixel!                        */
  /*                                                                       */
  /*    Indeed, the only way to get the exact metrics is to render _all_   */
  /*    glyphs.  As this would be a definite performance hit, it is up to  */
  /*    client applications to perform such computations.                  */
  /*                                                                       */
  /*    The FT_Size_Metrics structure is valid for bitmap fonts also.      */
  /*                                                                       */
  typedef struct  FT_Size_Metrics_
  {
    FT_UShort  x_ppem;      /* horizontal pixels per EM               */
    FT_UShort  y_ppem;      /* vertical pixels per EM                 */

    FT_Fixed   x_scale;     /* scaling values used to convert font    */
    FT_Fixed   y_scale;     /* units to 26.6 fractional pixels        */

    FT_Pos     ascender;    /* ascender in 26.6 frac. pixels          */
    FT_Pos     descender;   /* descender in 26.6 frac. pixels         */
    FT_Pos     height;      /* text height in 26.6 frac. pixels       */
    FT_Pos     max_advance; /* max horizontal advance, in 26.6 pixels */

  } FT_Size_Metrics;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_SizeRec                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root size class structure.  A size object models a face   */
  /*    object at a given size.                                            */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    face    :: Handle to the parent face object.                       */
  /*                                                                       */
  /*    generic :: A typeless pointer, which is unused by the FreeType     */
  /*               library or any of its drivers.  It can be used by       */
  /*               client applications to link their own data to each size */
  /*               object.                                                 */
  /*                                                                       */
  /*    metrics :: Metrics for this size object.  This field is read-only. */
  /*                                                                       */
  typedef struct  FT_SizeRec_
  {
    FT_Face           face;      /* parent face object              */
    FT_Generic        generic;   /* generic pointer for client uses */
    FT_Size_Metrics   metrics;   /* size metrics                    */
    FT_Size_Internal  internal;

  } FT_SizeRec;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_SubGlyph                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    The subglyph structure is an internal object used to describe      */
  /*    subglyphs (for example, in the case of composites).                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The subglyph implementation is not part of the high-level API,     */
  /*    hence the forward structure declaration.                           */
  /*                                                                       */
  /*    You can however retrieve subglyph information with                 */
  /*    @FT_Get_SubGlyph_Info.                                             */
  /*                                                                       */
  typedef struct FT_SubGlyphRec_*  FT_SubGlyph;


  /*************************************************************************/
  /*                                                                       */
  /* <Type>                                                                */
  /*    FT_Slot_Internal                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An opaque handle to an `FT_Slot_InternalRec' structure, used to    */
  /*    model private data of a given @FT_GlyphSlot object.                */
  /*                                                                       */
  typedef struct FT_Slot_InternalRec_*  FT_Slot_Internal;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_GlyphSlotRec                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    FreeType root glyph slot class structure.  A glyph slot is a       */
  /*    container where individual glyphs can be loaded, be they in        */
  /*    outline or bitmap format.                                          */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    library           :: A handle to the FreeType library instance     */
  /*                         this slot belongs to.                         */
  /*                                                                       */
  /*    face              :: A handle to the parent face object.           */
  /*                                                                       */
  /*    next              :: In some cases (like some font tools), several */
  /*                         glyph slots per face object can be a good     */
  /*                         thing.  As this is rare, the glyph slots are  */
  /*                         listed through a direct, single-linked list   */
  /*                         using its `next' field.                       */
  /*                                                                       */
  /*    generic           :: A typeless pointer which is unused by the     */
  /*                         FreeType library or any of its drivers.  It   */
  /*                         can be used by client applications to link    */
  /*                         their own data to each glyph slot object.     */
  /*                                                                       */
  /*    metrics           :: The metrics of the last loaded glyph in the   */
  /*                         slot.  The returned values depend on the last */
  /*                         load flags (see the @FT_Load_Glyph API        */
  /*                         function) and can be expressed either in 26.6 */
  /*                         fractional pixels or font units.              */
  /*                                                                       */
  /*                         Note that even when the glyph image is        */
  /*                         transformed, the metrics are not.             */
  /*                                                                       */
  /*    linearHoriAdvance :: The advance width of the unhinted glyph.      */
  /*                         Its value is expressed in 16.16 fractional    */
  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
  /*                         when loading the glyph.  This field can be    */
  /*                         important to perform correct WYSIWYG layout.  */
  /*                         Only relevant for outline glyphs.             */
  /*                                                                       */
  /*    linearVertAdvance :: The advance height of the unhinted glyph.     */
  /*                         Its value is expressed in 16.16 fractional    */
  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
  /*                         when loading the glyph.  This field can be    */
  /*                         important to perform correct WYSIWYG layout.  */
  /*                         Only relevant for outline glyphs.             */
  /*                                                                       */
  /*    advance           :: This shorthand is, depending on               */
  /*                         @FT_LOAD_IGNORE_TRANSFORM, the transformed    */
  /*                         advance width for the glyph (in 26.6          */
  /*                         fractional pixel format).  As specified with  */
  /*                         @FT_LOAD_VERTICAL_LAYOUT, it uses either the  */
  /*                         `horiAdvance' or the `vertAdvance' value of   */
  /*                         `metrics' field.                              */
  /*                                                                       */
  /*    format            :: This field indicates the format of the image  */
  /*                         contained in the glyph slot.  Typically       */
  /*                         @FT_GLYPH_FORMAT_BITMAP,                      */
  /*                         @FT_GLYPH_FORMAT_OUTLINE, or                  */
  /*                         @FT_GLYPH_FORMAT_COMPOSITE, but others are    */
  /*                         possible.                                     */
  /*                                                                       */
  /*    bitmap            :: This field is used as a bitmap descriptor     */
  /*                         when the slot format is                       */
  /*                         @FT_GLYPH_FORMAT_BITMAP.  Note that the       */
  /*                         address and content of the bitmap buffer can  */
  /*                         change between calls of @FT_Load_Glyph and a  */
  /*                         few other functions.                          */
  /*                                                                       */
  /*    bitmap_left       :: This is the bitmap's left bearing expressed   */
  /*                         in integer pixels.  Of course, this is only   */
  /*                         valid if the format is                        */
  /*                         @FT_GLYPH_FORMAT_BITMAP.                      */
  /*                                                                       */
  /*    bitmap_top        :: This is the bitmap's top bearing expressed in */
  /*                         integer pixels.  Remember that this is the    */
  /*                         distance from the baseline to the top-most    */
  /*                         glyph scanline, upwards y~coordinates being   */
  /*                         *positive*.                                   */
  /*                                                                       */
  /*    outline           :: The outline descriptor for the current glyph  */
  /*                         image if its format is                        */
  /*                         @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is    */
  /*                         loaded, `outline' can be transformed,         */
  /*                         distorted, embolded, etc.  However, it must   */
  /*                         not be freed.                                 */
  /*                                                                       */
  /*    num_subglyphs     :: The number of subglyphs in a composite glyph. */
  /*                         This field is only valid for the composite    */
  /*                         glyph format that should normally only be     */
  /*                         loaded with the @FT_LOAD_NO_RECURSE flag.     */
  /*                         For now this is internal to FreeType.         */
  /*                                                                       */
  /*    subglyphs         :: An array of subglyph descriptors for          */
  /*                         composite glyphs.  There are `num_subglyphs'  */
  /*                         elements in there.  Currently internal to     */
  /*                         FreeType.                                     */
  /*                                                                       */
  /*    control_data      :: Certain font drivers can also return the      */
  /*                         control data for a given glyph image (e.g.    */
  /*                         TrueType bytecode, Type~1 charstrings, etc.). */
  /*                         This field is a pointer to such data.         */
  /*                                                                       */
  /*    control_len       :: This is the length in bytes of the control    */
  /*                         data.                                         */
  /*                                                                       */
  /*    other             :: Really wicked formats can use this pointer to */
  /*                         present their own glyph image to client       */
  /*                         applications.  Note that the application      */
  /*                         needs to know about the image format.         */
  /*                                                                       */
  /*    lsb_delta         :: The difference between hinted and unhinted    */
  /*                         left side bearing while autohinting is        */
  /*                         active.  Zero otherwise.                      */
  /*                                                                       */
  /*    rsb_delta         :: The difference between hinted and unhinted    */
  /*                         right side bearing while autohinting is       */
  /*                         active.  Zero otherwise.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If @FT_Load_Glyph is called with default flags (see                */
  /*    @FT_LOAD_DEFAULT) the glyph image is loaded in the glyph slot in   */
  /*    its native format (e.g., an outline glyph for TrueType and Type~1  */
  /*    formats).                                                          */
  /*                                                                       */
  /*    This image can later be converted into a bitmap by calling         */
  /*    @FT_Render_Glyph.  This function finds the current renderer for    */
  /*    the native image's format, then invokes it.                        */
  /*                                                                       */
  /*    The renderer is in charge of transforming the native image through */
  /*    the slot's face transformation fields, then converting it into a   */
  /*    bitmap that is returned in `slot->bitmap'.                         */
  /*                                                                       */
  /*    Note that `slot->bitmap_left' and `slot->bitmap_top' are also used */
  /*    to specify the position of the bitmap relative to the current pen  */
  /*    position (e.g., coordinates (0,0) on the baseline).  Of course,    */
  /*    `slot->format' is also changed to @FT_GLYPH_FORMAT_BITMAP.         */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Here a small pseudo code fragment which shows how to use           */
  /*    `lsb_delta' and `rsb_delta':                                       */
  /*                                                                       */
  /*    {                                                                  */
  /*      FT_Pos  origin_x       = 0;                                      */
  /*      FT_Pos  prev_rsb_delta = 0;                                      */
  /*                                                                       */
  /*                                                                       */
  /*      for all glyphs do                                                */
  /*        <compute kern between current and previous glyph and add it to */
  /*         `origin_x'>                                                   */
  /*                                                                       */
  /*        <load glyph with `FT_Load_Glyph'>                              */
  /*                                                                       */
  /*        if ( prev_rsb_delta - face->glyph->lsb_delta >= 32 )           */
  /*          origin_x -= 64;                                              */
  /*        else if ( prev_rsb_delta - face->glyph->lsb_delta < -32 )      */
  /*          origin_x += 64;                                              */
  /*                                                                       */
  /*        prev_rsb_delta = face->glyph->rsb_delta;                       */
  /*                                                                       */
  /*        <save glyph image, or render glyph, or ...>                    */
  /*                                                                       */
  /*        origin_x += face->glyph->advance.x;                            */
  /*      endfor                                                           */
  /*    }                                                                  */
  /*                                                                       */
  typedef struct  FT_GlyphSlotRec_
  {
    FT_Library        library;
    FT_Face           face;
    FT_GlyphSlot      next;
    FT_UInt           reserved;       /* retained for binary compatibility */
    FT_Generic        generic;

    FT_Glyph_Metrics  metrics;
    FT_Fixed          linearHoriAdvance;
    FT_Fixed          linearVertAdvance;
    FT_Vector         advance;

    FT_Glyph_Format   format;

    FT_Bitmap         bitmap;
    FT_Int            bitmap_left;
    FT_Int            bitmap_top;

    FT_Outline        outline;

    FT_UInt           num_subglyphs;
    FT_SubGlyph       subglyphs;

    void*             control_data;
    long              control_len;

    FT_Pos            lsb_delta;
    FT_Pos            rsb_delta;

    void*             other;

    FT_Slot_Internal  internal;

  } FT_GlyphSlotRec;


  /*************************************************************************/
  /*************************************************************************/
  /*                                                                       */
  /*                         F U N C T I O N S                             */
  /*                                                                       */
  /*************************************************************************/
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Init_FreeType                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initialize a new FreeType library object.  The set of modules      */
  /*    that are registered by this function is determined at build time.  */
  /*                                                                       */
  /* <Output>                                                              */
  /*    alibrary :: A handle to a new library object.                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    In case you want to provide your own memory allocating routines,   */
  /*    use @FT_New_Library instead, followed by a call to                 */
  /*    @FT_Add_Default_Modules (or a series of calls to @FT_Add_Module).  */
  /*                                                                       */
  /*    For multi-threading applications each thread should have its own   */
  /*    FT_Library object.                                                 */
  /*                                                                       */
  /*    If you need reference-counting (cf. @FT_Reference_Library), use    */
  /*    @FT_New_Library and @FT_Done_Library.                              */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Init_FreeType( FT_Library  *alibrary );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Done_FreeType                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Destroy a given FreeType library object and all of its children,   */
  /*    including resources, drivers, faces, sizes, etc.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    library :: A handle to the target library object.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Done_FreeType( FT_Library  library );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_OPEN_XXX                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit-field constants used within the `flags' field of the */
  /*    @FT_Open_Args structure.                                           */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_OPEN_MEMORY   :: This is a memory-based stream.                 */
  /*                                                                       */
  /*    FT_OPEN_STREAM   :: Copy the stream from the `stream' field.       */
  /*                                                                       */
  /*    FT_OPEN_PATHNAME :: Create a new input stream from a C~path        */
  /*                        name.                                          */
  /*                                                                       */
  /*    FT_OPEN_DRIVER   :: Use the `driver' field.                        */
  /*                                                                       */
  /*    FT_OPEN_PARAMS   :: Use the `num_params' and `params' fields.      */
  /*                                                                       */
  /*    ft_open_memory   :: Deprecated; use @FT_OPEN_MEMORY instead.       */
  /*                                                                       */
  /*    ft_open_stream   :: Deprecated; use @FT_OPEN_STREAM instead.       */
  /*                                                                       */
  /*    ft_open_pathname :: Deprecated; use @FT_OPEN_PATHNAME instead.     */
  /*                                                                       */
  /*    ft_open_driver   :: Deprecated; use @FT_OPEN_DRIVER instead.       */
  /*                                                                       */
  /*    ft_open_params   :: Deprecated; use @FT_OPEN_PARAMS instead.       */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The `FT_OPEN_MEMORY', `FT_OPEN_STREAM', and `FT_OPEN_PATHNAME'     */
  /*    flags are mutually exclusive.                                      */
  /*                                                                       */
#define FT_OPEN_MEMORY    0x1
#define FT_OPEN_STREAM    0x2
#define FT_OPEN_PATHNAME  0x4
#define FT_OPEN_DRIVER    0x8
#define FT_OPEN_PARAMS    0x10

#define ft_open_memory    FT_OPEN_MEMORY     /* deprecated */
#define ft_open_stream    FT_OPEN_STREAM     /* deprecated */
#define ft_open_pathname  FT_OPEN_PATHNAME   /* deprecated */
#define ft_open_driver    FT_OPEN_DRIVER     /* deprecated */
#define ft_open_params    FT_OPEN_PARAMS     /* deprecated */


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Parameter                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A simple structure used to pass more or less generic parameters to */
  /*    @FT_Open_Face.                                                     */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    tag  :: A four-byte identification tag.                            */
  /*                                                                       */
  /*    data :: A pointer to the parameter data.                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The ID and function of parameters are driver-specific.  See the    */
  /*    various FT_PARAM_TAG_XXX flags for more information.               */
  /*                                                                       */
  typedef struct  FT_Parameter_
  {
    FT_ULong    tag;
    FT_Pointer  data;

  } FT_Parameter;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Open_Args                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to indicate how to open a new font file or        */
  /*    stream.  A pointer to such a structure can be used as a parameter  */
  /*    for the functions @FT_Open_Face and @FT_Attach_Stream.             */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    flags       :: A set of bit flags indicating how to use the        */
  /*                   structure.                                          */
  /*                                                                       */
  /*    memory_base :: The first byte of the file in memory.               */
  /*                                                                       */
  /*    memory_size :: The size in bytes of the file in memory.            */
  /*                                                                       */
  /*    pathname    :: A pointer to an 8-bit file pathname.                */
  /*                                                                       */
  /*    stream      :: A handle to a source stream object.                 */
  /*                                                                       */
  /*    driver      :: This field is exclusively used by @FT_Open_Face;    */
  /*                   it simply specifies the font driver to use to open  */
  /*                   the face.  If set to~0, FreeType tries to load the  */
  /*                   face with each one of the drivers in its list.      */
  /*                                                                       */
  /*    num_params  :: The number of extra parameters.                     */
  /*                                                                       */
  /*    params      :: Extra parameters passed to the font driver when     */
  /*                   opening a new face.                                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The stream type is determined by the contents of `flags' which     */
  /*    are tested in the following order by @FT_Open_Face:                */
  /*                                                                       */
  /*    If the `FT_OPEN_MEMORY' bit is set, assume that this is a          */
  /*    memory file of `memory_size' bytes, located at `memory_address'.   */
  /*    The data are are not copied, and the client is responsible for     */
  /*    releasing and destroying them _after_ the corresponding call to    */
  /*    @FT_Done_Face.                                                     */
  /*                                                                       */
  /*    Otherwise, if the `FT_OPEN_STREAM' bit is set, assume that a       */
  /*    custom input stream `stream' is used.                              */
  /*                                                                       */
  /*    Otherwise, if the `FT_OPEN_PATHNAME' bit is set, assume that this  */
  /*    is a normal file and use `pathname' to open it.                    */
  /*                                                                       */
  /*    If the `FT_OPEN_DRIVER' bit is set, @FT_Open_Face only tries to    */
  /*    open the file with the driver whose handler is in `driver'.        */
  /*                                                                       */
  /*    If the `FT_OPEN_PARAMS' bit is set, the parameters given by        */
  /*    `num_params' and `params' is used.  They are ignored otherwise.    */
  /*                                                                       */
  /*    Ideally, both the `pathname' and `params' fields should be tagged  */
  /*    as `const'; this is missing for API backwards compatibility.  In   */
  /*    other words, applications should treat them as read-only.          */
  /*                                                                       */
  typedef struct  FT_Open_Args_
  {
    FT_UInt         flags;
    const FT_Byte*  memory_base;
    FT_Long         memory_size;
    FT_String*      pathname;
    FT_Stream       stream;
    FT_Module       driver;
    FT_Int          num_params;
    FT_Parameter*   params;

  } FT_Open_Args;


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Face                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function calls @FT_Open_Face to open a font by its pathname.  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    pathname   :: A path to the font file.                             */
  /*                                                                       */
  /*    face_index :: The index of the face within the font.  The first    */
  /*                  face has index~0.                                    */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                  See @FT_Open_Face for more details.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Use @FT_Done_Face to destroy the created @FT_Face object (along    */
  /*    with its slot and sizes).                                          */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_New_Face( FT_Library   library,
               const char*  filepathname,
               FT_Long      face_index,
               FT_Face     *aface );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_New_Memory_Face                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function calls @FT_Open_Face to open a font which has been    */
  /*    loaded into memory.                                                */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    file_base  :: A pointer to the beginning of the font data.         */
  /*                                                                       */
  /*    file_size  :: The size of the memory chunk used by the font data.  */
  /*                                                                       */
  /*    face_index :: The index of the face within the font.  The first    */
  /*                  face has index~0.                                    */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                  See @FT_Open_Face for more details.                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You must not deallocate the memory before calling @FT_Done_Face.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_New_Memory_Face( FT_Library      library,
                      const FT_Byte*  file_base,
                      FT_Long         file_size,
                      FT_Long         face_index,
                      FT_Face        *aface );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Open_Face                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Create a face object from a given resource described by            */
  /*    @FT_Open_Args.                                                     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    library    :: A handle to the library resource.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    args       :: A pointer to an `FT_Open_Args' structure which must  */
  /*                  be filled by the caller.                             */
  /*                                                                       */
  /*    face_index :: The index of the face within the font.  The first    */
  /*                  face has index~0.                                    */
  /*                                                                       */
  /* <Output>                                                              */
  /*    aface      :: A handle to a new face object.  If `face_index' is   */
  /*                  greater than or equal to zero, it must be non-NULL.  */
  /*                  See note below.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Unlike FreeType 1.x, this function automatically creates a glyph   */
  /*    slot for the face object which can be accessed directly through    */
  /*    `face->glyph'.                                                     */
  /*                                                                       */
  /*    FT_Open_Face can be used to quickly check whether the font         */
  /*    format of a given font resource is supported by FreeType.  If the  */
  /*    `face_index' field is negative, the function's return value is~0   */
  /*    if the font format is recognized, or non-zero otherwise;           */
  /*    the function returns a more or less empty face handle in `*aface'  */
  /*    (if `aface' isn't NULL).  The only useful field in this special    */
  /*    case is `face->num_faces' which gives the number of faces within   */
  /*    the font file.  After examination, the returned @FT_Face structure */
  /*    should be deallocated with a call to @FT_Done_Face.                */
  /*                                                                       */
  /*    Each new face object created with this function also owns a        */
  /*    default @FT_Size object, accessible as `face->size'.               */
  /*                                                                       */
  /*    One @FT_Library instance can have multiple face objects, this is,  */
  /*    @FT_Open_Face and its siblings can be called multiple times using  */
  /*    the same `library' argument.                                       */
  /*                                                                       */
  /*    See the discussion of reference counters in the description of     */
  /*    @FT_Reference_Face.                                                */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Open_Face( FT_Library           library,
                const FT_Open_Args*  args,
                FT_Long              face_index,
                FT_Face             *aface );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Attach_File                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function calls @FT_Attach_Stream to attach a file.            */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: The target face object.                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    filepathname :: The pathname.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Attach_File( FT_Face      face,
                  const char*  filepathname );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Attach_Stream                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    `Attach' data to a face object.  Normally, this is used to read    */
  /*    additional information for the face object.  For example, you can  */
  /*    attach an AFM file that comes with a Type~1 font to get the        */
  /*    kerning values and other metrics.                                  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face       :: The target face object.                              */
  /*                                                                       */
  /* <Input>                                                               */
  /*    parameters :: A pointer to @FT_Open_Args which must be filled by   */
  /*                  the caller.                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The meaning of the `attach' (i.e., what really happens when the    */
  /*    new file is read) is not fixed by FreeType itself.  It really      */
  /*    depends on the font format (and thus the font driver).             */
  /*                                                                       */
  /*    Client applications are expected to know what they are doing       */
  /*    when invoking this function.  Most drivers simply do not implement */
  /*    file attachments.                                                  */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Attach_Stream( FT_Face        face,
                    FT_Open_Args*  parameters );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Reference_Face                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A counter gets initialized to~1 at the time an @FT_Face structure  */
  /*    is created.  This function increments the counter.  @FT_Done_Face  */
  /*    then only destroys a face if the counter is~1, otherwise it simply */
  /*    decrements the counter.                                            */
  /*                                                                       */
  /*    This function helps in managing life-cycles of structures which    */
  /*    reference @FT_Face objects.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.4.2                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Reference_Face( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Done_Face                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Discard a given face object, as well as all of its child slots and */
  /*    sizes.                                                             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    See the discussion of reference counters in the description of     */
  /*    @FT_Reference_Face.                                                */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Done_Face( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Select_Size                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a bitmap strike.                                            */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: A handle to a target face object.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    strike_index :: The index of the bitmap strike in the              */
  /*                    `available_sizes' field of @FT_FaceRec structure.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Select_Size( FT_Face  face,
                  FT_Int   strike_index );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Size_Request_Type                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type that lists the supported size request types.   */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_SIZE_REQUEST_TYPE_NOMINAL ::                                    */
  /*      The nominal size.  The `units_per_EM' field of @FT_FaceRec is    */
  /*      used to determine both scaling values.                           */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_REAL_DIM ::                                   */
  /*      The real dimension.  The sum of the the `ascender' and (minus    */
  /*      of) the `descender' fields of @FT_FaceRec are used to determine  */
  /*      both scaling values.                                             */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_BBOX ::                                       */
  /*      The font bounding box.  The width and height of the `bbox' field */
  /*      of @FT_FaceRec are used to determine the horizontal and vertical */
  /*      scaling value, respectively.                                     */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_CELL ::                                       */
  /*      The `max_advance_width' field of @FT_FaceRec is used to          */
  /*      determine the horizontal scaling value; the vertical scaling     */
  /*      value is determined the same way as                              */
  /*      @FT_SIZE_REQUEST_TYPE_REAL_DIM does.  Finally, both scaling      */
  /*      values are set to the smaller one.  This type is useful if you   */
  /*      want to specify the font size for, say, a window of a given      */
  /*      dimension and 80x24 cells.                                       */
  /*                                                                       */
  /*    FT_SIZE_REQUEST_TYPE_SCALES ::                                     */
  /*      Specify the scaling values directly.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The above descriptions only apply to scalable formats.  For bitmap */
  /*    formats, the behaviour is up to the driver.                        */
  /*                                                                       */
  /*    See the note section of @FT_Size_Metrics if you wonder how size    */
  /*    requesting relates to scaling values.                              */
  /*                                                                       */
  typedef enum  FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_RequestRec                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A structure used to model a size request.                          */
  /*                                                                       */
  /* <Fields>                                                              */
  /*    type           :: See @FT_Size_Request_Type.                       */
  /*                                                                       */
  /*    width          :: The desired width.                               */
  /*                                                                       */
  /*    height         :: The desired height.                              */
  /*                                                                       */
  /*    horiResolution :: The horizontal resolution.  If set to zero,      */
  /*                      `width' is treated as a 26.6 fractional pixel    */
  /*                      value.                                           */
  /*                                                                       */
  /*    vertResolution :: The vertical resolution.  If set to zero,        */
  /*                      `height' is treated as a 26.6 fractional pixel   */
  /*                      value.                                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If `width' is zero, then the horizontal scaling value is set equal */
  /*    to the vertical scaling value, and vice versa.                     */
  /*                                                                       */
  typedef struct  FT_Size_RequestRec_
  {
    FT_Size_Request_Type  type;
    FT_Long               width;
    FT_Long               height;
    FT_UInt               horiResolution;
    FT_UInt               vertResolution;

  } FT_Size_RequestRec;


  /*************************************************************************/
  /*                                                                       */
  /* <Struct>                                                              */
  /*    FT_Size_Request                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A handle to a size request structure.                              */
  /*                                                                       */
  typedef struct FT_Size_RequestRec_  *FT_Size_Request;


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Request_Size                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Resize the scale of the active @FT_Size object in a face.          */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face :: A handle to a target face object.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    req  :: A pointer to a @FT_Size_RequestRec.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Although drivers may select the bitmap strike matching the         */
  /*    request, you should not rely on this if you intend to select a     */
  /*    particular bitmap strike.  Use @FT_Select_Size instead in that     */
  /*    case.                                                              */
  /*                                                                       */
  /*    The relation between the requested size and the resulting glyph    */
  /*    size is dependent entirely on how the size is defined in the       */
  /*    source face.  The font designer chooses the final size of each     */
  /*    glyph relative to this size.  For more information refer to        */
  /*    `http://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'      */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Request_Size( FT_Face          face,
                   FT_Size_Request  req );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Char_Size                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function calls @FT_Request_Size to request the nominal size   */
  /*    (in points).                                                       */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face            :: A handle to a target face object.               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    char_width      :: The nominal width, in 26.6 fractional points.   */
  /*                                                                       */
  /*    char_height     :: The nominal height, in 26.6 fractional points.  */
  /*                                                                       */
  /*    horz_resolution :: The horizontal resolution in dpi.               */
  /*                                                                       */
  /*    vert_resolution :: The vertical resolution in dpi.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If either the character width or height is zero, it is set equal   */
  /*    to the other value.                                                */
  /*                                                                       */
  /*    If either the horizontal or vertical resolution is zero, it is set */
  /*    equal to the other value.                                          */
  /*                                                                       */
  /*    A character width or height smaller than 1pt is set to 1pt; if     */
  /*    both resolution values are zero, they are set to 72dpi.            */
  /*                                                                       */
  /*    Don't use this function if you are using the FreeType cache API.   */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Char_Size( FT_Face     face,
                    FT_F26Dot6  char_width,
                    FT_F26Dot6  char_height,
                    FT_UInt     horz_resolution,
                    FT_UInt     vert_resolution );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Pixel_Sizes                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function calls @FT_Request_Size to request the nominal size   */
  /*    (in pixels).                                                       */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face         :: A handle to the target face object.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    pixel_width  :: The nominal width, in pixels.                      */
  /*                                                                       */
  /*    pixel_height :: The nominal height, in pixels.                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should not rely on the resulting glyphs matching, or being     */
  /*    constrained, to this pixel size.  Refer to @FT_Request_Size to     */
  /*    understand how requested sizes relate to actual sizes.             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Pixel_Sizes( FT_Face  face,
                      FT_UInt  pixel_width,
                      FT_UInt  pixel_height );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Load_Glyph                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to load a single glyph into the glyph slot of a    */
  /*    face object.                                                       */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face        :: A handle to the target face object where the glyph  */
  /*                   is loaded.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    glyph_index :: The index of the glyph in the font file.  For       */
  /*                   CID-keyed fonts (either in PS or in CFF format)     */
  /*                   this argument specifies the CID value.              */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   @FT_LOAD_XXX constants can be used to control the   */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The loaded glyph may be transformed.  See @FT_Set_Transform for    */
  /*    the details.                                                       */
  /*                                                                       */
  /*    For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument' is        */
  /*    returned for invalid CID values (this is, for CID values which     */
  /*    don't have a corresponding glyph in the font).  See the discussion */
  /*    of the @FT_FACE_FLAG_CID_KEYED flag for more details.              */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Load_Glyph( FT_Face   face,
                 FT_UInt   glyph_index,
                 FT_Int32  load_flags );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Load_Char                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to load a single glyph into the glyph slot of a    */
  /*    face object, according to its character code.                      */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face        :: A handle to a target face object where the glyph    */
  /*                   is loaded.                                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    char_code   :: The glyph's character code, according to the        */
  /*                   current charmap used in the face.                   */
  /*                                                                       */
  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
  /*                   @FT_LOAD_XXX constants can be used to control the   */
  /*                   glyph loading process (e.g., whether the outline    */
  /*                   should be scaled, whether to load bitmaps or not,   */
  /*                   whether to hint the outline, etc).                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.  */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Load_Char( FT_Face   face,
                FT_ULong  char_code,
                FT_Int32  load_flags );


  /*************************************************************************
   *
   * @enum:
   *   FT_LOAD_XXX
   *
   * @description:
   *   A list of bit-field constants used with @FT_Load_Glyph to indicate
   *   what kind of operations to perform during glyph loading.
   *
   * @values:
   *   FT_LOAD_DEFAULT ::
   *     Corresponding to~0, this value is used as the default glyph load
   *     operation.  In this case, the following happens:
   *
   *     1. FreeType looks for a bitmap for the glyph corresponding to the
   *        face's current size.  If one is found, the function returns.
   *        The bitmap data can be accessed from the glyph slot (see note
   *        below).
   *
   *     2. If no embedded bitmap is searched or found, FreeType looks for a
   *        scalable outline.  If one is found, it is loaded from the font
   *        file, scaled to device pixels, then `hinted' to the pixel grid
   *        in order to optimize it.  The outline data can be accessed from
   *        the glyph slot (see note below).
   *
   *     Note that by default, the glyph loader doesn't render outlines into
   *     bitmaps.  The following flags are used to modify this default
   *     behaviour to more specific and useful cases.
   *
   *   FT_LOAD_NO_SCALE ::
   *     Don't scale the loaded outline glyph but keep it in font units.
   *
   *     This flag implies @FT_LOAD_NO_HINTING and @FT_LOAD_NO_BITMAP, and
   *     unsets @FT_LOAD_RENDER.
   *
   *     If the font is `tricky' (see @FT_FACE_FLAG_TRICKY for more), using
   *     FT_LOAD_NO_SCALE usually yields meaningless outlines because the
   *     subglyphs must be scaled and positioned with hinting instructions.
   *     This can be solved by loading the font without FT_LOAD_NO_SCALE and
   *     setting the character size to `font->units_per_EM'.
   *
   *   FT_LOAD_NO_HINTING ::
   *     Disable hinting.  This generally generates `blurrier' bitmap glyphs
   *     when the glyph are rendered in any of the anti-aliased modes.  See
   *     also the note below.
   *
   *     This flag is implied by @FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_RENDER ::
   *     Call @FT_Render_Glyph after the glyph is loaded.  By default, the
   *     glyph is rendered in @FT_RENDER_MODE_NORMAL mode.  This can be
   *     overridden by @FT_LOAD_TARGET_XXX or @FT_LOAD_MONOCHROME.
   *
   *     This flag is unset by @FT_LOAD_NO_SCALE.
   *
   *   FT_LOAD_NO_BITMAP ::
   *     Ignore bitmap strikes when loading.  Bitmap-only fonts ignore this
   *     flag.
   *
   *     @FT_LOAD_NO_SCALE always sets this flag.
   *
   *   FT_LOAD_VERTICAL_LAYOUT ::
   *     Load the glyph for vertical text layout.  In particular, the
   *     `advance' value in the @FT_GlyphSlotRec structure is set to the
   *     `vertAdvance' value of the `metrics' field.
   *
   *     In case @FT_HAS_VERTICAL doesn't return true, you shouldn't use
   *     this flag currently.  Reason is that in this case vertical metrics
   *     get synthesized, and those values are not always consistent across
   *     various font formats.
   *
   *   FT_LOAD_FORCE_AUTOHINT ::
   *     Indicates that the auto-hinter is preferred over the font's native
   *     hinter.  See also the note below.
   *
   *   FT_LOAD_CROP_BITMAP ::
   *     Indicates that the font driver should crop the loaded bitmap glyph
   *     (i.e., remove all space around its black bits).  Not all drivers
   *     implement this.
   *
   *   FT_LOAD_PEDANTIC ::
   *     Indicates that the font driver should perform pedantic verifications
   *     during glyph loading.  This is mostly used to detect broken glyphs
   *     in fonts.  By default, FreeType tries to handle broken fonts also.
   *
   *     In particular, errors from the TrueType bytecode engine are not
   *     passed to the application if this flag is not set; this might
   *     result in partially hinted or distorted glyphs in case a glyph's
   *     bytecode is buggy.
   *
   *   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ::
   *     Ignored.  Deprecated.
   *
   *   FT_LOAD_NO_RECURSE ::
   *     This flag is only used internally.  It merely indicates that the
   *     font driver should not load composite glyphs recursively.  Instead,
   *     it should set the `num_subglyph' and `subglyphs' values of the
   *     glyph slot accordingly, and set `glyph->format' to
   *     @FT_GLYPH_FORMAT_COMPOSITE.
   *
   *     The description of sub-glyphs is not available to client
   *     applications for now.
   *
   *     This flag implies @FT_LOAD_NO_SCALE and @FT_LOAD_IGNORE_TRANSFORM.
   *
   *   FT_LOAD_IGNORE_TRANSFORM ::
   *     Indicates that the transform matrix set by @FT_Set_Transform should
   *     be ignored.
   *
   *   FT_LOAD_MONOCHROME ::
   *     This flag is used with @FT_LOAD_RENDER to indicate that you want to
   *     render an outline glyph to a 1-bit monochrome bitmap glyph, with
   *     8~pixels packed into each byte of the bitmap data.
   *
   *     Note that this has no effect on the hinting algorithm used.  You
   *     should rather use @FT_LOAD_TARGET_MONO so that the
   *     monochrome-optimized hinting algorithm is used.
   *
   *   FT_LOAD_LINEAR_DESIGN ::
   *     Indicates that the `linearHoriAdvance' and `linearVertAdvance'
   *     fields of @FT_GlyphSlotRec should be kept in font units.  See
   *     @FT_GlyphSlotRec for details.
   *
   *   FT_LOAD_NO_AUTOHINT ::
   *     Disable auto-hinter.  See also the note below.
   *
   *   FT_LOAD_COLOR ::
   *     This flag is used to request loading of color embedded-bitmap
   *     images.  The resulting color bitmaps, if available, will have the
   *     @FT_PIXEL_MODE_BGRA format.  When the flag is not used and color
   *     bitmaps are found, they will be converted to 256-level gray
   *     bitmaps transparently.  Those bitmaps will be in the
   *     @FT_PIXEL_MODE_GRAY format.
   *
   * @note:
   *   By default, hinting is enabled and the font's native hinter (see
   *   @FT_FACE_FLAG_HINTER) is preferred over the auto-hinter.  You can
   *   disable hinting by setting @FT_LOAD_NO_HINTING or change the
   *   precedence by setting @FT_LOAD_FORCE_AUTOHINT.  You can also set
   *   @FT_LOAD_NO_AUTOHINT in case you don't want the auto-hinter to be
   *   used at all.
   *
   *   See the description of @FT_FACE_FLAG_TRICKY for a special exception
   *   (affecting only a handful of Asian fonts).
   *
   *   Besides deciding which hinter to use, you can also decide which
   *   hinting algorithm to use.  See @FT_LOAD_TARGET_XXX for details.
   *
   *   Note that the auto-hinter needs a valid Unicode cmap (either a native
   *   one or synthesized by FreeType) for producing correct results.  If a
   *   font provides an incorrect mapping (for example, assigning the
   *   character code U+005A, LATIN CAPITAL LETTER Z, to a glyph depicting a
   *   mathematical integral sign), the auto-hinter might produce useless
   *   results.
   *
   */
#define FT_LOAD_DEFAULT                      0x0
#define FT_LOAD_NO_SCALE                     ( 1L << 0 )
#define FT_LOAD_NO_HINTING                   ( 1L << 1 )
#define FT_LOAD_RENDER                       ( 1L << 2 )
#define FT_LOAD_NO_BITMAP                    ( 1L << 3 )
#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4 )
#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5 )
#define FT_LOAD_CROP_BITMAP                  ( 1L << 6 )
#define FT_LOAD_PEDANTIC                     ( 1L << 7 )
#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9 )
#define FT_LOAD_NO_RECURSE                   ( 1L << 10 )
#define FT_LOAD_IGNORE_TRANSFORM             ( 1L << 11 )
#define FT_LOAD_MONOCHROME                   ( 1L << 12 )
#define FT_LOAD_LINEAR_DESIGN                ( 1L << 13 )
#define FT_LOAD_NO_AUTOHINT                  ( 1L << 15 )
  /* Bits 16..19 are used by `FT_LOAD_TARGET_' */
#define FT_LOAD_COLOR                        ( 1L << 20 )

  /* */

  /* used internally only by certain font drivers! */
#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8 )
#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )


  /**************************************************************************
   *
   * @enum:
   *   FT_LOAD_TARGET_XXX
   *
   * @description:
   *   A list of values that are used to select a specific hinting algorithm
   *   to use by the hinter.  You should OR one of these values to your
   *   `load_flags' when calling @FT_Load_Glyph.
   *
   *   Note that font's native hinters may ignore the hinting algorithm you
   *   have specified (e.g., the TrueType bytecode interpreter).  You can set
   *   @FT_LOAD_FORCE_AUTOHINT to ensure that the auto-hinter is used.
   *
   *   Also note that @FT_LOAD_TARGET_LIGHT is an exception, in that it
   *   always implies @FT_LOAD_FORCE_AUTOHINT.
   *
   * @values:
   *   FT_LOAD_TARGET_NORMAL ::
   *     This corresponds to the default hinting algorithm, optimized for
   *     standard gray-level rendering.  For monochrome output, use
   *     @FT_LOAD_TARGET_MONO instead.
   *
   *   FT_LOAD_TARGET_LIGHT ::
   *     A lighter hinting algorithm for non-monochrome modes.  Many
   *     generated glyphs are more fuzzy but better resemble its original
   *     shape.  A bit like rendering on Mac OS~X.
   *
   *     As a special exception, this target implies @FT_LOAD_FORCE_AUTOHINT.
   *
   *   FT_LOAD_TARGET_MONO ::
   *     Strong hinting algorithm that should only be used for monochrome
   *     output.  The result is probably unpleasant if the glyph is rendered
   *     in non-monochrome modes.
   *
   *   FT_LOAD_TARGET_LCD ::
   *     A variant of @FT_LOAD_TARGET_NORMAL optimized for horizontally
   *     decimated LCD displays.
   *
   *   FT_LOAD_TARGET_LCD_V ::
   *     A variant of @FT_LOAD_TARGET_NORMAL optimized for vertically
   *     decimated LCD displays.
   *
   * @note:
   *   You should use only _one_ of the FT_LOAD_TARGET_XXX values in your
   *   `load_flags'.  They can't be ORed.
   *
   *   If @FT_LOAD_RENDER is also set, the glyph is rendered in the
   *   corresponding mode (i.e., the mode which matches the used algorithm
   *   best).  An exeption is FT_LOAD_TARGET_MONO since it implies
   *   @FT_LOAD_MONOCHROME.
   *
   *   You can use a hinting algorithm that doesn't correspond to the same
   *   rendering mode.  As an example, it is possible to use the `light'
   *   hinting algorithm and have the results rendered in horizontal LCD
   *   pixel mode, with code like
   *
   *     {
   *       FT_Load_Glyph( face, glyph_index,
   *                      load_flags | FT_LOAD_TARGET_LIGHT );
   *
   *       FT_Render_Glyph( face->glyph, FT_RENDER_MODE_LCD );
   *     }
   *
   */
#define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )

#define FT_LOAD_TARGET_NORMAL  FT_LOAD_TARGET_( FT_RENDER_MODE_NORMAL )
#define FT_LOAD_TARGET_LIGHT   FT_LOAD_TARGET_( FT_RENDER_MODE_LIGHT  )
#define FT_LOAD_TARGET_MONO    FT_LOAD_TARGET_( FT_RENDER_MODE_MONO   )
#define FT_LOAD_TARGET_LCD     FT_LOAD_TARGET_( FT_RENDER_MODE_LCD    )
#define FT_LOAD_TARGET_LCD_V   FT_LOAD_TARGET_( FT_RENDER_MODE_LCD_V  )


  /**************************************************************************
   *
   * @macro:
   *   FT_LOAD_TARGET_MODE
   *
   * @description:
   *   Return the @FT_Render_Mode corresponding to a given
   *   @FT_LOAD_TARGET_XXX value.
   *
   */
#define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Transform                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A function used to set the transformation that is applied to glyph */
  /*    images when they are loaded into a glyph slot through              */
  /*    @FT_Load_Glyph.                                                    */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face   :: A handle to the source face object.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    matrix :: A pointer to the transformation's 2x2 matrix.  Use~0 for */
  /*              the identity matrix.                                     */
  /*    delta  :: A pointer to the translation vector.  Use~0 for the null */
  /*              vector.                                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The transformation is only applied to scalable image formats after */
  /*    the glyph has been loaded.  It means that hinting is unaltered by  */
  /*    the transformation and is performed on the character size given in */
  /*    the last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.         */
  /*                                                                       */
  /*    Note that this also transforms the `face.glyph.advance' field, but */
  /*    *not* the values in `face.glyph.metrics'.                          */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Set_Transform( FT_Face     face,
                    FT_Matrix*  matrix,
                    FT_Vector*  delta );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Render_Mode                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration type that lists the render modes supported by       */
  /*    FreeType~2.  Each mode corresponds to a specific type of scanline  */
  /*    conversion performed on the outline.                               */
  /*                                                                       */
  /*    For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode'     */
  /*    field in the @FT_GlyphSlotRec structure gives the format of the    */
  /*    returned bitmap.                                                   */
  /*                                                                       */
  /*    All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity.   */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_RENDER_MODE_NORMAL ::                                           */
  /*      This is the default render mode; it corresponds to 8-bit         */
  /*      anti-aliased bitmaps.                                            */
  /*                                                                       */
  /*    FT_RENDER_MODE_LIGHT ::                                            */
  /*      This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only        */
  /*      defined as a separate value because render modes are also used   */
  /*      indirectly to define hinting algorithm selectors.  See           */
  /*      @FT_LOAD_TARGET_XXX for details.                                 */
  /*                                                                       */
  /*    FT_RENDER_MODE_MONO ::                                             */
  /*      This mode corresponds to 1-bit bitmaps (with 2~levels of         */
  /*      opacity).                                                        */
  /*                                                                       */
  /*    FT_RENDER_MODE_LCD ::                                              */
  /*      This mode corresponds to horizontal RGB and BGR sub-pixel        */
  /*      displays like LCD screens.  It produces 8-bit bitmaps that are   */
  /*      3~times the width of the original glyph outline in pixels, and   */
  /*      which use the @FT_PIXEL_MODE_LCD mode.                           */
  /*                                                                       */
  /*    FT_RENDER_MODE_LCD_V ::                                            */
  /*      This mode corresponds to vertical RGB and BGR sub-pixel displays */
  /*      (like PDA screens, rotated LCD displays, etc.).  It produces     */
  /*      8-bit bitmaps that are 3~times the height of the original        */
  /*      glyph outline in pixels and use the @FT_PIXEL_MODE_LCD_V mode.   */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The LCD-optimized glyph bitmaps produced by FT_Render_Glyph can be */
  /*    filtered to reduce color-fringes by using @FT_Library_SetLcdFilter */
  /*    (not active in the default builds).  It is up to the caller to     */
  /*    either call @FT_Library_SetLcdFilter (if available) or do the      */
  /*    filtering itself.                                                  */
  /*                                                                       */
  /*    The selected render mode only affects vector glyphs of a font.     */
  /*    Embedded bitmaps often have a different pixel mode like            */
  /*    @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform  */
  /*    them into 8-bit pixmaps.                                           */
  /*                                                                       */
  typedef enum  FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    ft_render_mode_xxx                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    These constants are deprecated.  Use the corresponding             */
  /*    @FT_Render_Mode values instead.                                    */
  /*                                                                       */
  /* <Values>                                                              */
  /*    ft_render_mode_normal :: see @FT_RENDER_MODE_NORMAL                */
  /*    ft_render_mode_mono   :: see @FT_RENDER_MODE_MONO                  */
  /*                                                                       */
#define ft_render_mode_normal  FT_RENDER_MODE_NORMAL
#define ft_render_mode_mono    FT_RENDER_MODE_MONO


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Render_Glyph                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Convert a given glyph image to a bitmap.  It does so by inspecting */
  /*    the glyph image format, finding the relevant renderer, and         */
  /*    invoking it.                                                       */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    slot        :: A handle to the glyph slot containing the image to  */
  /*                   convert.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    render_mode :: This is the render mode used to render the glyph    */
  /*                   image into a bitmap.  See @FT_Render_Mode for a     */
  /*                   list of possible values.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Render_Glyph( FT_GlyphSlot    slot,
                   FT_Render_Mode  render_mode );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_Kerning_Mode                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    An enumeration used to specify which kerning values to return in   */
  /*    @FT_Get_Kerning.                                                   */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_KERNING_DEFAULT  :: Return scaled and grid-fitted kerning       */
  /*                           distances (value is~0).                     */
  /*                                                                       */
  /*    FT_KERNING_UNFITTED :: Return scaled but un-grid-fitted kerning    */
  /*                           distances.                                  */
  /*                                                                       */
  /*    FT_KERNING_UNSCALED :: Return the kerning vector in original font  */
  /*                           units.                                      */
  /*                                                                       */
  typedef enum  FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT  = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;


  /*************************************************************************/
  /*                                                                       */
  /* <Const>                                                               */
  /*    ft_kerning_default                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This constant is deprecated.  Please use @FT_KERNING_DEFAULT       */
  /*    instead.                                                           */
  /*                                                                       */
#define ft_kerning_default   FT_KERNING_DEFAULT


  /*************************************************************************/
  /*                                                                       */
  /* <Const>                                                               */
  /*    ft_kerning_unfitted                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This constant is deprecated.  Please use @FT_KERNING_UNFITTED      */
  /*    instead.                                                           */
  /*                                                                       */
#define ft_kerning_unfitted  FT_KERNING_UNFITTED


  /*************************************************************************/
  /*                                                                       */
  /* <Const>                                                               */
  /*    ft_kerning_unscaled                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This constant is deprecated.  Please use @FT_KERNING_UNSCALED      */
  /*    instead.                                                           */
  /*                                                                       */
#define ft_kerning_unscaled  FT_KERNING_UNSCALED


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Kerning                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the kerning vector between two glyphs of a same face.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face        :: A handle to a source face object.                   */
  /*                                                                       */
  /*    left_glyph  :: The index of the left glyph in the kern pair.       */
  /*                                                                       */
  /*    right_glyph :: The index of the right glyph in the kern pair.      */
  /*                                                                       */
  /*    kern_mode   :: See @FT_Kerning_Mode for more information.          */
  /*                   Determines the scale and dimension of the returned  */
  /*                   kerning vector.                                     */
  /*                                                                       */
  /* <Output>                                                              */
  /*    akerning    :: The kerning vector.  This is either in font units   */
  /*                   or in pixels (26.6 format) for scalable formats,    */
  /*                   and in pixels for fixed-sizes formats.              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Only horizontal layouts (left-to-right & right-to-left) are        */
  /*    supported by this method.  Other layouts, or more sophisticated    */
  /*    kernings, are out of the scope of this API function -- they can be */
  /*    implemented through format-specific interfaces.                    */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Kerning( FT_Face     face,
                  FT_UInt     left_glyph,
                  FT_UInt     right_glyph,
                  FT_UInt     kern_mode,
                  FT_Vector  *akerning );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Track_Kerning                                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the track kerning for a given face object at a given size.  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face       :: A handle to a source face object.                    */
  /*                                                                       */
  /*    point_size :: The point size in 16.16 fractional points.           */
  /*                                                                       */
  /*    degree     :: The degree of tightness.  Increasingly negative      */
  /*                  values represent tighter track kerning, while        */
  /*                  increasingly positive values represent looser track  */
  /*                  kerning.  Value zero means no track kerning.         */
  /*                                                                       */
  /* <Output>                                                              */
  /*    akerning   :: The kerning in 16.16 fractional points, to be        */
  /*                  uniformly applied between all glyphs.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Currently, only the Type~1 font driver supports track kerning,     */
  /*    using data from AFM files (if attached with @FT_Attach_File or     */
  /*    @FT_Attach_Stream).                                                */
  /*                                                                       */
  /*    Only very few AFM files come with track kerning data; please refer */
  /*    to the Adobe's AFM specification for more details.                 */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Track_Kerning( FT_Face    face,
                        FT_Fixed   point_size,
                        FT_Int     degree,
                        FT_Fixed*  akerning );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Glyph_Name                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Retrieve the ASCII name of a given glyph in a face.  This only     */
  /*    works for those faces where @FT_HAS_GLYPH_NAMES(face) returns~1.   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face        :: A handle to a source face object.                   */
  /*                                                                       */
  /*    glyph_index :: The glyph index.                                    */
  /*                                                                       */
  /*    buffer_max  :: The maximum number of bytes available in the        */
  /*                   buffer.                                             */
  /*                                                                       */
  /* <Output>                                                              */
  /*    buffer      :: A pointer to a target buffer where the name is      */
  /*                   copied to.                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    An error is returned if the face doesn't provide glyph names or if */
  /*    the glyph index is invalid.  In all cases of failure, the first    */
  /*    byte of `buffer' is set to~0 to indicate an empty name.            */
  /*                                                                       */
  /*    The glyph name is truncated to fit within the buffer if it is too  */
  /*    long.  The returned string is always zero-terminated.              */
  /*                                                                       */
  /*    Be aware that FreeType reorders glyph indices internally so that   */
  /*    glyph index~0 always corresponds to the `missing glyph' (called    */
  /*    `.notdef').                                                        */
  /*                                                                       */
  /*    This function is not compiled within the library if the config     */
  /*    macro `FT_CONFIG_OPTION_NO_GLYPH_NAMES' is defined in              */
  /*    `include/freetype/config/ftoptions.h'.                             */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Get_Glyph_Name( FT_Face     face,
                     FT_UInt     glyph_index,
                     FT_Pointer  buffer,
                     FT_UInt     buffer_max );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Postscript_Name                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Retrieve the ASCII PostScript name of a given face, if available.  */
  /*    This only works with PostScript and TrueType fonts.                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the source face object.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to the face's PostScript name.  NULL if unavailable.     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The returned pointer is owned by the face and is destroyed with    */
  /*    it.                                                                */
  /*                                                                       */
  FT_EXPORT( const char* )
  FT_Get_Postscript_Name( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Select_Charmap                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a given charmap by its encoding tag (as listed in           */
  /*    `freetype.h').                                                     */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face     :: A handle to the source face object.                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    encoding :: A handle to the selected encoding.                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function returns an error if no charmap in the face           */
  /*    corresponds to the encoding queried here.                          */
  /*                                                                       */
  /*    Because many fonts contain more than a single cmap for Unicode     */
  /*    encoding, this function has some special code to select the one    */
  /*    which covers Unicode best (`best' in the sense that a UCS-4 cmap   */
  /*    is preferred to a UCS-2 cmap).  It is thus preferable to           */
  /*    @FT_Set_Charmap in this case.                                      */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Select_Charmap( FT_Face      face,
                     FT_Encoding  encoding );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Set_Charmap                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Select a given charmap for character code to glyph index mapping.  */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face    :: A handle to the source face object.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charmap :: A handle to the selected charmap.                       */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0~means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function returns an error if the charmap is not part of       */
  /*    the face (i.e., if it is not listed in the `face->charmaps'        */
  /*    table).                                                            */
  /*                                                                       */
  /*    It also fails if a type~14 charmap is selected.                    */
  /*                                                                       */
  FT_EXPORT( FT_Error )
  FT_Set_Charmap( FT_Face     face,
                  FT_CharMap  charmap );


  /*************************************************************************
   *
   * @function:
   *   FT_Get_Charmap_Index
   *
   * @description:
   *   Retrieve index of a given charmap.
   *
   * @input:
   *   charmap ::
   *     A handle to a charmap.
   *
   * @return:
   *   The index into the array of character maps within the face to which
   *   `charmap' belongs.  If an error occurs, -1 is returned.
   *
   */
  FT_EXPORT( FT_Int )
  FT_Get_Charmap_Index( FT_CharMap  charmap );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Char_Index                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given character code.  This function   */
  /*    uses a charmap object to do the mapping.                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the source face object.                    */
  /*                                                                       */
  /*    charcode :: The character code.                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means `undefined character code'.              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If you use FreeType to manipulate the contents of font files       */
  /*    directly, be aware that the glyph index returned by this function  */
  /*    doesn't always correspond to the internal indices used within the  */
  /*    file.  This is done to ensure that value~0 always corresponds to   */
  /*    the `missing glyph'.  If the first glyph is not named `.notdef',   */
  /*    then for Type~1 and Type~42 fonts, `.notdef' will be moved into    */
  /*    the glyph ID~0 position, and whatever was there will be moved to   */
  /*    the position `.notdef' had.  For Type~1 fonts, if there is no      */
  /*    `.notdef' glyph at all, then one will be created at index~0 and    */
  /*    whatever was there will be moved to the last index -- Type~42      */
  /*    fonts are considered invalid under this condition.                 */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Get_Char_Index( FT_Face   face,
                     FT_ULong  charcode );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_First_Char                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function is used to return the first character code in the    */
  /*    current charmap of a given face.  It also returns the              */
  /*    corresponding glyph index.                                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face    :: A handle to the source face object.                     */
  /*                                                                       */
  /* <Output>                                                              */
  /*    agindex :: Glyph index of first character code.  0~if charmap is   */
  /*               empty.                                                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The charmap's first character code.                                */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should use this function with @FT_Get_Next_Char to be able to  */
  /*    parse all character codes available in a given charmap.  The code  */
  /*    should look like this:                                             */
  /*                                                                       */
  /*    {                                                                  */
  /*      FT_ULong  charcode;                                              */
  /*      FT_UInt   gindex;                                                */
  /*                                                                       */
  /*                                                                       */
  /*      charcode = FT_Get_First_Char( face, &gindex );                   */
  /*      while ( gindex != 0 )                                            */
  /*      {                                                                */
  /*        ... do something with (charcode,gindex) pair ...               */
  /*                                                                       */
  /*        charcode = FT_Get_Next_Char( face, charcode, &gindex );        */
  /*      }                                                                */
  /*    }                                                                  */
  /*                                                                       */
  /*    Note that `*agindex' is set to~0 if the charmap is empty.  The     */
  /*    result itself can be~0 in two cases: if the charmap is empty or    */
  /*    if the value~0 is the first valid character code.                  */
  /*                                                                       */
  FT_EXPORT( FT_ULong )
  FT_Get_First_Char( FT_Face   face,
                     FT_UInt  *agindex );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Next_Char                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This function is used to return the next character code in the     */
  /*    current charmap of a given face following the value `char_code',   */
  /*    as well as the corresponding glyph index.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face      :: A handle to the source face object.                   */
  /*    char_code :: The starting character code.                          */
  /*                                                                       */
  /* <Output>                                                              */
  /*    agindex   :: Glyph index of next character code.  0~if charmap     */
  /*                 is empty.                                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The charmap's next character code.                                 */
  /*                                                                       */
  /* <Note>                                                                */
  /*    You should use this function with @FT_Get_First_Char to walk       */
  /*    over all character codes available in a given charmap.  See the    */
  /*    note for this function for a simple code example.                  */
  /*                                                                       */
  /*    Note that `*agindex' is set to~0 when there are no more codes in   */
  /*    the charmap.                                                       */
  /*                                                                       */
  FT_EXPORT( FT_ULong )
  FT_Get_Next_Char( FT_Face    face,
                    FT_ULong   char_code,
                    FT_UInt   *agindex );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_Name_Index                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given glyph name.  This function uses  */
  /*    driver specific objects to do the translation.                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face       :: A handle to the source face object.                  */
  /*                                                                       */
  /*    glyph_name :: The glyph name.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means `undefined character code'.              */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Get_Name_Index( FT_Face     face,
                     FT_String*  glyph_name );


  /*************************************************************************
   *
   * @macro:
   *   FT_SUBGLYPH_FLAG_XXX
   *
   * @description:
   *   A list of constants used to describe subglyphs.  Please refer to the
   *   TrueType specification for the meaning of the various flags.
   *
   * @values:
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS ::
   *   FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES ::
   *   FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID ::
   *   FT_SUBGLYPH_FLAG_SCALE ::
   *   FT_SUBGLYPH_FLAG_XY_SCALE ::
   *   FT_SUBGLYPH_FLAG_2X2 ::
   *   FT_SUBGLYPH_FLAG_USE_MY_METRICS ::
   *
   */
#define FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS          1
#define FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES      2
#define FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID        4
#define FT_SUBGLYPH_FLAG_SCALE                   8
#define FT_SUBGLYPH_FLAG_XY_SCALE             0x40
#define FT_SUBGLYPH_FLAG_2X2                  0x80
#define FT_SUBGLYPH_FLAG_USE_MY_METRICS      0x200


  /*************************************************************************
   *
   * @func:
   *   FT_Get_SubGlyph_Info
   *
   * @description:
   *   Retrieve a description of a given subglyph.  Only use it if
   *   `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
   *   returned otherwise.
   *
   * @input:
   *   glyph ::
   *     The source glyph slot.
   *
   *   sub_index ::
   *     The index of the subglyph.  Must be less than
   *     `glyph->num_subglyphs'.
   *
   * @output:
   *   p_index ::
   *     The glyph index of the subglyph.
   *
   *   p_flags ::
   *     The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
   *
   *   p_arg1 ::
   *     The subglyph's first argument (if any).
   *
   *   p_arg2 ::
   *     The subglyph's second argument (if any).
   *
   *   p_transform ::
   *     The subglyph transformation (if any).
   *
   * @return:
   *   FreeType error code.  0~means success.
   *
   * @note:
   *   The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
   *   interpreted depending on the flags returned in `*p_flags'.  See the
   *   TrueType specification for details.
   *
   */
  FT_EXPORT( FT_Error )
  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,
                        FT_UInt       sub_index,
                        FT_Int       *p_index,
                        FT_UInt      *p_flags,
                        FT_Int       *p_arg1,
                        FT_Int       *p_arg2,
                        FT_Matrix    *p_transform );


  /*************************************************************************/
  /*                                                                       */
  /* <Enum>                                                                */
  /*    FT_FSTYPE_XXX                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A list of bit flags used in the `fsType' field of the OS/2 table   */
  /*    in a TrueType or OpenType font and the `FSType' entry in a         */
  /*    PostScript font.  These bit flags are returned by                  */
  /*    @FT_Get_FSType_Flags; they inform client applications of embedding */
  /*    and subsetting restrictions associated with a font.                */
  /*                                                                       */
  /*    See http://www.adobe.com/devnet/acrobat/pdfs/FontPolicies.pdf for  */
  /*    more details.                                                      */
  /*                                                                       */
  /* <Values>                                                              */
  /*    FT_FSTYPE_INSTALLABLE_EMBEDDING ::                                 */
  /*      Fonts with no fsType bit set may be embedded and permanently     */
  /*      installed on the remote system by an application.                */
  /*                                                                       */
  /*    FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING ::                          */
  /*      Fonts that have only this bit set must not be modified, embedded */
  /*      or exchanged in any manner without first obtaining permission of */
  /*      the font software copyright owner.                               */
  /*                                                                       */
  /*    FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING ::                           */
  /*      If this bit is set, the font may be embedded and temporarily     */
  /*      loaded on the remote system.  Documents containing Preview &     */
  /*      Print fonts must be opened `read-only'; no edits can be applied  */
  /*      to the document.                                                 */
  /*                                                                       */
  /*    FT_FSTYPE_EDITABLE_EMBEDDING ::                                    */
  /*      If this bit is set, the font may be embedded but must only be    */
  /*      installed temporarily on other systems.  In contrast to Preview  */
  /*      & Print fonts, documents containing editable fonts may be opened */
  /*      for reading, editing is permitted, and changes may be saved.     */
  /*                                                                       */
  /*    FT_FSTYPE_NO_SUBSETTING ::                                         */
  /*      If this bit is set, the font may not be subsetted prior to       */
  /*      embedding.                                                       */
  /*                                                                       */
  /*    FT_FSTYPE_BITMAP_EMBEDDING_ONLY ::                                 */
  /*      If this bit is set, only bitmaps contained in the font may be    */
  /*      embedded; no outline data may be embedded.  If there are no      */
  /*      bitmaps available in the font, then the font is unembeddable.    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    While the fsType flags can indicate that a font may be embedded, a */
  /*    license with the font vendor may be separately required to use the */
  /*    font in this way.                                                  */
  /*                                                                       */
#define FT_FSTYPE_INSTALLABLE_EMBEDDING         0x0000
#define FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING  0x0002
#define FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING   0x0004
#define FT_FSTYPE_EDITABLE_EMBEDDING            0x0008
#define FT_FSTYPE_NO_SUBSETTING                 0x0100
#define FT_FSTYPE_BITMAP_EMBEDDING_ONLY         0x0200


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Get_FSType_Flags                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the fsType flags for a font.                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the source face object.                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The fsType flags, @FT_FSTYPE_XXX.                                  */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Use this function rather than directly reading the `fs_type' field */
  /*    in the @PS_FontInfoRec structure which is only guaranteed to       */
  /*    return the correct results for Type~1 fonts.                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.8                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UShort )
  FT_Get_FSType_Flags( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    glyph_variants                                                     */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Glyph Variants                                                     */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    The FreeType~2 interface to Unicode Ideographic Variation          */
  /*    Sequences (IVS), using the SFNT cmap format~14.                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Many CJK characters have variant forms.  They are a sort of grey   */
  /*    area somewhere between being totally irrelevant and semantically   */
  /*    distinct; for this reason, the Unicode consortium decided to       */
  /*    introduce Ideographic Variation Sequences (IVS), consisting of a   */
  /*    Unicode base character and one of 240 variant selectors            */
  /*    (U+E0100-U+E01EF), instead of further extending the already huge   */
  /*    code range for CJK characters.                                     */
  /*                                                                       */
  /*    An IVS is registered and unique; for further details please refer  */
  /*    to Unicode Technical Standard #37, the Ideographic Variation       */
  /*    Database:                                                          */
  /*                                                                       */
  /*      http://www.unicode.org/reports/tr37/                             */
  /*                                                                       */
  /*    To date (November 2012), the character with the most variants is   */
  /*    U+9089, having 31 such IVS.                                        */
  /*                                                                       */
  /*    Adobe and MS decided to support IVS with a new cmap subtable       */
  /*    (format~14).  It is an odd subtable because it is not a mapping of */
  /*    input code points to glyphs, but contains lists of all variants    */
  /*    supported by the font.                                             */
  /*                                                                       */
  /*    A variant may be either `default' or `non-default'.  A default     */
  /*    variant is the one you will get for that code point if you look it */
  /*    up in the standard Unicode cmap.  A non-default variant is a       */
  /*    different glyph.                                                   */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharVariantIndex                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the glyph index of a given character code as modified by    */
  /*    the variation selector.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character code point in Unicode.                             */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The Unicode code point of the variation selector.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The glyph index.  0~means either `undefined character code', or    */
  /*    `undefined selector code', or `no variation selector cmap          */
  /*    subtable', or `current CharMap is not Unicode'.                    */
  /*                                                                       */
  /* <Note>                                                                */
  /*    If you use FreeType to manipulate the contents of font files       */
  /*    directly, be aware that the glyph index returned by this function  */
  /*    doesn't always correspond to the internal indices used within      */
  /*    the file.  This is done to ensure that value~0 always corresponds  */
  /*    to the `missing glyph'.                                            */
  /*                                                                       */
  /*    This function is only meaningful if                                */
  /*      a) the font has a variation selector cmap sub table,             */
  /*    and                                                                */
  /*      b) the current charmap has a Unicode encoding.                   */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt )
  FT_Face_GetCharVariantIndex( FT_Face   face,
                               FT_ULong  charcode,
                               FT_ULong  variantSelector );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharVariantIsDefault                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Check whether this variant of this Unicode character is the one to */
  /*    be found in the `cmap'.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character codepoint in Unicode.                              */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The Unicode codepoint of the variation selector.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    1~if found in the standard (Unicode) cmap, 0~if found in the       */
  /*    variation selector cmap, or -1 if it is not a variant.             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function is only meaningful if the font has a variation       */
  /*    selector cmap subtable.                                            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Int )
  FT_Face_GetCharVariantIsDefault( FT_Face   face,
                                   FT_ULong  charcode,
                                   FT_ULong  variantSelector );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetVariantSelectors                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode variant selectors found   */
  /*    in the font.                                                       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to an array of selector code points, or NULL if there is */
  /*    no valid variant selector cmap subtable.                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetVariantSelectors( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetVariantsOfChar                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode variant selectors found   */
  /*    for the specified character code.                                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    charcode ::                                                        */
  /*      The character codepoint in Unicode.                              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to an array of variant selector code points which are    */
  /*    active for the given character, or NULL if the corresponding list  */
  /*    is empty.                                                          */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetVariantsOfChar( FT_Face   face,
                             FT_ULong  charcode );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_GetCharsOfVariant                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return a zero-terminated list of Unicode character codes found for */
  /*    the specified variant selector.                                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face ::                                                            */
  /*      A handle to the source face object.                              */
  /*                                                                       */
  /*    variantSelector ::                                                 */
  /*      The variant selector code point in Unicode.                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A list of all the code points which are specified by this selector */
  /*    (both default and non-default codes are returned) or NULL if there */
  /*    is no valid cmap or the variant selector is invalid.               */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The last item in the array is~0; the array is owned by the         */
  /*    @FT_Face object but can be overwritten or released on the next     */
  /*    call to a FreeType function.                                       */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.6                                                              */
  /*                                                                       */
  FT_EXPORT( FT_UInt32* )
  FT_Face_GetCharsOfVariant( FT_Face   face,
                             FT_ULong  variantSelector );


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    computations                                                       */
  /*                                                                       */
  /* <Title>                                                               */
  /*    Computations                                                       */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Crunching fixed numbers and vectors.                               */
  /*                                                                       */
  /* <Description>                                                         */
  /*    This section contains various functions used to perform            */
  /*    computations on 16.16 fixed-float numbers or 2d vectors.           */
  /*                                                                       */
  /* <Order>                                                               */
  /*    FT_MulDiv                                                          */
  /*    FT_MulFix                                                          */
  /*    FT_DivFix                                                          */
  /*    FT_RoundFix                                                        */
  /*    FT_CeilFix                                                         */
  /*    FT_FloorFix                                                        */
  /*    FT_Vector_Transform                                                */
  /*    FT_Matrix_Multiply                                                 */
  /*    FT_Matrix_Invert                                                   */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_MulDiv                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to perform the computation `(a*b)/c'   */
  /*    with maximum accuracy (it uses a 64-bit intermediate integer       */
  /*    whenever necessary).                                               */
  /*                                                                       */
  /*    This function isn't necessarily as fast as some processor specific */
  /*    operations, but is at least completely portable.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The first multiplier.                                         */
  /*    b :: The second multiplier.                                        */
  /*    c :: The divisor.                                                  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*b)/c'.  This function never traps when trying to */
  /*    divide by zero; it simply returns `MaxInt' or `MinInt' depending   */
  /*    on the signs of `a' and `b'.                                       */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c );


  /* */

  /* The following #if 0 ... #endif is for the documentation formatter, */
  /* hiding the internal `FT_MULFIX_INLINED' macro.                     */

#if 0
  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_MulFix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to perform the computation             */
  /*    `(a*b)/0x10000' with maximum accuracy.  Most of the time this is   */
  /*    used to multiply a given value by a 16.16 fixed-point factor.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The first multiplier.                                         */
  /*    b :: The second multiplier.  Use a 16.16 factor here whenever      */
  /*         possible (see note below).                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*b)/0x10000'.                                     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    This function has been optimized for the case where the absolute   */
  /*    value of `a' is less than 2048, and `b' is a 16.16 scaling factor. */
  /*    As this happens mainly when scaling from notional units to         */
  /*    fractional pixels in FreeType, it resulted in noticeable speed     */
  /*    improvements between versions 2.x and 1.x.                         */
  /*                                                                       */
  /*    As a conclusion, always try to place a 16.16 factor as the         */
  /*    _second_ argument of this function; this can make a great          */
  /*    difference.                                                        */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_MulFix( FT_Long  a,
             FT_Long  b );

  /* */
#endif

#ifdef FT_MULFIX_INLINED
#define FT_MulFix( a, b )  FT_MULFIX_INLINED( a, b )
#else
  FT_EXPORT( FT_Long )
  FT_MulFix( FT_Long  a,
             FT_Long  b );
#endif


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_DivFix                                                          */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to perform the computation             */
  /*    `(a*0x10000)/b' with maximum accuracy.  Most of the time, this is  */
  /*    used to divide a given value by a 16.16 fixed-point factor.        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The first multiplier.                                         */
  /*    b :: The second multiplier.  Use a 16.16 factor here whenever      */
  /*         possible (see note below).                                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a*0x10000)/b'.                                     */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The optimization for FT_DivFix() is simple: If (a~<<~16) fits in   */
  /*    32~bits, then the division is computed directly.  Otherwise, we    */
  /*    use a specialized version of @FT_MulDiv.                           */
  /*                                                                       */
  FT_EXPORT( FT_Long )
  FT_DivFix( FT_Long  a,
             FT_Long  b );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_RoundFix                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to round a 16.16 fixed number.         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number to be rounded.                                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a + 0x8000) & -0x10000'.                           */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_RoundFix( FT_Fixed  a );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_CeilFix                                                         */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to compute the ceiling function of a   */
  /*    16.16 fixed number.                                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number for which the ceiling function is to be computed.  */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `(a + 0x10000 - 1) & -0x10000'.                      */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_CeilFix( FT_Fixed  a );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_FloorFix                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    A very simple function used to compute the floor function of a     */
  /*    16.16 fixed number.                                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    a :: The number for which the floor function is to be computed.    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The result of `a & -0x10000'.                                      */
  /*                                                                       */
  FT_EXPORT( FT_Fixed )
  FT_FloorFix( FT_Fixed  a );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Vector_Transform                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Transform a single vector through a 2x2 matrix.                    */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    vector :: The target vector to transform.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    matrix :: A pointer to the source 2x2 matrix.                      */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The result is undefined if either `vector' or `matrix' is invalid. */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Vector_Transform( FT_Vector*        vec,
                       const FT_Matrix*  matrix );


  /*************************************************************************/
  /*                                                                       */
  /* <Section>                                                             */
  /*    version                                                            */
  /*                                                                       */
  /* <Title>                                                               */
  /*    FreeType Version                                                   */
  /*                                                                       */
  /* <Abstract>                                                            */
  /*    Functions and macros related to FreeType versions.                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Note that those functions and macros are of limited use because    */
  /*    even a new release of FreeType with only documentation changes     */
  /*    increases the version number.                                      */
  /*                                                                       */
  /*************************************************************************/


  /*************************************************************************
   *
   * @enum:
   *   FREETYPE_XXX
   *
   * @description:
   *   These three macros identify the FreeType source code version.
   *   Use @FT_Library_Version to access them at runtime.
   *
   * @values:
   *   FREETYPE_MAJOR :: The major version number.
   *   FREETYPE_MINOR :: The minor version number.
   *   FREETYPE_PATCH :: The patch level.
   *
   * @note:
   *   The version number of FreeType if built as a dynamic link library
   *   with the `libtool' package is _not_ controlled by these three
   *   macros.
   *
   */
#define FREETYPE_MAJOR  2
#define FREETYPE_MINOR  5
#define FREETYPE_PATCH  0


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Library_Version                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Return the version of the FreeType library being used.  This is    */
  /*    useful when dynamically linking to the library, since one cannot   */
  /*    use the macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and               */
  /*    @FREETYPE_PATCH.                                                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    library :: A source library handle.                                */
  /*                                                                       */
  /* <Output>                                                              */
  /*    amajor  :: The major version number.                               */
  /*                                                                       */
  /*    aminor  :: The minor version number.                               */
  /*                                                                       */
  /*    apatch  :: The patch version number.                               */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The reason why this function takes a `library' argument is because */
  /*    certain programs implement library initialization in a custom way  */
  /*    that doesn't use @FT_Init_FreeType.                                */
  /*                                                                       */
  /*    In such cases, the library version might not be available before   */
  /*    the library object has been created.                               */
  /*                                                                       */
  FT_EXPORT( void )
  FT_Library_Version( FT_Library   library,
                      FT_Int      *amajor,
                      FT_Int      *aminor,
                      FT_Int      *apatch );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_CheckTrueTypePatents                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Parse all bytecode instructions of a TrueType font file to check   */
  /*    whether any of the patented opcodes are used.  This is only useful */
  /*    if you want to be able to use the unpatented hinter with           */
  /*    fonts that do *not* use these opcodes.                             */
  /*                                                                       */
  /*    Note that this function parses *all* glyph instructions in the     */
  /*    font file, which may be slow.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A face handle.                                             */
  /*                                                                       */
  /* <Return>                                                              */
  /*    1~if this is a TrueType font that uses one of the patented         */
  /*    opcodes, 0~otherwise.                                              */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since May 2010, TrueType hinting is no longer patented.            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.5                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Bool )
  FT_Face_CheckTrueTypePatents( FT_Face  face );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    FT_Face_SetUnpatentedHinting                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Enable or disable the unpatented hinter for a given face.          */
  /*    Only enable it if you have determined that the face doesn't        */
  /*    use any patented opcodes (see @FT_Face_CheckTrueTypePatents).      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face  :: A face handle.                                            */
  /*                                                                       */
  /*    value :: New boolean setting.                                      */
  /*                                                                       */
  /* <Return>                                                              */
  /*    The old setting value.  This will always be false if this is not   */
  /*    an SFNT font, or if the unpatented hinter is not compiled in this  */
  /*    instance of the library.                                           */
  /*                                                                       */
  /* <Note>                                                                */
  /*    Since May 2010, TrueType hinting is no longer patented.            */
  /*                                                                       */
  /* <Since>                                                               */
  /*    2.3.5                                                              */
  /*                                                                       */
  FT_EXPORT( FT_Bool )
  FT_Face_SetUnpatentedHinting( FT_Face  face,
                                FT_Bool  value );

  /* */


FT_END_HEADER

#endif /* __FREETYPE_H__ */


/* END */


// These warnings are for stb_image.c
#ifdef _MSC_VER
#pragma warning(push)          // push XO-AMALGAMATION-DISABLED-WARNINGS
#pragma warning(disable: 4251) // class needs to have dll-interface to be used by clients of class
#pragma warning(disable: 6001) // using uninitialized memory
#pragma warning(disable: 6246) // local declaration hides name in outer scope
#pragma warning(disable: 6262) // stack size
#pragma warning(disable: 6385) // reading invalid data
#endif

#ifndef ASSERT
	#define TEMP_ASSERT
	#ifdef _DEBUG
		#define ASSERT(condition) (void)0
	#else
		#define ASSERT(condition) assert(condition)
	#endif
#endif

#ifdef _WIN32
	#define XO_BUILD_DIRECTX 1
#else
	#define XO_BUILD_DIRECTX 0
#endif

#define XO_BUILD_OPENGL 1
#define PROJECT_XO 1

#ifdef _WIN32
#ifndef XOAPI
#define XOAPI __declspec(dllexport)
#else
#define XOAPI __declspec(dllimport)
#endif
#else
#define XOAPI
#endif


#ifdef _WIN32
#ifdef _DEBUG
#include <stdlib.h>
#include <crtdbg.h>
#endif
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <Shlobj.h>
#include <tchar.h>
#else
#define XO_BUILD_OPENGL 1
#ifdef ANDROID
// Android
#define XO_BUILD_OPENGL_ES 1
#include <jni.h>
#include <android/log.h>
#include <sys/atomics.h>
#else
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#endif
#ifdef XO_BUILD_OPENGL_ES
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>
#else
#include <GL/gl.h>
#include <GL/glx.h>
#include <GL/glu.h>
#endif
#include <pthread.h>
#include <semaphore.h>
#include <math.h>
#endif

#if XO_BUILD_DIRECTX
#include <D3D11.h>
#include <d3dcompiler.h>
#include <directxmath.h>
#include <directxcolors.h>
#endif

#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <float.h>

#include <string>
#include <algorithm>
#include <limits>
#include <functional>

#ifndef POINTER_C_GENERATED_HEADER_OPENGL_H
#define POINTER_C_GENERATED_HEADER_OPENGL_H

#if defined(__glew_h__) || defined(__GLEW_H__)
#error Attempt to include auto-generated header after including glew.h
#endif
#if defined(__gl_h_) || defined(__GL_H__)
#error Attempt to include auto-generated header after including gl.h
#endif
#if defined(__glext_h_) || defined(__GLEXT_H_)
#error Attempt to include auto-generated header after including glext.h
#endif
#if defined(__gltypes_h_)
#error Attempt to include auto-generated header after gltypes.h
#endif
#if defined(__gl_ATI_h_)
#error Attempt to include auto-generated header after including glATI.h
#endif

#define __glew_h__
#define __GLEW_H__
#define __gl_h_
#define __GL_H__
#define __glext_h_
#define __GLEXT_H_
#define __gltypes_h_
#define __gl_ATI_h_

#ifndef APIENTRY
#if defined(__MINGW32__)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#elif (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__)
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>
#else
#define APIENTRY
#endif
#endif /*APIENTRY*/

#ifndef CODEGEN_FUNCPTR
#define CODEGEN_REMOVE_FUNCPTR
#if defined(_WIN32)
#define CODEGEN_FUNCPTR APIENTRY
#else
#define CODEGEN_FUNCPTR
#endif
#endif /*CODEGEN_FUNCPTR*/

#ifndef GLAPI
#define GLAPI extern
#endif


#ifndef GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS
#define GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS


#endif /*GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS*/


#include <stddef.h>
#ifndef GLEXT_64_TYPES_DEFINED
/* This code block is duplicated in glxext.h, so must be protected */
#define GLEXT_64_TYPES_DEFINED
/* Define int32_t, int64_t, and uint64_t types for UST/MSC */
/* (as used in the GL_EXT_timer_query extension). */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#include <inttypes.h>
#elif defined(__sun__) || defined(__digital__)
#include <inttypes.h>
#if defined(__STDC__)
#if defined(__arch64__) || defined(_LP64)
typedef long int int64_t;
typedef unsigned long int uint64_t;
#else
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#endif /* __arch64__ */
#endif /* __STDC__ */
#elif defined( __VMS ) || defined(__sgi)
#include <inttypes.h>
#elif defined(__SCO__) || defined(__USLC__)
#include <stdint.h>
#elif defined(__UNIXOS2__) || defined(__SOL64__)
typedef long int int32_t;
typedef long long int int64_t;
typedef unsigned long long int uint64_t;
#elif defined(_WIN32) && defined(__GNUC__)
#include <stdint.h>
#elif defined(_WIN32)
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
/* Fallback if nothing above works */
#include <inttypes.h>
#endif
#endif
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef void GLvoid;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef int GLsizei;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef char GLchar;
typedef char GLcharARB;
#ifdef __APPLE__
typedef void *GLhandleARB;
#else
typedef unsigned int GLhandleARB;
#endif
typedef unsigned short GLhalfARB;
typedef unsigned short GLhalf;
typedef GLint GLfixed;
typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;
typedef int64_t GLint64;
typedef uint64_t GLuint64;
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
typedef struct __GLsync *GLsync;
struct _cl_context;
struct _cl_event;
typedef void (APIENTRY *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (APIENTRY *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLenum severity,GLsizei length,const GLchar *message,const void *userParam);
typedef void (APIENTRY *GLDEBUGPROCAMD)(GLuint id,GLenum category,GLenum severity,GLsizei length,const GLchar *message,void *userParam);
typedef unsigned short GLhalfNV;
typedef GLintptr GLvdpauSurfaceNV;

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

extern int ogl_ext_ARB_framebuffer_sRGB;
extern int ogl_ext_EXT_framebuffer_sRGB;

#define GL_FRAMEBUFFER_SRGB 0x8DB9

#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT 0x8DBA
#define GL_FRAMEBUFFER_SRGB_EXT 0x8DB9

#define GL_ALPHA 0x1906
#define GL_ALWAYS 0x0207
#define GL_AND 0x1501
#define GL_AND_INVERTED 0x1504
#define GL_AND_REVERSE 0x1502
#define GL_BACK 0x0405
#define GL_BACK_LEFT 0x0402
#define GL_BACK_RIGHT 0x0403
#define GL_BLEND 0x0BE2
#define GL_BLEND_DST 0x0BE0
#define GL_BLEND_SRC 0x0BE1
#define GL_BLUE 0x1905
#define GL_BYTE 0x1400
#define GL_CCW 0x0901
#define GL_CLEAR 0x1500
#define GL_COLOR 0x1800
#define GL_COLOR_BUFFER_BIT 0x00004000
#define GL_COLOR_CLEAR_VALUE 0x0C22
#define GL_COLOR_LOGIC_OP 0x0BF2
#define GL_COLOR_WRITEMASK 0x0C23
#define GL_COPY 0x1503
#define GL_COPY_INVERTED 0x150C
#define GL_CULL_FACE 0x0B44
#define GL_CULL_FACE_MODE 0x0B45
#define GL_CW 0x0900
#define GL_DECR 0x1E03
#define GL_DEPTH 0x1801
#define GL_DEPTH_BUFFER_BIT 0x00000100
#define GL_DEPTH_CLEAR_VALUE 0x0B73
#define GL_DEPTH_COMPONENT 0x1902
#define GL_DEPTH_FUNC 0x0B74
#define GL_DEPTH_RANGE 0x0B70
#define GL_DEPTH_TEST 0x0B71
#define GL_DEPTH_WRITEMASK 0x0B72
#define GL_DITHER 0x0BD0
#define GL_DONT_CARE 0x1100
#define GL_DOUBLE 0x140A
#define GL_DOUBLEBUFFER 0x0C32
#define GL_DRAW_BUFFER 0x0C01
#define GL_DST_ALPHA 0x0304
#define GL_DST_COLOR 0x0306
#define GL_EQUAL 0x0202
#define GL_EQUIV 0x1509
#define GL_EXTENSIONS 0x1F03
#define GL_FALSE 0
#define GL_FASTEST 0x1101
#define GL_FILL 0x1B02
#define GL_FLOAT 0x1406
#define GL_FRONT 0x0404
#define GL_FRONT_AND_BACK 0x0408
#define GL_FRONT_FACE 0x0B46
#define GL_FRONT_LEFT 0x0400
#define GL_FRONT_RIGHT 0x0401
#define GL_GEQUAL 0x0206
#define GL_GREATER 0x0204
#define GL_GREEN 0x1904
#define GL_INCR 0x1E02
#define GL_INT 0x1404
#define GL_INVALID_ENUM 0x0500
#define GL_INVALID_OPERATION 0x0502
#define GL_INVALID_VALUE 0x0501
#define GL_INVERT 0x150A
#define GL_KEEP 0x1E00
#define GL_LEFT 0x0406
#define GL_LEQUAL 0x0203
#define GL_LESS 0x0201
#define GL_LINE 0x1B01
#define GL_LINEAR 0x2601
#define GL_LINEAR_MIPMAP_LINEAR 0x2703
#define GL_LINEAR_MIPMAP_NEAREST 0x2701
#define GL_LINES 0x0001
#define GL_LINE_LOOP 0x0002
#define GL_LINE_SMOOTH 0x0B20
#define GL_LINE_SMOOTH_HINT 0x0C52
#define GL_LINE_STRIP 0x0003
#define GL_LINE_WIDTH 0x0B21
#define GL_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_LINE_WIDTH_RANGE 0x0B22
#define GL_LOGIC_OP_MODE 0x0BF0
#define GL_MAX_TEXTURE_SIZE 0x0D33
#define GL_MAX_VIEWPORT_DIMS 0x0D3A
#define GL_NAND 0x150E
#define GL_NEAREST 0x2600
#define GL_NEAREST_MIPMAP_LINEAR 0x2702
#define GL_NEAREST_MIPMAP_NEAREST 0x2700
#define GL_NEVER 0x0200
#define GL_NICEST 0x1102
#define GL_NONE 0
#define GL_NOOP 0x1505
#define GL_NOR 0x1508
#define GL_NOTEQUAL 0x0205
#define GL_NO_ERROR 0
#define GL_ONE 1
#define GL_ONE_MINUS_DST_ALPHA 0x0305
#define GL_ONE_MINUS_DST_COLOR 0x0307
#define GL_ONE_MINUS_SRC_ALPHA 0x0303
#define GL_ONE_MINUS_SRC_COLOR 0x0301
#define GL_OR 0x1507
#define GL_OR_INVERTED 0x150D
#define GL_OR_REVERSE 0x150B
#define GL_OUT_OF_MEMORY 0x0505
#define GL_PACK_ALIGNMENT 0x0D05
#define GL_PACK_LSB_FIRST 0x0D01
#define GL_PACK_ROW_LENGTH 0x0D02
#define GL_PACK_SKIP_PIXELS 0x0D04
#define GL_PACK_SKIP_ROWS 0x0D03
#define GL_PACK_SWAP_BYTES 0x0D00
#define GL_POINT 0x1B00
#define GL_POINTS 0x0000
#define GL_POINT_SIZE 0x0B11
#define GL_POINT_SIZE_GRANULARITY 0x0B13
#define GL_POINT_SIZE_RANGE 0x0B12
#define GL_POLYGON_MODE 0x0B40
#define GL_POLYGON_OFFSET_FACTOR 0x8038
#define GL_POLYGON_OFFSET_FILL 0x8037
#define GL_POLYGON_OFFSET_LINE 0x2A02
#define GL_POLYGON_OFFSET_POINT 0x2A01
#define GL_POLYGON_OFFSET_UNITS 0x2A00
#define GL_POLYGON_SMOOTH 0x0B41
#define GL_POLYGON_SMOOTH_HINT 0x0C53
#define GL_PROXY_TEXTURE_1D 0x8063
#define GL_PROXY_TEXTURE_2D 0x8064
#define GL_QUADS 0x0007
#define GL_R3_G3_B2 0x2A10
#define GL_READ_BUFFER 0x0C02
#define GL_RED 0x1903
#define GL_RENDERER 0x1F01
#define GL_REPEAT 0x2901
#define GL_REPLACE 0x1E01
#define GL_RGB 0x1907
#define GL_RGB10 0x8052
#define GL_RGB10_A2 0x8059
#define GL_RGB12 0x8053
#define GL_RGB16 0x8054
#define GL_RGB4 0x804F
#define GL_RGB5 0x8050
#define GL_RGB5_A1 0x8057
#define GL_RGB8 0x8051
#define GL_RGBA 0x1908
#define GL_RGBA12 0x805A
#define GL_RGBA16 0x805B
#define GL_RGBA2 0x8055
#define GL_RGBA4 0x8056
#define GL_RGBA8 0x8058
#define GL_RIGHT 0x0407
#define GL_SCISSOR_BOX 0x0C10
#define GL_SCISSOR_TEST 0x0C11
#define GL_SET 0x150F
#define GL_SHORT 0x1402
#define GL_SRC_ALPHA 0x0302
#define GL_SRC_ALPHA_SATURATE 0x0308
#define GL_SRC_COLOR 0x0300
#define GL_STENCIL 0x1802
#define GL_STENCIL_BUFFER_BIT 0x00000400
#define GL_STENCIL_CLEAR_VALUE 0x0B91
#define GL_STENCIL_FAIL 0x0B94
#define GL_STENCIL_FUNC 0x0B92
#define GL_STENCIL_INDEX 0x1901
#define GL_STENCIL_PASS_DEPTH_FAIL 0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS 0x0B96
#define GL_STENCIL_REF 0x0B97
#define GL_STENCIL_TEST 0x0B90
#define GL_STENCIL_VALUE_MASK 0x0B93
#define GL_STENCIL_WRITEMASK 0x0B98
#define GL_STEREO 0x0C33
#define GL_SUBPIXEL_BITS 0x0D50
#define GL_TEXTURE 0x1702
#define GL_TEXTURE_1D 0x0DE0
#define GL_TEXTURE_2D 0x0DE1
#define GL_TEXTURE_ALPHA_SIZE 0x805F
#define GL_TEXTURE_BINDING_1D 0x8068
#define GL_TEXTURE_BINDING_2D 0x8069
#define GL_TEXTURE_BLUE_SIZE 0x805E
#define GL_TEXTURE_BORDER_COLOR 0x1004
#define GL_TEXTURE_GREEN_SIZE 0x805D
#define GL_TEXTURE_HEIGHT 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT 0x1003
#define GL_TEXTURE_MAG_FILTER 0x2800
#define GL_TEXTURE_MIN_FILTER 0x2801
#define GL_TEXTURE_RED_SIZE 0x805C
#define GL_TEXTURE_WIDTH 0x1000
#define GL_TEXTURE_WRAP_S 0x2802
#define GL_TEXTURE_WRAP_T 0x2803
#define GL_TRIANGLES 0x0004
#define GL_TRIANGLE_FAN 0x0006
#define GL_TRIANGLE_STRIP 0x0005
#define GL_TRUE 1
#define GL_UNPACK_ALIGNMENT 0x0CF5
#define GL_UNPACK_LSB_FIRST 0x0CF1
#define GL_UNPACK_ROW_LENGTH 0x0CF2
#define GL_UNPACK_SKIP_PIXELS 0x0CF4
#define GL_UNPACK_SKIP_ROWS 0x0CF3
#define GL_UNPACK_SWAP_BYTES 0x0CF0
#define GL_UNSIGNED_BYTE 0x1401
#define GL_UNSIGNED_INT 0x1405
#define GL_UNSIGNED_SHORT 0x1403
#define GL_VENDOR 0x1F00
#define GL_VERSION 0x1F02
#define GL_VIEWPORT 0x0BA2
#define GL_XOR 0x1506
#define GL_ZERO 0

#define GL_ALIASED_LINE_WIDTH_RANGE 0x846E
#define GL_BGR 0x80E0
#define GL_BGRA 0x80E1
#define GL_CLAMP_TO_EDGE 0x812F
#define GL_MAX_3D_TEXTURE_SIZE 0x8073
#define GL_MAX_ELEMENTS_INDICES 0x80E9
#define GL_MAX_ELEMENTS_VERTICES 0x80E8
#define GL_PACK_IMAGE_HEIGHT 0x806C
#define GL_PACK_SKIP_IMAGES 0x806B
#define GL_PROXY_TEXTURE_3D 0x8070
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY 0x0B23
#define GL_SMOOTH_LINE_WIDTH_RANGE 0x0B22
#define GL_SMOOTH_POINT_SIZE_GRANULARITY 0x0B13
#define GL_SMOOTH_POINT_SIZE_RANGE 0x0B12
#define GL_TEXTURE_3D 0x806F
#define GL_TEXTURE_BASE_LEVEL 0x813C
#define GL_TEXTURE_BINDING_3D 0x806A
#define GL_TEXTURE_DEPTH 0x8071
#define GL_TEXTURE_MAX_LEVEL 0x813D
#define GL_TEXTURE_MAX_LOD 0x813B
#define GL_TEXTURE_MIN_LOD 0x813A
#define GL_TEXTURE_WRAP_R 0x8072
#define GL_UNPACK_IMAGE_HEIGHT 0x806E
#define GL_UNPACK_SKIP_IMAGES 0x806D
#define GL_UNSIGNED_BYTE_2_3_3_REV 0x8362
#define GL_UNSIGNED_BYTE_3_3_2 0x8032
#define GL_UNSIGNED_INT_10_10_10_2 0x8036
#define GL_UNSIGNED_INT_2_10_10_10_REV 0x8368
#define GL_UNSIGNED_INT_8_8_8_8 0x8035
#define GL_UNSIGNED_INT_8_8_8_8_REV 0x8367
#define GL_UNSIGNED_SHORT_1_5_5_5_REV 0x8366
#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
#define GL_UNSIGNED_SHORT_4_4_4_4_REV 0x8365
#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
#define GL_UNSIGNED_SHORT_5_6_5 0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV 0x8364

#define GL_ACTIVE_TEXTURE 0x84E0
#define GL_CLAMP_TO_BORDER 0x812D
#define GL_COMPRESSED_RGB 0x84ED
#define GL_COMPRESSED_RGBA 0x84EE
#define GL_COMPRESSED_TEXTURE_FORMATS 0x86A3
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE 0x851C
#define GL_MULTISAMPLE 0x809D
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_PROXY_TEXTURE_CUBE_MAP 0x851B
#define GL_SAMPLES 0x80A9
#define GL_SAMPLE_ALPHA_TO_COVERAGE 0x809E
#define GL_SAMPLE_ALPHA_TO_ONE 0x809F
#define GL_SAMPLE_BUFFERS 0x80A8
#define GL_SAMPLE_COVERAGE 0x80A0
#define GL_SAMPLE_COVERAGE_INVERT 0x80AB
#define GL_SAMPLE_COVERAGE_VALUE 0x80AA
#define GL_TEXTURE0 0x84C0
#define GL_TEXTURE1 0x84C1
#define GL_TEXTURE10 0x84CA
#define GL_TEXTURE11 0x84CB
#define GL_TEXTURE12 0x84CC
#define GL_TEXTURE13 0x84CD
#define GL_TEXTURE14 0x84CE
#define GL_TEXTURE15 0x84CF
#define GL_TEXTURE16 0x84D0
#define GL_TEXTURE17 0x84D1
#define GL_TEXTURE18 0x84D2
#define GL_TEXTURE19 0x84D3
#define GL_TEXTURE2 0x84C2
#define GL_TEXTURE20 0x84D4
#define GL_TEXTURE21 0x84D5
#define GL_TEXTURE22 0x84D6
#define GL_TEXTURE23 0x84D7
#define GL_TEXTURE24 0x84D8
#define GL_TEXTURE25 0x84D9
#define GL_TEXTURE26 0x84DA
#define GL_TEXTURE27 0x84DB
#define GL_TEXTURE28 0x84DC
#define GL_TEXTURE29 0x84DD
#define GL_TEXTURE3 0x84C3
#define GL_TEXTURE30 0x84DE
#define GL_TEXTURE31 0x84DF
#define GL_TEXTURE4 0x84C4
#define GL_TEXTURE5 0x84C5
#define GL_TEXTURE6 0x84C6
#define GL_TEXTURE7 0x84C7
#define GL_TEXTURE8 0x84C8
#define GL_TEXTURE9 0x84C9
#define GL_TEXTURE_BINDING_CUBE_MAP 0x8514
#define GL_TEXTURE_COMPRESSED 0x86A1
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE 0x86A0
#define GL_TEXTURE_COMPRESSION_HINT 0x84EF
#define GL_TEXTURE_CUBE_MAP 0x8513
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X 0x8516
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y 0x8518
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z 0x851A
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X 0x8515
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y 0x8517
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z 0x8519

#define GL_BLEND_COLOR 0x8005
#define GL_BLEND_DST_ALPHA 0x80CA
#define GL_BLEND_DST_RGB 0x80C8
#define GL_BLEND_EQUATION 0x8009
#define GL_BLEND_SRC_ALPHA 0x80CB
#define GL_BLEND_SRC_RGB 0x80C9
#define GL_CONSTANT_ALPHA 0x8003
#define GL_CONSTANT_COLOR 0x8001
#define GL_DECR_WRAP 0x8508
#define GL_DEPTH_COMPONENT16 0x81A5
#define GL_DEPTH_COMPONENT24 0x81A6
#define GL_DEPTH_COMPONENT32 0x81A7
#define GL_FUNC_ADD 0x8006
#define GL_FUNC_REVERSE_SUBTRACT 0x800B
#define GL_FUNC_SUBTRACT 0x800A
#define GL_INCR_WRAP 0x8507
#define GL_MAX 0x8008
#define GL_MAX_TEXTURE_LOD_BIAS 0x84FD
#define GL_MIN 0x8007
#define GL_MIRRORED_REPEAT 0x8370
#define GL_ONE_MINUS_CONSTANT_ALPHA 0x8004
#define GL_ONE_MINUS_CONSTANT_COLOR 0x8002
#define GL_POINT_FADE_THRESHOLD_SIZE 0x8128
#define GL_TEXTURE_COMPARE_FUNC 0x884D
#define GL_TEXTURE_COMPARE_MODE 0x884C
#define GL_TEXTURE_DEPTH_SIZE 0x884A
#define GL_TEXTURE_LOD_BIAS 0x8501

#define GL_ARRAY_BUFFER 0x8892
#define GL_ARRAY_BUFFER_BINDING 0x8894
#define GL_BUFFER_ACCESS 0x88BB
#define GL_BUFFER_MAPPED 0x88BC
#define GL_BUFFER_MAP_POINTER 0x88BD
#define GL_BUFFER_SIZE 0x8764
#define GL_BUFFER_USAGE 0x8765
#define GL_CURRENT_QUERY 0x8865
#define GL_DYNAMIC_COPY 0x88EA
#define GL_DYNAMIC_DRAW 0x88E8
#define GL_DYNAMIC_READ 0x88E9
#define GL_ELEMENT_ARRAY_BUFFER 0x8893
#define GL_ELEMENT_ARRAY_BUFFER_BINDING 0x8895
#define GL_QUERY_COUNTER_BITS 0x8864
#define GL_QUERY_RESULT 0x8866
#define GL_QUERY_RESULT_AVAILABLE 0x8867
#define GL_READ_ONLY 0x88B8
#define GL_READ_WRITE 0x88BA
#define GL_SAMPLES_PASSED 0x8914
#define GL_SRC1_ALPHA 0x8589
#define GL_STATIC_COPY 0x88E6
#define GL_STATIC_DRAW 0x88E4
#define GL_STATIC_READ 0x88E5
#define GL_STREAM_COPY 0x88E2
#define GL_STREAM_DRAW 0x88E0
#define GL_STREAM_READ 0x88E1
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_WRITE_ONLY 0x88B9

#define GL_ACTIVE_ATTRIBUTES 0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH 0x8B8A
#define GL_ACTIVE_UNIFORMS 0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH 0x8B87
#define GL_ATTACHED_SHADERS 0x8B85
#define GL_BLEND_EQUATION_ALPHA 0x883D
#define GL_BLEND_EQUATION_RGB 0x8009
#define GL_BOOL 0x8B56
#define GL_BOOL_VEC2 0x8B57
#define GL_BOOL_VEC3 0x8B58
#define GL_BOOL_VEC4 0x8B59
#define GL_COMPILE_STATUS 0x8B81
#define GL_CURRENT_PROGRAM 0x8B8D
#define GL_CURRENT_VERTEX_ATTRIB 0x8626
#define GL_DELETE_STATUS 0x8B80
#define GL_DRAW_BUFFER0 0x8825
#define GL_DRAW_BUFFER1 0x8826
#define GL_DRAW_BUFFER10 0x882F
#define GL_DRAW_BUFFER11 0x8830
#define GL_DRAW_BUFFER12 0x8831
#define GL_DRAW_BUFFER13 0x8832
#define GL_DRAW_BUFFER14 0x8833
#define GL_DRAW_BUFFER15 0x8834
#define GL_DRAW_BUFFER2 0x8827
#define GL_DRAW_BUFFER3 0x8828
#define GL_DRAW_BUFFER4 0x8829
#define GL_DRAW_BUFFER5 0x882A
#define GL_DRAW_BUFFER6 0x882B
#define GL_DRAW_BUFFER7 0x882C
#define GL_DRAW_BUFFER8 0x882D
#define GL_DRAW_BUFFER9 0x882E
#define GL_FLOAT_MAT2 0x8B5A
#define GL_FLOAT_MAT3 0x8B5B
#define GL_FLOAT_MAT4 0x8B5C
#define GL_FLOAT_VEC2 0x8B50
#define GL_FLOAT_VEC3 0x8B51
#define GL_FLOAT_VEC4 0x8B52
#define GL_FRAGMENT_SHADER 0x8B30
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_INFO_LOG_LENGTH 0x8B84
#define GL_INT_VEC2 0x8B53
#define GL_INT_VEC3 0x8B54
#define GL_INT_VEC4 0x8B55
#define GL_LINK_STATUS 0x8B82
#define GL_LOWER_LEFT 0x8CA1
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_MAX_DRAW_BUFFERS 0x8824
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_TEXTURE_IMAGE_UNITS 0x8872
#define GL_MAX_VARYING_FLOATS 0x8B4B
#define GL_MAX_VERTEX_ATTRIBS 0x8869
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS 0x8B4A
#define GL_POINT_SPRITE_COORD_ORIGIN 0x8CA0
#define GL_SAMPLER_1D 0x8B5D
#define GL_SAMPLER_1D_SHADOW 0x8B61
#define GL_SAMPLER_2D 0x8B5E
#define GL_SAMPLER_2D_SHADOW 0x8B62
#define GL_SAMPLER_3D 0x8B5F
#define GL_SAMPLER_CUBE 0x8B60
#define GL_SHADER_SOURCE_LENGTH 0x8B88
#define GL_SHADER_TYPE 0x8B4F
#define GL_SHADING_LANGUAGE_VERSION 0x8B8C
#define GL_STENCIL_BACK_FAIL 0x8801
#define GL_STENCIL_BACK_FUNC 0x8800
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL 0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS 0x8803
#define GL_STENCIL_BACK_REF 0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK 0x8CA4
#define GL_STENCIL_BACK_WRITEMASK 0x8CA5
#define GL_UPPER_LEFT 0x8CA2
#define GL_VALIDATE_STATUS 0x8B83
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED 0x8622
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_VERTEX_ATTRIB_ARRAY_POINTER 0x8645
#define GL_VERTEX_ATTRIB_ARRAY_SIZE 0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE 0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE 0x8625
#define GL_VERTEX_PROGRAM_POINT_SIZE 0x8642
#define GL_VERTEX_SHADER 0x8B31

#define GL_COMPRESSED_SRGB 0x8C48
#define GL_COMPRESSED_SRGB_ALPHA 0x8C49
#define GL_FLOAT_MAT2x3 0x8B65
#define GL_FLOAT_MAT2x4 0x8B66
#define GL_FLOAT_MAT3x2 0x8B67
#define GL_FLOAT_MAT3x4 0x8B68
#define GL_FLOAT_MAT4x2 0x8B69
#define GL_FLOAT_MAT4x3 0x8B6A
#define GL_PIXEL_PACK_BUFFER 0x88EB
#define GL_PIXEL_PACK_BUFFER_BINDING 0x88ED
#define GL_PIXEL_UNPACK_BUFFER 0x88EC
#define GL_PIXEL_UNPACK_BUFFER_BINDING 0x88EF
#define GL_SRGB 0x8C40
#define GL_SRGB8 0x8C41
#define GL_SRGB8_ALPHA8 0x8C43
#define GL_SRGB_ALPHA 0x8C42

#define GL_BGRA_INTEGER 0x8D9B
#define GL_BGR_INTEGER 0x8D9A
#define GL_BLUE_INTEGER 0x8D96
#define GL_BUFFER_ACCESS_FLAGS 0x911F
#define GL_BUFFER_MAP_LENGTH 0x9120
#define GL_BUFFER_MAP_OFFSET 0x9121
#define GL_CLAMP_READ_COLOR 0x891C
#define GL_CLIP_DISTANCE0 0x3000
#define GL_CLIP_DISTANCE1 0x3001
#define GL_CLIP_DISTANCE2 0x3002
#define GL_CLIP_DISTANCE3 0x3003
#define GL_CLIP_DISTANCE4 0x3004
#define GL_CLIP_DISTANCE5 0x3005
#define GL_CLIP_DISTANCE6 0x3006
#define GL_CLIP_DISTANCE7 0x3007
#define GL_COLOR_ATTACHMENT0 0x8CE0
#define GL_COLOR_ATTACHMENT1 0x8CE1
#define GL_COLOR_ATTACHMENT10 0x8CEA
#define GL_COLOR_ATTACHMENT11 0x8CEB
#define GL_COLOR_ATTACHMENT12 0x8CEC
#define GL_COLOR_ATTACHMENT13 0x8CED
#define GL_COLOR_ATTACHMENT14 0x8CEE
#define GL_COLOR_ATTACHMENT15 0x8CEF
#define GL_COLOR_ATTACHMENT2 0x8CE2
#define GL_COLOR_ATTACHMENT3 0x8CE3
#define GL_COLOR_ATTACHMENT4 0x8CE4
#define GL_COLOR_ATTACHMENT5 0x8CE5
#define GL_COLOR_ATTACHMENT6 0x8CE6
#define GL_COLOR_ATTACHMENT7 0x8CE7
#define GL_COLOR_ATTACHMENT8 0x8CE8
#define GL_COLOR_ATTACHMENT9 0x8CE9
#define GL_COMPARE_REF_TO_TEXTURE 0x884E
#define GL_COMPRESSED_RED 0x8225
#define GL_COMPRESSED_RED_RGTC1 0x8DBB
#define GL_COMPRESSED_RG 0x8226
#define GL_COMPRESSED_RG_RGTC2 0x8DBD
#define GL_COMPRESSED_SIGNED_RED_RGTC1 0x8DBC
#define GL_COMPRESSED_SIGNED_RG_RGTC2 0x8DBE
#define GL_CONTEXT_FLAGS 0x821E
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x00000001
#define GL_DEPTH24_STENCIL8 0x88F0
#define GL_DEPTH32F_STENCIL8 0x8CAD
#define GL_DEPTH_ATTACHMENT 0x8D00
#define GL_DEPTH_COMPONENT32F 0x8CAC
#define GL_DEPTH_STENCIL 0x84F9
#define GL_DEPTH_STENCIL_ATTACHMENT 0x821A
#define GL_DRAW_FRAMEBUFFER 0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING 0x8CA6
#define GL_FIXED_ONLY 0x891D
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#define GL_FRAMEBUFFER 0x8D40
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_BINDING 0x8CA6
#define GL_FRAMEBUFFER_COMPLETE 0x8CD5
#define GL_FRAMEBUFFER_DEFAULT 0x8218
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
/*Copied GL_FRAMEBUFFER_SRGB From: ARB_framebuffer_sRGB*/
#define GL_FRAMEBUFFER_UNDEFINED 0x8219
#define GL_FRAMEBUFFER_UNSUPPORTED 0x8CDD
#define GL_GREEN_INTEGER 0x8D95
#define GL_HALF_FLOAT 0x140B
#define GL_INTERLEAVED_ATTRIBS 0x8C8C
#define GL_INT_SAMPLER_1D 0x8DC9
#define GL_INT_SAMPLER_1D_ARRAY 0x8DCE
#define GL_INT_SAMPLER_2D 0x8DCA
#define GL_INT_SAMPLER_2D_ARRAY 0x8DCF
#define GL_INT_SAMPLER_3D 0x8DCB
#define GL_INT_SAMPLER_CUBE 0x8DCC
#define GL_INVALID_FRAMEBUFFER_OPERATION 0x0506
#define GL_MAJOR_VERSION 0x821B
#define GL_MAP_FLUSH_EXPLICIT_BIT 0x0010
#define GL_MAP_INVALIDATE_BUFFER_BIT 0x0008
#define GL_MAP_INVALIDATE_RANGE_BIT 0x0004
#define GL_MAP_READ_BIT 0x0001
#define GL_MAP_UNSYNCHRONIZED_BIT 0x0020
#define GL_MAP_WRITE_BIT 0x0002
#define GL_MAX_ARRAY_TEXTURE_LAYERS 0x88FF
#define GL_MAX_CLIP_DISTANCES 0x0D32
#define GL_MAX_COLOR_ATTACHMENTS 0x8CDF
#define GL_MAX_PROGRAM_TEXEL_OFFSET 0x8905
#define GL_MAX_RENDERBUFFER_SIZE 0x84E8
#define GL_MAX_SAMPLES 0x8D57
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_MAX_VARYING_COMPONENTS 0x8B4B
#define GL_MINOR_VERSION 0x821C
#define GL_MIN_PROGRAM_TEXEL_OFFSET 0x8904
#define GL_NUM_EXTENSIONS 0x821D
#define GL_PRIMITIVES_GENERATED 0x8C87
#define GL_PROXY_TEXTURE_1D_ARRAY 0x8C19
#define GL_PROXY_TEXTURE_2D_ARRAY 0x8C1B
#define GL_QUERY_BY_REGION_NO_WAIT 0x8E16
#define GL_QUERY_BY_REGION_WAIT 0x8E15
#define GL_QUERY_NO_WAIT 0x8E14
#define GL_QUERY_WAIT 0x8E13
#define GL_R11F_G11F_B10F 0x8C3A
#define GL_R16 0x822A
#define GL_R16F 0x822D
#define GL_R16I 0x8233
#define GL_R16UI 0x8234
#define GL_R32F 0x822E
#define GL_R32I 0x8235
#define GL_R32UI 0x8236
#define GL_R8 0x8229
#define GL_R8I 0x8231
#define GL_R8UI 0x8232
#define GL_RASTERIZER_DISCARD 0x8C89
#define GL_READ_FRAMEBUFFER 0x8CA8
#define GL_READ_FRAMEBUFFER_BINDING 0x8CAA
#define GL_RED_INTEGER 0x8D94
#define GL_RENDERBUFFER 0x8D41
#define GL_RENDERBUFFER_ALPHA_SIZE 0x8D53
#define GL_RENDERBUFFER_BINDING 0x8CA7
#define GL_RENDERBUFFER_BLUE_SIZE 0x8D52
#define GL_RENDERBUFFER_DEPTH_SIZE 0x8D54
#define GL_RENDERBUFFER_GREEN_SIZE 0x8D51
#define GL_RENDERBUFFER_HEIGHT 0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT 0x8D44
#define GL_RENDERBUFFER_RED_SIZE 0x8D50
#define GL_RENDERBUFFER_SAMPLES 0x8CAB
#define GL_RENDERBUFFER_STENCIL_SIZE 0x8D55
#define GL_RENDERBUFFER_WIDTH 0x8D42
#define GL_RG 0x8227
#define GL_RG16 0x822C
#define GL_RG16F 0x822F
#define GL_RG16I 0x8239
#define GL_RG16UI 0x823A
#define GL_RG32F 0x8230
#define GL_RG32I 0x823B
#define GL_RG32UI 0x823C
#define GL_RG8 0x822B
#define GL_RG8I 0x8237
#define GL_RG8UI 0x8238
#define GL_RGB16F 0x881B
#define GL_RGB16I 0x8D89
#define GL_RGB16UI 0x8D77
#define GL_RGB32F 0x8815
#define GL_RGB32I 0x8D83
#define GL_RGB32UI 0x8D71
#define GL_RGB8I 0x8D8F
#define GL_RGB8UI 0x8D7D
#define GL_RGB9_E5 0x8C3D
#define GL_RGBA16F 0x881A
#define GL_RGBA16I 0x8D88
#define GL_RGBA16UI 0x8D76
#define GL_RGBA32F 0x8814
#define GL_RGBA32I 0x8D82
#define GL_RGBA32UI 0x8D70
#define GL_RGBA8I 0x8D8E
#define GL_RGBA8UI 0x8D7C
#define GL_RGBA_INTEGER 0x8D99
#define GL_RGB_INTEGER 0x8D98
#define GL_RG_INTEGER 0x8228
#define GL_SAMPLER_1D_ARRAY 0x8DC0
#define GL_SAMPLER_1D_ARRAY_SHADOW 0x8DC3
#define GL_SAMPLER_2D_ARRAY 0x8DC1
#define GL_SAMPLER_2D_ARRAY_SHADOW 0x8DC4
#define GL_SAMPLER_CUBE_SHADOW 0x8DC5
#define GL_SEPARATE_ATTRIBS 0x8C8D
#define GL_STENCIL_ATTACHMENT 0x8D20
#define GL_STENCIL_INDEX1 0x8D46
#define GL_STENCIL_INDEX16 0x8D49
#define GL_STENCIL_INDEX4 0x8D47
#define GL_STENCIL_INDEX8 0x8D48
#define GL_TEXTURE_1D_ARRAY 0x8C18
#define GL_TEXTURE_2D_ARRAY 0x8C1A
#define GL_TEXTURE_ALPHA_TYPE 0x8C13
#define GL_TEXTURE_BINDING_1D_ARRAY 0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY 0x8C1D
#define GL_TEXTURE_BLUE_TYPE 0x8C12
#define GL_TEXTURE_DEPTH_TYPE 0x8C16
#define GL_TEXTURE_GREEN_TYPE 0x8C11
#define GL_TEXTURE_RED_TYPE 0x8C10
#define GL_TEXTURE_SHARED_SIZE 0x8C3F
#define GL_TEXTURE_STENCIL_SIZE 0x88F1
#define GL_TRANSFORM_FEEDBACK_BUFFER 0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_TRANSFORM_FEEDBACK_VARYINGS 0x8C83
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_UNSIGNED_INT_10F_11F_11F_REV 0x8C3B
#define GL_UNSIGNED_INT_24_8 0x84FA
#define GL_UNSIGNED_INT_5_9_9_9_REV 0x8C3E
#define GL_UNSIGNED_INT_SAMPLER_1D 0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D 0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_3D 0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE 0x8DD4
#define GL_UNSIGNED_INT_VEC2 0x8DC6
#define GL_UNSIGNED_INT_VEC3 0x8DC7
#define GL_UNSIGNED_INT_VEC4 0x8DC8
#define GL_UNSIGNED_NORMALIZED 0x8C17
#define GL_VERTEX_ARRAY_BINDING 0x85B5
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER 0x88FD

#define GL_ACTIVE_UNIFORM_BLOCKS 0x8A36
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_COPY_READ_BUFFER 0x8F36
#define GL_COPY_WRITE_BUFFER 0x8F37
#define GL_INT_SAMPLER_2D_RECT 0x8DCD
#define GL_INT_SAMPLER_BUFFER 0x8DD0
#define GL_INVALID_INDEX 0xFFFFFFFF
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_MAX_COMBINED_UNIFORM_BLOCKS 0x8A2E
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS 0x8A2D
#define GL_MAX_RECTANGLE_TEXTURE_SIZE 0x84F8
#define GL_MAX_TEXTURE_BUFFER_SIZE 0x8C2B
#define GL_MAX_UNIFORM_BLOCK_SIZE 0x8A30
#define GL_MAX_UNIFORM_BUFFER_BINDINGS 0x8A2F
#define GL_MAX_VERTEX_UNIFORM_BLOCKS 0x8A2B
#define GL_PRIMITIVE_RESTART 0x8F9D
#define GL_PRIMITIVE_RESTART_INDEX 0x8F9E
#define GL_PROXY_TEXTURE_RECTANGLE 0x84F7
#define GL_R16_SNORM 0x8F98
#define GL_R8_SNORM 0x8F94
#define GL_RG16_SNORM 0x8F99
#define GL_RG8_SNORM 0x8F95
#define GL_RGB16_SNORM 0x8F9A
#define GL_RGB8_SNORM 0x8F96
#define GL_RGBA16_SNORM 0x8F9B
#define GL_RGBA8_SNORM 0x8F97
#define GL_SAMPLER_2D_RECT 0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW 0x8B64
#define GL_SAMPLER_BUFFER 0x8DC2
#define GL_SIGNED_NORMALIZED 0x8F9C
#define GL_TEXTURE_BINDING_BUFFER 0x8C2C
#define GL_TEXTURE_BINDING_RECTANGLE 0x84F6
#define GL_TEXTURE_BUFFER 0x8C2A
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_RECTANGLE 0x84F5
#define GL_UNIFORM_ARRAY_STRIDE 0x8A3C
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS 0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_BINDING 0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE 0x8A40
#define GL_UNIFORM_BLOCK_INDEX 0x8A3A
#define GL_UNIFORM_BLOCK_NAME_LENGTH 0x8A41
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BUFFER 0x8A11
#define GL_UNIFORM_BUFFER_BINDING 0x8A28
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_UNIFORM_BUFFER_SIZE 0x8A2A
#define GL_UNIFORM_BUFFER_START 0x8A29
#define GL_UNIFORM_IS_ROW_MAJOR 0x8A3E
#define GL_UNIFORM_MATRIX_STRIDE 0x8A3D
#define GL_UNIFORM_NAME_LENGTH 0x8A39
#define GL_UNIFORM_OFFSET 0x8A3B
#define GL_UNIFORM_SIZE 0x8A38
#define GL_UNIFORM_TYPE 0x8A37
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT 0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_BUFFER 0x8DD8

#define GL_ALREADY_SIGNALED 0x911A
#define GL_CONDITION_SATISFIED 0x911C
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_CONTEXT_CORE_PROFILE_BIT 0x00000001
#define GL_CONTEXT_PROFILE_MASK 0x9126
#define GL_DEPTH_CLAMP 0x864F
#define GL_FIRST_VERTEX_CONVENTION 0x8E4D
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_GEOMETRY_INPUT_TYPE 0x8917
#define GL_GEOMETRY_OUTPUT_TYPE 0x8918
#define GL_GEOMETRY_SHADER 0x8DD9
#define GL_GEOMETRY_VERTICES_OUT 0x8916
#define GL_INT_SAMPLER_2D_MULTISAMPLE 0x9109
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_LAST_VERTEX_CONVENTION 0x8E4E
#define GL_LINES_ADJACENCY 0x000A
#define GL_LINE_STRIP_ADJACENCY 0x000B
#define GL_MAX_COLOR_TEXTURE_SAMPLES 0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES 0x910F
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS 0x9125
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS 0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES 0x8DE0
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_INTEGER_SAMPLES 0x9110
#define GL_MAX_SAMPLE_MASK_WORDS 0x8E59
#define GL_MAX_SERVER_WAIT_TIMEOUT 0x9111
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS 0x9122
#define GL_OBJECT_TYPE 0x9112
#define GL_PROGRAM_POINT_SIZE 0x8642
#define GL_PROVOKING_VERTEX 0x8E4F
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE 0x9101
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION 0x8E4C
#define GL_SAMPLER_2D_MULTISAMPLE 0x9108
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910B
#define GL_SAMPLE_MASK 0x8E51
#define GL_SAMPLE_MASK_VALUE 0x8E52
#define GL_SAMPLE_POSITION 0x8E50
#define GL_SIGNALED 0x9119
#define GL_SYNC_CONDITION 0x9113
#define GL_SYNC_FENCE 0x9116
#define GL_SYNC_FLAGS 0x9115
#define GL_SYNC_FLUSH_COMMANDS_BIT 0x00000001
#define GL_SYNC_GPU_COMMANDS_COMPLETE 0x9117
#define GL_SYNC_STATUS 0x9114
#define GL_TEXTURE_2D_MULTISAMPLE 0x9100
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9102
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_CUBE_MAP_SEAMLESS 0x884F
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_TEXTURE_SAMPLES 0x9106
#define GL_TIMEOUT_EXPIRED 0x911B
#define GL_TIMEOUT_IGNORED 0xFFFFFFFFFFFFFFFF
#define GL_TRIANGLES_ADJACENCY 0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY 0x000D
#define GL_UNSIGNALED 0x9118
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_WAIT_FAILED 0x911D

#define GL_ANY_SAMPLES_PASSED 0x8C2F
#define GL_INT_2_10_10_10_REV 0x8D9F
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS 0x88FC
#define GL_ONE_MINUS_SRC1_ALPHA 0x88FB
#define GL_ONE_MINUS_SRC1_COLOR 0x88FA
#define GL_RGB10_A2UI 0x906F
#define GL_SAMPLER_BINDING 0x8919
#define GL_SRC1_COLOR 0x88F9
#define GL_TEXTURE_SWIZZLE_A 0x8E45
#define GL_TEXTURE_SWIZZLE_B 0x8E44
#define GL_TEXTURE_SWIZZLE_G 0x8E43
#define GL_TEXTURE_SWIZZLE_R 0x8E42
#define GL_TEXTURE_SWIZZLE_RGBA 0x8E46
#define GL_TIMESTAMP 0x8E28
#define GL_TIME_ELAPSED 0x88BF
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR 0x88FE



extern void (CODEGEN_FUNCPTR *_ptrc_glBlendFunc)(GLenum, GLenum);
#define glBlendFunc _ptrc_glBlendFunc
extern void (CODEGEN_FUNCPTR *_ptrc_glClear)(GLbitfield);
#define glClear _ptrc_glClear
extern void (CODEGEN_FUNCPTR *_ptrc_glClearColor)(GLfloat, GLfloat, GLfloat, GLfloat);
#define glClearColor _ptrc_glClearColor
extern void (CODEGEN_FUNCPTR *_ptrc_glClearDepth)(GLdouble);
#define glClearDepth _ptrc_glClearDepth
extern void (CODEGEN_FUNCPTR *_ptrc_glClearStencil)(GLint);
#define glClearStencil _ptrc_glClearStencil
extern void (CODEGEN_FUNCPTR *_ptrc_glColorMask)(GLboolean, GLboolean, GLboolean, GLboolean);
#define glColorMask _ptrc_glColorMask
extern void (CODEGEN_FUNCPTR *_ptrc_glCullFace)(GLenum);
#define glCullFace _ptrc_glCullFace
extern void (CODEGEN_FUNCPTR *_ptrc_glDepthFunc)(GLenum);
#define glDepthFunc _ptrc_glDepthFunc
extern void (CODEGEN_FUNCPTR *_ptrc_glDepthMask)(GLboolean);
#define glDepthMask _ptrc_glDepthMask
extern void (CODEGEN_FUNCPTR *_ptrc_glDepthRange)(GLdouble, GLdouble);
#define glDepthRange _ptrc_glDepthRange
extern void (CODEGEN_FUNCPTR *_ptrc_glDisable)(GLenum);
#define glDisable _ptrc_glDisable
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawBuffer)(GLenum);
#define glDrawBuffer _ptrc_glDrawBuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glEnable)(GLenum);
#define glEnable _ptrc_glEnable
extern void (CODEGEN_FUNCPTR *_ptrc_glFinish)();
#define glFinish _ptrc_glFinish
extern void (CODEGEN_FUNCPTR *_ptrc_glFlush)();
#define glFlush _ptrc_glFlush
extern void (CODEGEN_FUNCPTR *_ptrc_glFrontFace)(GLenum);
#define glFrontFace _ptrc_glFrontFace
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBooleanv)(GLenum, GLboolean *);
#define glGetBooleanv _ptrc_glGetBooleanv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetDoublev)(GLenum, GLdouble *);
#define glGetDoublev _ptrc_glGetDoublev
extern GLenum (CODEGEN_FUNCPTR *_ptrc_glGetError)();
#define glGetError _ptrc_glGetError
extern void (CODEGEN_FUNCPTR *_ptrc_glGetFloatv)(GLenum, GLfloat *);
#define glGetFloatv _ptrc_glGetFloatv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetIntegerv)(GLenum, GLint *);
#define glGetIntegerv _ptrc_glGetIntegerv
extern const GLubyte * (CODEGEN_FUNCPTR *_ptrc_glGetString)(GLenum);
#define glGetString _ptrc_glGetString
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexImage)(GLenum, GLint, GLenum, GLenum, GLvoid *);
#define glGetTexImage _ptrc_glGetTexImage
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexLevelParameterfv)(GLenum, GLint, GLenum, GLfloat *);
#define glGetTexLevelParameterfv _ptrc_glGetTexLevelParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexLevelParameteriv)(GLenum, GLint, GLenum, GLint *);
#define glGetTexLevelParameteriv _ptrc_glGetTexLevelParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterfv)(GLenum, GLenum, GLfloat *);
#define glGetTexParameterfv _ptrc_glGetTexParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameteriv)(GLenum, GLenum, GLint *);
#define glGetTexParameteriv _ptrc_glGetTexParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glHint)(GLenum, GLenum);
#define glHint _ptrc_glHint
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsEnabled)(GLenum);
#define glIsEnabled _ptrc_glIsEnabled
extern void (CODEGEN_FUNCPTR *_ptrc_glLineWidth)(GLfloat);
#define glLineWidth _ptrc_glLineWidth
extern void (CODEGEN_FUNCPTR *_ptrc_glLogicOp)(GLenum);
#define glLogicOp _ptrc_glLogicOp
extern void (CODEGEN_FUNCPTR *_ptrc_glPixelStoref)(GLenum, GLfloat);
#define glPixelStoref _ptrc_glPixelStoref
extern void (CODEGEN_FUNCPTR *_ptrc_glPixelStorei)(GLenum, GLint);
#define glPixelStorei _ptrc_glPixelStorei
extern void (CODEGEN_FUNCPTR *_ptrc_glPointSize)(GLfloat);
#define glPointSize _ptrc_glPointSize
extern void (CODEGEN_FUNCPTR *_ptrc_glPolygonMode)(GLenum, GLenum);
#define glPolygonMode _ptrc_glPolygonMode
extern void (CODEGEN_FUNCPTR *_ptrc_glReadBuffer)(GLenum);
#define glReadBuffer _ptrc_glReadBuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glReadPixels)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
#define glReadPixels _ptrc_glReadPixels
extern void (CODEGEN_FUNCPTR *_ptrc_glScissor)(GLint, GLint, GLsizei, GLsizei);
#define glScissor _ptrc_glScissor
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilFunc)(GLenum, GLint, GLuint);
#define glStencilFunc _ptrc_glStencilFunc
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilMask)(GLuint);
#define glStencilMask _ptrc_glStencilMask
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilOp)(GLenum, GLenum, GLenum);
#define glStencilOp _ptrc_glStencilOp
extern void (CODEGEN_FUNCPTR *_ptrc_glTexImage1D)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
#define glTexImage1D _ptrc_glTexImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glTexImage2D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
#define glTexImage2D _ptrc_glTexImage2D
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameterf)(GLenum, GLenum, GLfloat);
#define glTexParameterf _ptrc_glTexParameterf
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameterfv)(GLenum, GLenum, const GLfloat *);
#define glTexParameterfv _ptrc_glTexParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameteri)(GLenum, GLenum, GLint);
#define glTexParameteri _ptrc_glTexParameteri
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameteriv)(GLenum, GLenum, const GLint *);
#define glTexParameteriv _ptrc_glTexParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glViewport)(GLint, GLint, GLsizei, GLsizei);
#define glViewport _ptrc_glViewport

extern void (CODEGEN_FUNCPTR *_ptrc_glBindTexture)(GLenum, GLuint);
#define glBindTexture _ptrc_glBindTexture
extern void (CODEGEN_FUNCPTR *_ptrc_glCopyTexImage1D)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
#define glCopyTexImage1D _ptrc_glCopyTexImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glCopyTexImage2D)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
#define glCopyTexImage2D _ptrc_glCopyTexImage2D
extern void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage1D)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
#define glCopyTexSubImage1D _ptrc_glCopyTexSubImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage2D)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
#define glCopyTexSubImage2D _ptrc_glCopyTexSubImage2D
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteTextures)(GLsizei, const GLuint *);
#define glDeleteTextures _ptrc_glDeleteTextures
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawArrays)(GLenum, GLint, GLsizei);
#define glDrawArrays _ptrc_glDrawArrays
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawElements)(GLenum, GLsizei, GLenum, const GLvoid *);
#define glDrawElements _ptrc_glDrawElements
extern void (CODEGEN_FUNCPTR *_ptrc_glGenTextures)(GLsizei, GLuint *);
#define glGenTextures _ptrc_glGenTextures
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsTexture)(GLuint);
#define glIsTexture _ptrc_glIsTexture
extern void (CODEGEN_FUNCPTR *_ptrc_glPolygonOffset)(GLfloat, GLfloat);
#define glPolygonOffset _ptrc_glPolygonOffset
extern void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage1D)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
#define glTexSubImage1D _ptrc_glTexSubImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage2D)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#define glTexSubImage2D _ptrc_glTexSubImage2D

extern void (CODEGEN_FUNCPTR *_ptrc_glBlendColor)(GLfloat, GLfloat, GLfloat, GLfloat);
#define glBlendColor _ptrc_glBlendColor
extern void (CODEGEN_FUNCPTR *_ptrc_glBlendEquation)(GLenum);
#define glBlendEquation _ptrc_glBlendEquation
extern void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
#define glCopyTexSubImage3D _ptrc_glCopyTexSubImage3D
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawRangeElements)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
#define glDrawRangeElements _ptrc_glDrawRangeElements
extern void (CODEGEN_FUNCPTR *_ptrc_glTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
#define glTexImage3D _ptrc_glTexImage3D
extern void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#define glTexSubImage3D _ptrc_glTexSubImage3D

extern void (CODEGEN_FUNCPTR *_ptrc_glActiveTexture)(GLenum);
#define glActiveTexture _ptrc_glActiveTexture
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage1D)(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *);
#define glCompressedTexImage1D _ptrc_glCompressedTexImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage2D)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
#define glCompressedTexImage2D _ptrc_glCompressedTexImage2D
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage3D)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *);
#define glCompressedTexImage3D _ptrc_glCompressedTexImage3D
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage1D)(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *);
#define glCompressedTexSubImage1D _ptrc_glCompressedTexSubImage1D
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage2D)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
#define glCompressedTexSubImage2D _ptrc_glCompressedTexSubImage2D
extern void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *);
#define glCompressedTexSubImage3D _ptrc_glCompressedTexSubImage3D
extern void (CODEGEN_FUNCPTR *_ptrc_glGetCompressedTexImage)(GLenum, GLint, GLvoid *);
#define glGetCompressedTexImage _ptrc_glGetCompressedTexImage
extern void (CODEGEN_FUNCPTR *_ptrc_glSampleCoverage)(GLfloat, GLboolean);
#define glSampleCoverage _ptrc_glSampleCoverage

extern void (CODEGEN_FUNCPTR *_ptrc_glBlendFuncSeparate)(GLenum, GLenum, GLenum, GLenum);
#define glBlendFuncSeparate _ptrc_glBlendFuncSeparate
extern void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawArrays)(GLenum, const GLint *, const GLsizei *, GLsizei);
#define glMultiDrawArrays _ptrc_glMultiDrawArrays
extern void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawElements)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei);
#define glMultiDrawElements _ptrc_glMultiDrawElements
extern void (CODEGEN_FUNCPTR *_ptrc_glPointParameterf)(GLenum, GLfloat);
#define glPointParameterf _ptrc_glPointParameterf
extern void (CODEGEN_FUNCPTR *_ptrc_glPointParameterfv)(GLenum, const GLfloat *);
#define glPointParameterfv _ptrc_glPointParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glPointParameteri)(GLenum, GLint);
#define glPointParameteri _ptrc_glPointParameteri
extern void (CODEGEN_FUNCPTR *_ptrc_glPointParameteriv)(GLenum, const GLint *);
#define glPointParameteriv _ptrc_glPointParameteriv

extern void (CODEGEN_FUNCPTR *_ptrc_glBeginQuery)(GLenum, GLuint);
#define glBeginQuery _ptrc_glBeginQuery
extern void (CODEGEN_FUNCPTR *_ptrc_glBindBuffer)(GLenum, GLuint);
#define glBindBuffer _ptrc_glBindBuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glBufferData)(GLenum, GLsizeiptr, const GLvoid *, GLenum);
#define glBufferData _ptrc_glBufferData
extern void (CODEGEN_FUNCPTR *_ptrc_glBufferSubData)(GLenum, GLintptr, GLsizeiptr, const GLvoid *);
#define glBufferSubData _ptrc_glBufferSubData
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteBuffers)(GLsizei, const GLuint *);
#define glDeleteBuffers _ptrc_glDeleteBuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteQueries)(GLsizei, const GLuint *);
#define glDeleteQueries _ptrc_glDeleteQueries
extern void (CODEGEN_FUNCPTR *_ptrc_glEndQuery)(GLenum);
#define glEndQuery _ptrc_glEndQuery
extern void (CODEGEN_FUNCPTR *_ptrc_glGenBuffers)(GLsizei, GLuint *);
#define glGenBuffers _ptrc_glGenBuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glGenQueries)(GLsizei, GLuint *);
#define glGenQueries _ptrc_glGenQueries
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBufferParameteriv)(GLenum, GLenum, GLint *);
#define glGetBufferParameteriv _ptrc_glGetBufferParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBufferPointerv)(GLenum, GLenum, GLvoid **);
#define glGetBufferPointerv _ptrc_glGetBufferPointerv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBufferSubData)(GLenum, GLintptr, GLsizeiptr, GLvoid *);
#define glGetBufferSubData _ptrc_glGetBufferSubData
extern void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectiv)(GLuint, GLenum, GLint *);
#define glGetQueryObjectiv _ptrc_glGetQueryObjectiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectuiv)(GLuint, GLenum, GLuint *);
#define glGetQueryObjectuiv _ptrc_glGetQueryObjectuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetQueryiv)(GLenum, GLenum, GLint *);
#define glGetQueryiv _ptrc_glGetQueryiv
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsBuffer)(GLuint);
#define glIsBuffer _ptrc_glIsBuffer
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsQuery)(GLuint);
#define glIsQuery _ptrc_glIsQuery
extern void * (CODEGEN_FUNCPTR *_ptrc_glMapBuffer)(GLenum, GLenum);
#define glMapBuffer _ptrc_glMapBuffer
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glUnmapBuffer)(GLenum);
#define glUnmapBuffer _ptrc_glUnmapBuffer

extern void (CODEGEN_FUNCPTR *_ptrc_glAttachShader)(GLuint, GLuint);
#define glAttachShader _ptrc_glAttachShader
extern void (CODEGEN_FUNCPTR *_ptrc_glBindAttribLocation)(GLuint, GLuint, const GLchar *);
#define glBindAttribLocation _ptrc_glBindAttribLocation
extern void (CODEGEN_FUNCPTR *_ptrc_glBlendEquationSeparate)(GLenum, GLenum);
#define glBlendEquationSeparate _ptrc_glBlendEquationSeparate
extern void (CODEGEN_FUNCPTR *_ptrc_glCompileShader)(GLuint);
#define glCompileShader _ptrc_glCompileShader
extern GLuint (CODEGEN_FUNCPTR *_ptrc_glCreateProgram)();
#define glCreateProgram _ptrc_glCreateProgram
extern GLuint (CODEGEN_FUNCPTR *_ptrc_glCreateShader)(GLenum);
#define glCreateShader _ptrc_glCreateShader
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteProgram)(GLuint);
#define glDeleteProgram _ptrc_glDeleteProgram
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteShader)(GLuint);
#define glDeleteShader _ptrc_glDeleteShader
extern void (CODEGEN_FUNCPTR *_ptrc_glDetachShader)(GLuint, GLuint);
#define glDetachShader _ptrc_glDetachShader
extern void (CODEGEN_FUNCPTR *_ptrc_glDisableVertexAttribArray)(GLuint);
#define glDisableVertexAttribArray _ptrc_glDisableVertexAttribArray
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawBuffers)(GLsizei, const GLenum *);
#define glDrawBuffers _ptrc_glDrawBuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glEnableVertexAttribArray)(GLuint);
#define glEnableVertexAttribArray _ptrc_glEnableVertexAttribArray
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *);
#define glGetActiveAttrib _ptrc_glGetActiveAttrib
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *);
#define glGetActiveUniform _ptrc_glGetActiveUniform
extern void (CODEGEN_FUNCPTR *_ptrc_glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *);
#define glGetAttachedShaders _ptrc_glGetAttachedShaders
extern GLint (CODEGEN_FUNCPTR *_ptrc_glGetAttribLocation)(GLuint, const GLchar *);
#define glGetAttribLocation _ptrc_glGetAttribLocation
extern void (CODEGEN_FUNCPTR *_ptrc_glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
#define glGetProgramInfoLog _ptrc_glGetProgramInfoLog
extern void (CODEGEN_FUNCPTR *_ptrc_glGetProgramiv)(GLuint, GLenum, GLint *);
#define glGetProgramiv _ptrc_glGetProgramiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *);
#define glGetShaderInfoLog _ptrc_glGetShaderInfoLog
extern void (CODEGEN_FUNCPTR *_ptrc_glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *);
#define glGetShaderSource _ptrc_glGetShaderSource
extern void (CODEGEN_FUNCPTR *_ptrc_glGetShaderiv)(GLuint, GLenum, GLint *);
#define glGetShaderiv _ptrc_glGetShaderiv
extern GLint (CODEGEN_FUNCPTR *_ptrc_glGetUniformLocation)(GLuint, const GLchar *);
#define glGetUniformLocation _ptrc_glGetUniformLocation
extern void (CODEGEN_FUNCPTR *_ptrc_glGetUniformfv)(GLuint, GLint, GLfloat *);
#define glGetUniformfv _ptrc_glGetUniformfv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetUniformiv)(GLuint, GLint, GLint *);
#define glGetUniformiv _ptrc_glGetUniformiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribPointerv)(GLuint, GLenum, GLvoid **);
#define glGetVertexAttribPointerv _ptrc_glGetVertexAttribPointerv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribdv)(GLuint, GLenum, GLdouble *);
#define glGetVertexAttribdv _ptrc_glGetVertexAttribdv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribfv)(GLuint, GLenum, GLfloat *);
#define glGetVertexAttribfv _ptrc_glGetVertexAttribfv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribiv)(GLuint, GLenum, GLint *);
#define glGetVertexAttribiv _ptrc_glGetVertexAttribiv
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsProgram)(GLuint);
#define glIsProgram _ptrc_glIsProgram
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsShader)(GLuint);
#define glIsShader _ptrc_glIsShader
extern void (CODEGEN_FUNCPTR *_ptrc_glLinkProgram)(GLuint);
#define glLinkProgram _ptrc_glLinkProgram
extern void (CODEGEN_FUNCPTR *_ptrc_glShaderSource)(GLuint, GLsizei, const GLchar *const*, const GLint *);
#define glShaderSource _ptrc_glShaderSource
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilFuncSeparate)(GLenum, GLenum, GLint, GLuint);
#define glStencilFuncSeparate _ptrc_glStencilFuncSeparate
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilMaskSeparate)(GLenum, GLuint);
#define glStencilMaskSeparate _ptrc_glStencilMaskSeparate
extern void (CODEGEN_FUNCPTR *_ptrc_glStencilOpSeparate)(GLenum, GLenum, GLenum, GLenum);
#define glStencilOpSeparate _ptrc_glStencilOpSeparate
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1f)(GLint, GLfloat);
#define glUniform1f _ptrc_glUniform1f
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1fv)(GLint, GLsizei, const GLfloat *);
#define glUniform1fv _ptrc_glUniform1fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1i)(GLint, GLint);
#define glUniform1i _ptrc_glUniform1i
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1iv)(GLint, GLsizei, const GLint *);
#define glUniform1iv _ptrc_glUniform1iv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2f)(GLint, GLfloat, GLfloat);
#define glUniform2f _ptrc_glUniform2f
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2fv)(GLint, GLsizei, const GLfloat *);
#define glUniform2fv _ptrc_glUniform2fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2i)(GLint, GLint, GLint);
#define glUniform2i _ptrc_glUniform2i
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2iv)(GLint, GLsizei, const GLint *);
#define glUniform2iv _ptrc_glUniform2iv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3f)(GLint, GLfloat, GLfloat, GLfloat);
#define glUniform3f _ptrc_glUniform3f
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3fv)(GLint, GLsizei, const GLfloat *);
#define glUniform3fv _ptrc_glUniform3fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3i)(GLint, GLint, GLint, GLint);
#define glUniform3i _ptrc_glUniform3i
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3iv)(GLint, GLsizei, const GLint *);
#define glUniform3iv _ptrc_glUniform3iv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat);
#define glUniform4f _ptrc_glUniform4f
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4fv)(GLint, GLsizei, const GLfloat *);
#define glUniform4fv _ptrc_glUniform4fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4i)(GLint, GLint, GLint, GLint, GLint);
#define glUniform4i _ptrc_glUniform4i
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4iv)(GLint, GLsizei, const GLint *);
#define glUniform4iv _ptrc_glUniform4iv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix2fv _ptrc_glUniformMatrix2fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix3fv _ptrc_glUniformMatrix3fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix4fv _ptrc_glUniformMatrix4fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUseProgram)(GLuint);
#define glUseProgram _ptrc_glUseProgram
extern void (CODEGEN_FUNCPTR *_ptrc_glValidateProgram)(GLuint);
#define glValidateProgram _ptrc_glValidateProgram
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1d)(GLuint, GLdouble);
#define glVertexAttrib1d _ptrc_glVertexAttrib1d
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1dv)(GLuint, const GLdouble *);
#define glVertexAttrib1dv _ptrc_glVertexAttrib1dv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1f)(GLuint, GLfloat);
#define glVertexAttrib1f _ptrc_glVertexAttrib1f
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1fv)(GLuint, const GLfloat *);
#define glVertexAttrib1fv _ptrc_glVertexAttrib1fv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1s)(GLuint, GLshort);
#define glVertexAttrib1s _ptrc_glVertexAttrib1s
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1sv)(GLuint, const GLshort *);
#define glVertexAttrib1sv _ptrc_glVertexAttrib1sv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2d)(GLuint, GLdouble, GLdouble);
#define glVertexAttrib2d _ptrc_glVertexAttrib2d
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2dv)(GLuint, const GLdouble *);
#define glVertexAttrib2dv _ptrc_glVertexAttrib2dv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2f)(GLuint, GLfloat, GLfloat);
#define glVertexAttrib2f _ptrc_glVertexAttrib2f
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2fv)(GLuint, const GLfloat *);
#define glVertexAttrib2fv _ptrc_glVertexAttrib2fv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2s)(GLuint, GLshort, GLshort);
#define glVertexAttrib2s _ptrc_glVertexAttrib2s
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2sv)(GLuint, const GLshort *);
#define glVertexAttrib2sv _ptrc_glVertexAttrib2sv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3d)(GLuint, GLdouble, GLdouble, GLdouble);
#define glVertexAttrib3d _ptrc_glVertexAttrib3d
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3dv)(GLuint, const GLdouble *);
#define glVertexAttrib3dv _ptrc_glVertexAttrib3dv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat);
#define glVertexAttrib3f _ptrc_glVertexAttrib3f
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3fv)(GLuint, const GLfloat *);
#define glVertexAttrib3fv _ptrc_glVertexAttrib3fv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3s)(GLuint, GLshort, GLshort, GLshort);
#define glVertexAttrib3s _ptrc_glVertexAttrib3s
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3sv)(GLuint, const GLshort *);
#define glVertexAttrib3sv _ptrc_glVertexAttrib3sv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nbv)(GLuint, const GLbyte *);
#define glVertexAttrib4Nbv _ptrc_glVertexAttrib4Nbv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Niv)(GLuint, const GLint *);
#define glVertexAttrib4Niv _ptrc_glVertexAttrib4Niv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nsv)(GLuint, const GLshort *);
#define glVertexAttrib4Nsv _ptrc_glVertexAttrib4Nsv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nub)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte);
#define glVertexAttrib4Nub _ptrc_glVertexAttrib4Nub
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nubv)(GLuint, const GLubyte *);
#define glVertexAttrib4Nubv _ptrc_glVertexAttrib4Nubv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nuiv)(GLuint, const GLuint *);
#define glVertexAttrib4Nuiv _ptrc_glVertexAttrib4Nuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nusv)(GLuint, const GLushort *);
#define glVertexAttrib4Nusv _ptrc_glVertexAttrib4Nusv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4bv)(GLuint, const GLbyte *);
#define glVertexAttrib4bv _ptrc_glVertexAttrib4bv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4d)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
#define glVertexAttrib4d _ptrc_glVertexAttrib4d
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4dv)(GLuint, const GLdouble *);
#define glVertexAttrib4dv _ptrc_glVertexAttrib4dv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
#define glVertexAttrib4f _ptrc_glVertexAttrib4f
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4fv)(GLuint, const GLfloat *);
#define glVertexAttrib4fv _ptrc_glVertexAttrib4fv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4iv)(GLuint, const GLint *);
#define glVertexAttrib4iv _ptrc_glVertexAttrib4iv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4s)(GLuint, GLshort, GLshort, GLshort, GLshort);
#define glVertexAttrib4s _ptrc_glVertexAttrib4s
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4sv)(GLuint, const GLshort *);
#define glVertexAttrib4sv _ptrc_glVertexAttrib4sv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4ubv)(GLuint, const GLubyte *);
#define glVertexAttrib4ubv _ptrc_glVertexAttrib4ubv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4uiv)(GLuint, const GLuint *);
#define glVertexAttrib4uiv _ptrc_glVertexAttrib4uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4usv)(GLuint, const GLushort *);
#define glVertexAttrib4usv _ptrc_glVertexAttrib4usv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *);
#define glVertexAttribPointer _ptrc_glVertexAttribPointer

extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2x3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix2x3fv _ptrc_glUniformMatrix2x3fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2x4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix2x4fv _ptrc_glUniformMatrix2x4fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3x2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix3x2fv _ptrc_glUniformMatrix3x2fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3x4fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix3x4fv _ptrc_glUniformMatrix3x4fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4x2fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix4x2fv _ptrc_glUniformMatrix4x2fv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4x3fv)(GLint, GLsizei, GLboolean, const GLfloat *);
#define glUniformMatrix4x3fv _ptrc_glUniformMatrix4x3fv

extern void (CODEGEN_FUNCPTR *_ptrc_glBeginConditionalRender)(GLuint, GLenum);
#define glBeginConditionalRender _ptrc_glBeginConditionalRender
extern void (CODEGEN_FUNCPTR *_ptrc_glBeginTransformFeedback)(GLenum);
#define glBeginTransformFeedback _ptrc_glBeginTransformFeedback
extern void (CODEGEN_FUNCPTR *_ptrc_glBindBufferBase)(GLenum, GLuint, GLuint);
#define glBindBufferBase _ptrc_glBindBufferBase
extern void (CODEGEN_FUNCPTR *_ptrc_glBindBufferRange)(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr);
#define glBindBufferRange _ptrc_glBindBufferRange
extern void (CODEGEN_FUNCPTR *_ptrc_glBindFragDataLocation)(GLuint, GLuint, const GLchar *);
#define glBindFragDataLocation _ptrc_glBindFragDataLocation
extern void (CODEGEN_FUNCPTR *_ptrc_glBindFramebuffer)(GLenum, GLuint);
#define glBindFramebuffer _ptrc_glBindFramebuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glBindRenderbuffer)(GLenum, GLuint);
#define glBindRenderbuffer _ptrc_glBindRenderbuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glBindVertexArray)(GLuint);
#define glBindVertexArray _ptrc_glBindVertexArray
extern void (CODEGEN_FUNCPTR *_ptrc_glBlitFramebuffer)(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);
#define glBlitFramebuffer _ptrc_glBlitFramebuffer
extern GLenum (CODEGEN_FUNCPTR *_ptrc_glCheckFramebufferStatus)(GLenum);
#define glCheckFramebufferStatus _ptrc_glCheckFramebufferStatus
extern void (CODEGEN_FUNCPTR *_ptrc_glClampColor)(GLenum, GLenum);
#define glClampColor _ptrc_glClampColor
extern void (CODEGEN_FUNCPTR *_ptrc_glClearBufferfi)(GLenum, GLint, GLfloat, GLint);
#define glClearBufferfi _ptrc_glClearBufferfi
extern void (CODEGEN_FUNCPTR *_ptrc_glClearBufferfv)(GLenum, GLint, const GLfloat *);
#define glClearBufferfv _ptrc_glClearBufferfv
extern void (CODEGEN_FUNCPTR *_ptrc_glClearBufferiv)(GLenum, GLint, const GLint *);
#define glClearBufferiv _ptrc_glClearBufferiv
extern void (CODEGEN_FUNCPTR *_ptrc_glClearBufferuiv)(GLenum, GLint, const GLuint *);
#define glClearBufferuiv _ptrc_glClearBufferuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glColorMaski)(GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
#define glColorMaski _ptrc_glColorMaski
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteFramebuffers)(GLsizei, const GLuint *);
#define glDeleteFramebuffers _ptrc_glDeleteFramebuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteRenderbuffers)(GLsizei, const GLuint *);
#define glDeleteRenderbuffers _ptrc_glDeleteRenderbuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteVertexArrays)(GLsizei, const GLuint *);
#define glDeleteVertexArrays _ptrc_glDeleteVertexArrays
extern void (CODEGEN_FUNCPTR *_ptrc_glDisablei)(GLenum, GLuint);
#define glDisablei _ptrc_glDisablei
extern void (CODEGEN_FUNCPTR *_ptrc_glEnablei)(GLenum, GLuint);
#define glEnablei _ptrc_glEnablei
extern void (CODEGEN_FUNCPTR *_ptrc_glEndConditionalRender)();
#define glEndConditionalRender _ptrc_glEndConditionalRender
extern void (CODEGEN_FUNCPTR *_ptrc_glEndTransformFeedback)();
#define glEndTransformFeedback _ptrc_glEndTransformFeedback
extern void (CODEGEN_FUNCPTR *_ptrc_glFlushMappedBufferRange)(GLenum, GLintptr, GLsizeiptr);
#define glFlushMappedBufferRange _ptrc_glFlushMappedBufferRange
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferRenderbuffer)(GLenum, GLenum, GLenum, GLuint);
#define glFramebufferRenderbuffer _ptrc_glFramebufferRenderbuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture1D)(GLenum, GLenum, GLenum, GLuint, GLint);
#define glFramebufferTexture1D _ptrc_glFramebufferTexture1D
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture2D)(GLenum, GLenum, GLenum, GLuint, GLint);
#define glFramebufferTexture2D _ptrc_glFramebufferTexture2D
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture3D)(GLenum, GLenum, GLenum, GLuint, GLint, GLint);
#define glFramebufferTexture3D _ptrc_glFramebufferTexture3D
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTextureLayer)(GLenum, GLenum, GLuint, GLint, GLint);
#define glFramebufferTextureLayer _ptrc_glFramebufferTextureLayer
extern void (CODEGEN_FUNCPTR *_ptrc_glGenFramebuffers)(GLsizei, GLuint *);
#define glGenFramebuffers _ptrc_glGenFramebuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glGenRenderbuffers)(GLsizei, GLuint *);
#define glGenRenderbuffers _ptrc_glGenRenderbuffers
extern void (CODEGEN_FUNCPTR *_ptrc_glGenVertexArrays)(GLsizei, GLuint *);
#define glGenVertexArrays _ptrc_glGenVertexArrays
extern void (CODEGEN_FUNCPTR *_ptrc_glGenerateMipmap)(GLenum);
#define glGenerateMipmap _ptrc_glGenerateMipmap
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBooleani_v)(GLenum, GLuint, GLboolean *);
#define glGetBooleani_v _ptrc_glGetBooleani_v
extern GLint (CODEGEN_FUNCPTR *_ptrc_glGetFragDataLocation)(GLuint, const GLchar *);
#define glGetFragDataLocation _ptrc_glGetFragDataLocation
extern void (CODEGEN_FUNCPTR *_ptrc_glGetFramebufferAttachmentParameteriv)(GLenum, GLenum, GLenum, GLint *);
#define glGetFramebufferAttachmentParameteriv _ptrc_glGetFramebufferAttachmentParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetIntegeri_v)(GLenum, GLuint, GLint *);
#define glGetIntegeri_v _ptrc_glGetIntegeri_v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetRenderbufferParameteriv)(GLenum, GLenum, GLint *);
#define glGetRenderbufferParameteriv _ptrc_glGetRenderbufferParameteriv
extern const GLubyte * (CODEGEN_FUNCPTR *_ptrc_glGetStringi)(GLenum, GLuint);
#define glGetStringi _ptrc_glGetStringi
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterIiv)(GLenum, GLenum, GLint *);
#define glGetTexParameterIiv _ptrc_glGetTexParameterIiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterIuiv)(GLenum, GLenum, GLuint *);
#define glGetTexParameterIuiv _ptrc_glGetTexParameterIuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetTransformFeedbackVarying)(GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *);
#define glGetTransformFeedbackVarying _ptrc_glGetTransformFeedbackVarying
extern void (CODEGEN_FUNCPTR *_ptrc_glGetUniformuiv)(GLuint, GLint, GLuint *);
#define glGetUniformuiv _ptrc_glGetUniformuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribIiv)(GLuint, GLenum, GLint *);
#define glGetVertexAttribIiv _ptrc_glGetVertexAttribIiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribIuiv)(GLuint, GLenum, GLuint *);
#define glGetVertexAttribIuiv _ptrc_glGetVertexAttribIuiv
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsEnabledi)(GLenum, GLuint);
#define glIsEnabledi _ptrc_glIsEnabledi
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsFramebuffer)(GLuint);
#define glIsFramebuffer _ptrc_glIsFramebuffer
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsRenderbuffer)(GLuint);
#define glIsRenderbuffer _ptrc_glIsRenderbuffer
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsVertexArray)(GLuint);
#define glIsVertexArray _ptrc_glIsVertexArray
extern void * (CODEGEN_FUNCPTR *_ptrc_glMapBufferRange)(GLenum, GLintptr, GLsizeiptr, GLbitfield);
#define glMapBufferRange _ptrc_glMapBufferRange
extern void (CODEGEN_FUNCPTR *_ptrc_glRenderbufferStorage)(GLenum, GLenum, GLsizei, GLsizei);
#define glRenderbufferStorage _ptrc_glRenderbufferStorage
extern void (CODEGEN_FUNCPTR *_ptrc_glRenderbufferStorageMultisample)(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
#define glRenderbufferStorageMultisample _ptrc_glRenderbufferStorageMultisample
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameterIiv)(GLenum, GLenum, const GLint *);
#define glTexParameterIiv _ptrc_glTexParameterIiv
extern void (CODEGEN_FUNCPTR *_ptrc_glTexParameterIuiv)(GLenum, GLenum, const GLuint *);
#define glTexParameterIuiv _ptrc_glTexParameterIuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glTransformFeedbackVaryings)(GLuint, GLsizei, const GLchar *const*, GLenum);
#define glTransformFeedbackVaryings _ptrc_glTransformFeedbackVaryings
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1ui)(GLint, GLuint);
#define glUniform1ui _ptrc_glUniform1ui
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform1uiv)(GLint, GLsizei, const GLuint *);
#define glUniform1uiv _ptrc_glUniform1uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2ui)(GLint, GLuint, GLuint);
#define glUniform2ui _ptrc_glUniform2ui
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform2uiv)(GLint, GLsizei, const GLuint *);
#define glUniform2uiv _ptrc_glUniform2uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3ui)(GLint, GLuint, GLuint, GLuint);
#define glUniform3ui _ptrc_glUniform3ui
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform3uiv)(GLint, GLsizei, const GLuint *);
#define glUniform3uiv _ptrc_glUniform3uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4ui)(GLint, GLuint, GLuint, GLuint, GLuint);
#define glUniform4ui _ptrc_glUniform4ui
extern void (CODEGEN_FUNCPTR *_ptrc_glUniform4uiv)(GLint, GLsizei, const GLuint *);
#define glUniform4uiv _ptrc_glUniform4uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1i)(GLuint, GLint);
#define glVertexAttribI1i _ptrc_glVertexAttribI1i
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1iv)(GLuint, const GLint *);
#define glVertexAttribI1iv _ptrc_glVertexAttribI1iv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1ui)(GLuint, GLuint);
#define glVertexAttribI1ui _ptrc_glVertexAttribI1ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1uiv)(GLuint, const GLuint *);
#define glVertexAttribI1uiv _ptrc_glVertexAttribI1uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2i)(GLuint, GLint, GLint);
#define glVertexAttribI2i _ptrc_glVertexAttribI2i
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2iv)(GLuint, const GLint *);
#define glVertexAttribI2iv _ptrc_glVertexAttribI2iv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2ui)(GLuint, GLuint, GLuint);
#define glVertexAttribI2ui _ptrc_glVertexAttribI2ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2uiv)(GLuint, const GLuint *);
#define glVertexAttribI2uiv _ptrc_glVertexAttribI2uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3i)(GLuint, GLint, GLint, GLint);
#define glVertexAttribI3i _ptrc_glVertexAttribI3i
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3iv)(GLuint, const GLint *);
#define glVertexAttribI3iv _ptrc_glVertexAttribI3iv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3ui)(GLuint, GLuint, GLuint, GLuint);
#define glVertexAttribI3ui _ptrc_glVertexAttribI3ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3uiv)(GLuint, const GLuint *);
#define glVertexAttribI3uiv _ptrc_glVertexAttribI3uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4bv)(GLuint, const GLbyte *);
#define glVertexAttribI4bv _ptrc_glVertexAttribI4bv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4i)(GLuint, GLint, GLint, GLint, GLint);
#define glVertexAttribI4i _ptrc_glVertexAttribI4i
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4iv)(GLuint, const GLint *);
#define glVertexAttribI4iv _ptrc_glVertexAttribI4iv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4sv)(GLuint, const GLshort *);
#define glVertexAttribI4sv _ptrc_glVertexAttribI4sv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4ubv)(GLuint, const GLubyte *);
#define glVertexAttribI4ubv _ptrc_glVertexAttribI4ubv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4ui)(GLuint, GLuint, GLuint, GLuint, GLuint);
#define glVertexAttribI4ui _ptrc_glVertexAttribI4ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4uiv)(GLuint, const GLuint *);
#define glVertexAttribI4uiv _ptrc_glVertexAttribI4uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4usv)(GLuint, const GLushort *);
#define glVertexAttribI4usv _ptrc_glVertexAttribI4usv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribIPointer)(GLuint, GLint, GLenum, GLsizei, const GLvoid *);
#define glVertexAttribIPointer _ptrc_glVertexAttribIPointer

extern void (CODEGEN_FUNCPTR *_ptrc_glCopyBufferSubData)(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr);
#define glCopyBufferSubData _ptrc_glCopyBufferSubData
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawArraysInstanced)(GLenum, GLint, GLsizei, GLsizei);
#define glDrawArraysInstanced _ptrc_glDrawArraysInstanced
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsInstanced)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei);
#define glDrawElementsInstanced _ptrc_glDrawElementsInstanced
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformBlockName)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *);
#define glGetActiveUniformBlockName _ptrc_glGetActiveUniformBlockName
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformBlockiv)(GLuint, GLuint, GLenum, GLint *);
#define glGetActiveUniformBlockiv _ptrc_glGetActiveUniformBlockiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformName)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *);
#define glGetActiveUniformName _ptrc_glGetActiveUniformName
extern void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformsiv)(GLuint, GLsizei, const GLuint *, GLenum, GLint *);
#define glGetActiveUniformsiv _ptrc_glGetActiveUniformsiv
extern GLuint (CODEGEN_FUNCPTR *_ptrc_glGetUniformBlockIndex)(GLuint, const GLchar *);
#define glGetUniformBlockIndex _ptrc_glGetUniformBlockIndex
extern void (CODEGEN_FUNCPTR *_ptrc_glGetUniformIndices)(GLuint, GLsizei, const GLchar *const*, GLuint *);
#define glGetUniformIndices _ptrc_glGetUniformIndices
extern void (CODEGEN_FUNCPTR *_ptrc_glPrimitiveRestartIndex)(GLuint);
#define glPrimitiveRestartIndex _ptrc_glPrimitiveRestartIndex
extern void (CODEGEN_FUNCPTR *_ptrc_glTexBuffer)(GLenum, GLenum, GLuint);
#define glTexBuffer _ptrc_glTexBuffer
extern void (CODEGEN_FUNCPTR *_ptrc_glUniformBlockBinding)(GLuint, GLuint, GLuint);
#define glUniformBlockBinding _ptrc_glUniformBlockBinding

extern GLenum (CODEGEN_FUNCPTR *_ptrc_glClientWaitSync)(GLsync, GLbitfield, GLuint64);
#define glClientWaitSync _ptrc_glClientWaitSync
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteSync)(GLsync);
#define glDeleteSync _ptrc_glDeleteSync
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsBaseVertex)(GLenum, GLsizei, GLenum, const GLvoid *, GLint);
#define glDrawElementsBaseVertex _ptrc_glDrawElementsBaseVertex
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsInstancedBaseVertex)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei, GLint);
#define glDrawElementsInstancedBaseVertex _ptrc_glDrawElementsInstancedBaseVertex
extern void (CODEGEN_FUNCPTR *_ptrc_glDrawRangeElementsBaseVertex)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *, GLint);
#define glDrawRangeElementsBaseVertex _ptrc_glDrawRangeElementsBaseVertex
extern GLsync (CODEGEN_FUNCPTR *_ptrc_glFenceSync)(GLenum, GLbitfield);
#define glFenceSync _ptrc_glFenceSync
extern void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture)(GLenum, GLenum, GLuint, GLint);
#define glFramebufferTexture _ptrc_glFramebufferTexture
extern void (CODEGEN_FUNCPTR *_ptrc_glGetBufferParameteri64v)(GLenum, GLenum, GLint64 *);
#define glGetBufferParameteri64v _ptrc_glGetBufferParameteri64v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetInteger64i_v)(GLenum, GLuint, GLint64 *);
#define glGetInteger64i_v _ptrc_glGetInteger64i_v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetInteger64v)(GLenum, GLint64 *);
#define glGetInteger64v _ptrc_glGetInteger64v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetMultisamplefv)(GLenum, GLuint, GLfloat *);
#define glGetMultisamplefv _ptrc_glGetMultisamplefv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetSynciv)(GLsync, GLenum, GLsizei, GLsizei *, GLint *);
#define glGetSynciv _ptrc_glGetSynciv
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsSync)(GLsync);
#define glIsSync _ptrc_glIsSync
extern void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawElementsBaseVertex)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei, const GLint *);
#define glMultiDrawElementsBaseVertex _ptrc_glMultiDrawElementsBaseVertex
extern void (CODEGEN_FUNCPTR *_ptrc_glProvokingVertex)(GLenum);
#define glProvokingVertex _ptrc_glProvokingVertex
extern void (CODEGEN_FUNCPTR *_ptrc_glSampleMaski)(GLuint, GLbitfield);
#define glSampleMaski _ptrc_glSampleMaski
extern void (CODEGEN_FUNCPTR *_ptrc_glTexImage2DMultisample)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean);
#define glTexImage2DMultisample _ptrc_glTexImage2DMultisample
extern void (CODEGEN_FUNCPTR *_ptrc_glTexImage3DMultisample)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean);
#define glTexImage3DMultisample _ptrc_glTexImage3DMultisample
extern void (CODEGEN_FUNCPTR *_ptrc_glWaitSync)(GLsync, GLbitfield, GLuint64);
#define glWaitSync _ptrc_glWaitSync

extern void (CODEGEN_FUNCPTR *_ptrc_glBindFragDataLocationIndexed)(GLuint, GLuint, GLuint, const GLchar *);
#define glBindFragDataLocationIndexed _ptrc_glBindFragDataLocationIndexed
extern void (CODEGEN_FUNCPTR *_ptrc_glBindSampler)(GLuint, GLuint);
#define glBindSampler _ptrc_glBindSampler
extern void (CODEGEN_FUNCPTR *_ptrc_glDeleteSamplers)(GLsizei, const GLuint *);
#define glDeleteSamplers _ptrc_glDeleteSamplers
extern void (CODEGEN_FUNCPTR *_ptrc_glGenSamplers)(GLsizei, GLuint *);
#define glGenSamplers _ptrc_glGenSamplers
extern GLint (CODEGEN_FUNCPTR *_ptrc_glGetFragDataIndex)(GLuint, const GLchar *);
#define glGetFragDataIndex _ptrc_glGetFragDataIndex
extern void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjecti64v)(GLuint, GLenum, GLint64 *);
#define glGetQueryObjecti64v _ptrc_glGetQueryObjecti64v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectui64v)(GLuint, GLenum, GLuint64 *);
#define glGetQueryObjectui64v _ptrc_glGetQueryObjectui64v
extern void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterIiv)(GLuint, GLenum, GLint *);
#define glGetSamplerParameterIiv _ptrc_glGetSamplerParameterIiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterIuiv)(GLuint, GLenum, GLuint *);
#define glGetSamplerParameterIuiv _ptrc_glGetSamplerParameterIuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterfv)(GLuint, GLenum, GLfloat *);
#define glGetSamplerParameterfv _ptrc_glGetSamplerParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameteriv)(GLuint, GLenum, GLint *);
#define glGetSamplerParameteriv _ptrc_glGetSamplerParameteriv
extern GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsSampler)(GLuint);
#define glIsSampler _ptrc_glIsSampler
extern void (CODEGEN_FUNCPTR *_ptrc_glQueryCounter)(GLuint, GLenum);
#define glQueryCounter _ptrc_glQueryCounter
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterIiv)(GLuint, GLenum, const GLint *);
#define glSamplerParameterIiv _ptrc_glSamplerParameterIiv
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterIuiv)(GLuint, GLenum, const GLuint *);
#define glSamplerParameterIuiv _ptrc_glSamplerParameterIuiv
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterf)(GLuint, GLenum, GLfloat);
#define glSamplerParameterf _ptrc_glSamplerParameterf
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterfv)(GLuint, GLenum, const GLfloat *);
#define glSamplerParameterfv _ptrc_glSamplerParameterfv
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameteri)(GLuint, GLenum, GLint);
#define glSamplerParameteri _ptrc_glSamplerParameteri
extern void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameteriv)(GLuint, GLenum, const GLint *);
#define glSamplerParameteriv _ptrc_glSamplerParameteriv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribDivisor)(GLuint, GLuint);
#define glVertexAttribDivisor _ptrc_glVertexAttribDivisor
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP1ui)(GLuint, GLenum, GLboolean, GLuint);
#define glVertexAttribP1ui _ptrc_glVertexAttribP1ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP1uiv)(GLuint, GLenum, GLboolean, const GLuint *);
#define glVertexAttribP1uiv _ptrc_glVertexAttribP1uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP2ui)(GLuint, GLenum, GLboolean, GLuint);
#define glVertexAttribP2ui _ptrc_glVertexAttribP2ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP2uiv)(GLuint, GLenum, GLboolean, const GLuint *);
#define glVertexAttribP2uiv _ptrc_glVertexAttribP2uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP3ui)(GLuint, GLenum, GLboolean, GLuint);
#define glVertexAttribP3ui _ptrc_glVertexAttribP3ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP3uiv)(GLuint, GLenum, GLboolean, const GLuint *);
#define glVertexAttribP3uiv _ptrc_glVertexAttribP3uiv
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP4ui)(GLuint, GLenum, GLboolean, GLuint);
#define glVertexAttribP4ui _ptrc_glVertexAttribP4ui
extern void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP4uiv)(GLuint, GLenum, GLboolean, const GLuint *);
#define glVertexAttribP4uiv _ptrc_glVertexAttribP4uiv

enum ogl_LoadStatus
{
ogl_LOAD_FAILED = 0,
ogl_LOAD_SUCCEEDED = 1,
};

int ogl_LoadFunctions();

int ogl_GetMinorVersion();
int ogl_GetMajorVersion();
int ogl_IsVersionGEQ(int majorVersion, int minorVersion);

#ifdef __cplusplus
}
#endif /*__cplusplus*/

#endif //POINTER_C_GENERATED_HEADER_OPENGL_H

#ifndef POINTER_C_GENERATED_HEADER_WINDOWSGL_H
#define POINTER_C_GENERATED_HEADER_WINDOWSGL_H

#ifdef __wglext_h_
#error Attempt to include auto-generated WGL header after wglext.h
#endif

#define __wglext_h_

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif
#include <windows.h>

#ifdef CODEGEN_FUNCPTR
#undef CODEGEN_FUNCPTR
#endif /*CODEGEN_FUNCPTR*/
#define CODEGEN_FUNCPTR WINAPI

#ifndef GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS
#define GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
#define GLvoid void

#endif /*GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS*/


#ifndef GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS
#define GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS


#endif /*GL_LOAD_GEN_BASIC_OPENGL_TYPEDEFS*/


struct _GPU_DEVICE {
DWORD  cb;
CHAR   DeviceName[32];
CHAR   DeviceString[128];
DWORD  Flags;
RECT   rcVirtualScreen;
};
DECLARE_HANDLE(HPBUFFERARB);
DECLARE_HANDLE(HPBUFFEREXT);
DECLARE_HANDLE(HVIDEOOUTPUTDEVICENV);
DECLARE_HANDLE(HPVIDEODEV);
DECLARE_HANDLE(HGPUNV);
DECLARE_HANDLE(HVIDEOINPUTDEVICENV);
typedef struct _GPU_DEVICE *PGPU_DEVICE;

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

extern int wgl_ext_ARB_multisample;
extern int wgl_ext_ARB_extensions_string;
extern int wgl_ext_ARB_pixel_format;
extern int wgl_ext_ARB_pixel_format_float;
extern int wgl_ext_ARB_framebuffer_sRGB;
extern int wgl_ext_ARB_create_context;
extern int wgl_ext_ARB_create_context_profile;
extern int wgl_ext_ARB_create_context_robustness;
extern int wgl_ext_EXT_swap_control;
extern int wgl_ext_EXT_pixel_format_packed_float;
extern int wgl_ext_EXT_create_context_es2_profile;
extern int wgl_ext_EXT_swap_control_tear;
extern int wgl_ext_NV_swap_group;

#define WGL_SAMPLES_ARB 0x2042
#define WGL_SAMPLE_BUFFERS_ARB 0x2041

#define WGL_ACCELERATION_ARB 0x2003
#define WGL_ACCUM_ALPHA_BITS_ARB 0x2021
#define WGL_ACCUM_BITS_ARB 0x201D
#define WGL_ACCUM_BLUE_BITS_ARB 0x2020
#define WGL_ACCUM_GREEN_BITS_ARB 0x201F
#define WGL_ACCUM_RED_BITS_ARB 0x201E
#define WGL_ALPHA_BITS_ARB 0x201B
#define WGL_ALPHA_SHIFT_ARB 0x201C
#define WGL_AUX_BUFFERS_ARB 0x2024
#define WGL_BLUE_BITS_ARB 0x2019
#define WGL_BLUE_SHIFT_ARB 0x201A
#define WGL_COLOR_BITS_ARB 0x2014
#define WGL_DEPTH_BITS_ARB 0x2022
#define WGL_DOUBLE_BUFFER_ARB 0x2011
#define WGL_DRAW_TO_BITMAP_ARB 0x2002
#define WGL_DRAW_TO_WINDOW_ARB 0x2001
#define WGL_FULL_ACCELERATION_ARB 0x2027
#define WGL_GENERIC_ACCELERATION_ARB 0x2026
#define WGL_GREEN_BITS_ARB 0x2017
#define WGL_GREEN_SHIFT_ARB 0x2018
#define WGL_NEED_PALETTE_ARB 0x2004
#define WGL_NEED_SYSTEM_PALETTE_ARB 0x2005
#define WGL_NO_ACCELERATION_ARB 0x2025
#define WGL_NUMBER_OVERLAYS_ARB 0x2008
#define WGL_NUMBER_PIXEL_FORMATS_ARB 0x2000
#define WGL_NUMBER_UNDERLAYS_ARB 0x2009
#define WGL_PIXEL_TYPE_ARB 0x2013
#define WGL_RED_BITS_ARB 0x2015
#define WGL_RED_SHIFT_ARB 0x2016
#define WGL_SHARE_ACCUM_ARB 0x200E
#define WGL_SHARE_DEPTH_ARB 0x200C
#define WGL_SHARE_STENCIL_ARB 0x200D
#define WGL_STENCIL_BITS_ARB 0x2023
#define WGL_STEREO_ARB 0x2012
#define WGL_SUPPORT_GDI_ARB 0x200F
#define WGL_SUPPORT_OPENGL_ARB 0x2010
#define WGL_SWAP_COPY_ARB 0x2029
#define WGL_SWAP_EXCHANGE_ARB 0x2028
#define WGL_SWAP_LAYER_BUFFERS_ARB 0x2006
#define WGL_SWAP_METHOD_ARB 0x2007
#define WGL_SWAP_UNDEFINED_ARB 0x202A
#define WGL_TRANSPARENT_ALPHA_VALUE_ARB 0x203A
#define WGL_TRANSPARENT_ARB 0x200A
#define WGL_TRANSPARENT_BLUE_VALUE_ARB 0x2039
#define WGL_TRANSPARENT_GREEN_VALUE_ARB 0x2038
#define WGL_TRANSPARENT_INDEX_VALUE_ARB 0x203B
#define WGL_TRANSPARENT_RED_VALUE_ARB 0x2037
#define WGL_TYPE_COLORINDEX_ARB 0x202C
#define WGL_TYPE_RGBA_ARB 0x202B

#define WGL_TYPE_RGBA_FLOAT_ARB 0x21A0

#define WGL_FRAMEBUFFER_SRGB_CAPABLE_ARB 0x20A9

#define WGL_CONTEXT_DEBUG_BIT_ARB 0x00000001
#define WGL_CONTEXT_FLAGS_ARB 0x2094
#define WGL_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
#define WGL_CONTEXT_LAYER_PLANE_ARB 0x2093
#define WGL_CONTEXT_MAJOR_VERSION_ARB 0x2091
#define WGL_CONTEXT_MINOR_VERSION_ARB 0x2092
#define WGL_ERROR_INVALID_VERSION_ARB 0x2095

#define WGL_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
#define WGL_CONTEXT_CORE_PROFILE_BIT_ARB 0x00000001
#define WGL_CONTEXT_PROFILE_MASK_ARB 0x9126
#define WGL_ERROR_INVALID_PROFILE_ARB 0x2096

#define WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
#define WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
#define WGL_LOSE_CONTEXT_ON_RESET_ARB 0x8252
#define WGL_NO_RESET_NOTIFICATION_ARB 0x8261

#define WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT 0x20A8

#define WGL_CONTEXT_ES2_PROFILE_BIT_EXT 0x00000004


#ifndef WGL_ARB_extensions_string
#define WGL_ARB_extensions_string 1
extern const char * (CODEGEN_FUNCPTR *_ptrc_wglGetExtensionsStringARB)(HDC);
#define wglGetExtensionsStringARB _ptrc_wglGetExtensionsStringARB
#endif /*WGL_ARB_extensions_string*/

#ifndef WGL_ARB_pixel_format
#define WGL_ARB_pixel_format 1
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *, UINT, int *, UINT *);
#define wglChoosePixelFormatARB _ptrc_wglChoosePixelFormatARB
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglGetPixelFormatAttribfvARB)(HDC, int, int, UINT, const int *, FLOAT *);
#define wglGetPixelFormatAttribfvARB _ptrc_wglGetPixelFormatAttribfvARB
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglGetPixelFormatAttribivARB)(HDC, int, int, UINT, const int *, int *);
#define wglGetPixelFormatAttribivARB _ptrc_wglGetPixelFormatAttribivARB
#endif /*WGL_ARB_pixel_format*/



#ifndef WGL_ARB_create_context
#define WGL_ARB_create_context 1
extern HGLRC (CODEGEN_FUNCPTR *_ptrc_wglCreateContextAttribsARB)(HDC, HGLRC, const int *);
#define wglCreateContextAttribsARB _ptrc_wglCreateContextAttribsARB
#endif /*WGL_ARB_create_context*/



#ifndef WGL_EXT_swap_control
#define WGL_EXT_swap_control 1
extern int (CODEGEN_FUNCPTR *_ptrc_wglGetSwapIntervalEXT)();
#define wglGetSwapIntervalEXT _ptrc_wglGetSwapIntervalEXT
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglSwapIntervalEXT)(int);
#define wglSwapIntervalEXT _ptrc_wglSwapIntervalEXT
#endif /*WGL_EXT_swap_control*/




#ifndef WGL_NV_swap_group
#define WGL_NV_swap_group 1
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglBindSwapBarrierNV)(GLuint, GLuint);
#define wglBindSwapBarrierNV _ptrc_wglBindSwapBarrierNV
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglJoinSwapGroupNV)(HDC, GLuint);
#define wglJoinSwapGroupNV _ptrc_wglJoinSwapGroupNV
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglQueryFrameCountNV)(HDC, GLuint *);
#define wglQueryFrameCountNV _ptrc_wglQueryFrameCountNV
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglQueryMaxSwapGroupsNV)(HDC, GLuint *, GLuint *);
#define wglQueryMaxSwapGroupsNV _ptrc_wglQueryMaxSwapGroupsNV
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglQuerySwapGroupNV)(HDC, GLuint *, GLuint *);
#define wglQuerySwapGroupNV _ptrc_wglQuerySwapGroupNV
extern BOOL (CODEGEN_FUNCPTR *_ptrc_wglResetFrameCountNV)(HDC);
#define wglResetFrameCountNV _ptrc_wglResetFrameCountNV
#endif /*WGL_NV_swap_group*/

enum wgl_LoadStatus
{
wgl_LOAD_FAILED = 0,
wgl_LOAD_SUCCEEDED = 1,
};

int wgl_LoadFunctions(HDC hdc);


#ifdef __cplusplus
}
#endif /*__cplusplus*/

#endif //POINTER_C_GENERATED_HEADER_WINDOWSGL_H


#ifndef _WIN32
typedef const wchar_t* LPCTSTR;
typedef const char* LPCSTR;
#endif

#if PROJECT_XO
#ifdef _WIN32
#define PAPI __declspec(dllexport)
#else
#define PAPI
#endif
#else
#ifdef _WIN32
#define PAPI __declspec(dllimport)
#else
#define PAPI
#endif
#endif

#define NO_XSTRING

#ifndef INLINE
#define INLINE inline
#endif

#ifndef _TCHAR_DEFINED
typedef char TCHAR;
#endif

#ifndef _INC_TCHAR
//#define _T(x) L ## x
#define _T(x) x
#endif


// Definitions fit for inclusion into any C++ project, for any architecture

// Found this in the Chrome sources, via a PVS studio blog post
template <typename T, size_t N>
char (&ArraySizeHelper(T (&array)[N]))[N];
#define arraysize(array) (sizeof(ArraySizeHelper(array)))

// A macro to disallow the copy constructor and operator= functions
// This should be used in the private: declarations for a class.
// A common layout is this:
//   class Foo
//   {
//       DISALLOW_COPY_AND_ASSIGN(Foo);
//   public:
//       ...
//   }
#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
TypeName(const TypeName&);               \
void operator=(const TypeName&)

#ifdef _MSC_VER
#define NORETURN __declspec(noreturn)
#else
#define NORETURN __attribute__ ((noreturn))
#endif

#ifdef _MSC_VER
#	if _M_X64
#		define ARCH_64 1
#	endif
#else
#	if __SIZEOF_POINTER__ == 8
#		define ARCH_64 1
#	endif
#endif


// This file contains macros for compiler-specific things such as specifying struct alignment

#ifdef _WIN32
#define ABC_ALIGN(alignment)			__declspec(align(alignment))
#define ABC_ALIGNED(type, alignment)	__declspec(align(alignment)) type
#else
#define ABC_ALIGN(alignment)			__attribute__ ((aligned(alignment)))
#define ABC_ALIGNED(type, alignment)	type __attribute__ ((aligned(alignment)))
#endif

#define ABC_ALIGNED_TYPE(_type, alignment) typedef _type ABC_ALIGN(alignment)


#if ((__GNUC__ * 100) + __GNUC_MINOR__) >= 402
#define GCC_DIAG_STR(s) #s
#define GCC_DIAG_JOINSTR(x,y) GCC_DIAG_STR(x ## y)
# define GCC_DIAG_DO_PRAGMA(x) _Pragma (#x)
# define GCC_DIAG_PRAGMA(x) GCC_DIAG_DO_PRAGMA(GCC diagnostic x)
# if ((__GNUC__ * 100) + __GNUC_MINOR__) >= 406
#  define GCC_DIAG_OFF(x)    GCC_DIAG_PRAGMA(push) \
GCC_DIAG_PRAGMA(ignored GCC_DIAG_JOINSTR(-W,x))
#  define GCC_DIAG_ON(x)     GCC_DIAG_PRAGMA(pop)
# else
#  define GCC_DIAG_OFF(x)    GCC_DIAG_PRAGMA(ignored GCC_DIAG_JOINSTR(-W,x))
#  define GCC_DIAG_ON(x)     GCC_DIAG_PRAGMA(warning GCC_DIAG_JOINSTR(-W,x))
# endif
#else
# define GCC_DIAG_OFF(x)
# define GCC_DIAG_ON(x)
#endif





// Necessary on some linux stdint.h, to get INT32_MAX etc.
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS
#endif


#ifdef _WIN32
// This block here is necessary to quiet macro redefinition warnings from including stdint.h and intsafe.h.
// Issue https://connect.microsoft.com/VisualStudio/feedback/details/621653/including-stdint-after-intsafe-generates-warnings
#pragma warning( push )
#pragma warning( disable: 4005 ) // macro redef.
#pragma warning( pop )
#else
#endif

typedef signed char		i8;			// preferred (i8)
typedef signed char		int8;
typedef signed char		int8_t;
typedef unsigned char	u8;			// preferred (u8)
typedef unsigned char	uint8;
typedef unsigned char	uint8_t;
typedef unsigned char	byte;
typedef int int32;					// preferred (int or int32) -- see also intr/intp below
typedef int INT32;
typedef int int32_t;
typedef short i16;					// preferred (i16)
typedef short int16_t;
typedef short int16;
typedef unsigned int u32;			// preferred (u32) -- see also intr/intp below
typedef unsigned int uint;
typedef unsigned int UINT;
typedef unsigned int uint32;
typedef unsigned int UINT32;
typedef unsigned int uint32_t;
typedef unsigned short u16;			// preferred (u16)
typedef unsigned short uint16;
typedef unsigned short uint16_t;


#ifdef _MSC_VER
typedef __int64 i64;				// preferred (i64) -- see also intr/intp below
typedef __int64 int64;
typedef __int64 int64_t;
typedef __int64 INT64;
typedef unsigned __int64 u64;		// preferred (u64) -- see also intr/intp below
typedef unsigned __int64 uint64;
typedef unsigned __int64 uint64_t;
typedef unsigned __int64 UINT64;
#else
typedef int64_t		i64;
typedef int64_t		int64;
typedef int64_t		INT64;
typedef uint64_t	u64;
typedef uint64_t	uint64;
typedef uint64_t	UINT64;
#endif

// These are suggestions by Charles Bloom:
// intr: size of register
// intp: size of pointer
// intp and intr are the same on Windows x86/x64, but not true for all architectures.
// Here we assume that pointer and register sizes are always the same.
#if ARCH_64
typedef int64 intr;
typedef int64 intp;
typedef uint64 uintr;
typedef uint64 uintp;
#else
typedef int32 intr;
typedef int32 intp;
typedef unsigned int uintr;
typedef unsigned int uintp;
#endif

typedef signed char INT8;
typedef unsigned char UINT8;
typedef signed short INT16;
typedef unsigned short UINT16;

typedef UINT8 BYTE;
typedef INT16 SHORT;
typedef UINT16 WORD;

#ifndef _WIN32
typedef UINT32 DWORD;
#endif

// These macros are an unfortunate necessity to deal with the confusion between LP64 and LLP64 models
// that Unix and Windows employ. Use these macros when declaring 64-bit integer constants.
#ifdef _MSC_VER
#	define CONST_I64(n) n ## ll
#	define CONST_U64(n) n ## ull
#else
#	if __WORDSIZE == 64
#		define CONST_I64(n) n ## l
#		define CONST_U64(n) n ## ul
#	else
#		define CONST_I64(n) n ## ll
#		define CONST_U64(n) n ## ull
#	endif
#endif

// Don't use these. Instead, use %lld and %llu. Those work for all platforms. Note that the 'd' and 'u' are essential.
// HOWEVER, if you need to scanf a 64-bit hex string, then you have to use PRIx64
#ifdef _WIN32
//#define PRIu64 "I64u"
//#define PRId64 "I64d"
#	ifndef PRIu64
#		define PRIu64 ((void) static_assert(false, "Use %llu instead"))
#	endif
#	ifndef PRIu64
#		define PRId64 ((void) static_assert(false, "Use %lld instead"))
#	endif
#	ifndef PRIX64
#		define  PRIX64  "I64X"
#		define wPRIX64 L"I64X"
#	endif
#else
#	ifndef PRIX64
//		The GCC stdint.h uses __WORDSIZE == 64 to determine whether int64_t is going to be "long int" or "long long int", so we do the same here.
#		if __WORDSIZE == 64
#			define  PRIX64  "lX"
#			define wPRIX64 L"lX"
#		else
#			define  PRIX64  "llX"
#			define wPRIX64 L"llX"
#		endif
#	endif
#endif


#ifdef _WIN32
#define INTMIN		_I32_MIN
#define INTMAX		_I32_MAX
#define INT8MIN		_I8_MIN
#define INT8MAX		_I8_MAX
#define INT16MIN	_I16_MIN
#define INT16MAX	_I16_MAX
#define INT32MIN	_I32_MIN
#define INT32MAX	_I32_MAX
#define INT64MIN	_I64_MIN
#define INT64MAX	_I64_MAX
#define UINT8MAX	_UI8_MAX
#define UINT16MAX	_UI16_MAX
#define UINT32MAX	_UI32_MAX
#define UINT64MAX	_UI64_MAX
#else
#define INTMIN		INT32_MIN
#define INTMAX		INT32_MAX
#define INT8MIN		INT8_MIN
#define INT8MAX		INT8_MAX
#define INT16MIN	INT16_MIN
#define INT16MAX	INT16_MAX
#define INT32MIN	INT32_MIN
#define INT32MAX	INT32_MAX
#define INT64MIN	INT64_MIN
#define INT64MAX	INT64_MAX
#define UINT8MAX	UINT8_MAX
#define UINT16MAX	UINT16_MAX
#define UINT32MAX	UINT32_MAX
#define UINT64MAX	UINT64_MAX
#endif



// The GCC docs show NORETURN after the function name, so I'm not sure that this works
PAPI			int			AbcPanicMsg(const char* file, int line, const char* msg);
PAPI NORETURN	void		AbcDie();

#define AbcAssert(f)			(void) ((f) || (AbcPanicMsg(__FILE__,__LINE__,#f), AbcDie(), 0) )			// Compiled in all builds
#define AbcVerify(f)			AbcAssert(f)																// Compiled in all builds. Different from AbcAssert to express intent, that this is logic altering.
#define AbcPanic(msg)			(void) (AbcPanicMsg(__FILE__,__LINE__,msg), AbcDie())						// Compiled in all builds
#define AbcPanicHere()			(void) (AbcPanicMsg(__FILE__,__LINE__,""), AbcDie())						// Compiled in all builds
#define AbcTodo()				(void) (AbcPanicMsg(__FILE__,__LINE__,"Not yet implemented"), AbcDie())		// Compiled in all builds

#ifdef _DEBUG
#define ABCASSERT(f) AbcAssert(f)
#else
#define ABCASSERT(f) ((void)0)
#endif

#define AbcCheckNULL( obj )					if ( !(obj) )	{ AbcPanicHere(); }
#define AbcCheckAlloc( buf )				if ( !(buf) )	{ AbcPanic("Out of memory"); }
#define AbcMemoryExhausted()				AbcPanic("Out of memory")
PAPI void* AbcMallocOrDie( size_t bytes );
PAPI void* AbcReallocOrDie( void* p, size_t bytes );


// If this returns false, then we are a headless process, for example a windows service.
// This means no user32.dll - no messagebox, etc.
PAPI bool AbcAllowGUI();
PAPI void AbcSetAllowGUI( bool allowGUI );

#ifndef ABCORE_INCLUDED_CONT_UTILS_H
#define ABCORE_INCLUDED_CONT_UTILS_H

// for std::swap, which is a very sensible function

// ---------------------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------------------
// Container Utilities.
// Specific utilities for my own STL-like containers.
// I don't like the STL much.
// ---------------------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------------------

/** Moves the item at index 'top' to position 0 of the list, and bumps everything else down.
This was created for keeping a small list of recently used items. It allows you the convenience of avoiding having
to keep a 'date' field around, and managing it's wrap-around.
**/
template< typename TVal >
void shuffle_to_top( int n, TVal* items, int itop )
{
if ( n == 0 || itop == 0 ) return;
TVal old_top = items[itop];

// bump down everything below itop
for ( int i = itop; i > 0; i-- ) items[i] = items[i - 1];

// and insert new top
items[0] = old_top;
}

template< typename TVect >
void shuffle_to_top_v( TVect& items, int itop )
{
if ( items.size() > 0 ) shuffle_to_top( items.size(), &items[0], itop );
}

/// Vector equality
template < typename TVect >
bool vect_equals( const TVect& a, const TVect& b )
{
if ( a.size() != b.size() ) return false;
for ( size_t i = 0; i < (size_t) a.size(); i++ )
if ( a[i] != b[i] ) return false;
return true;
}

// Returns the index of the first item, or -1 if not found
template <typename TVect, typename T>
int vect_indexof( const TVect& list, const T& val )
{
for ( intp i = 0; i < list.size(); i++ )
if ( list[i] == val )
return i;
return -1;
}

template<typename TVect, typename T>
void vect_insert_if_not_exist( TVect& set, const T& val )
{
if ( vect_indexof(set, val) == -1 ) set.push_back( val );
}

template<typename TVect, typename T>
void vect_erase_all_of( TVect& set, const T& val )
{
for ( intp i = set.size() - 1; i >= 0; i-- )
if ( set[i] == val )
set.erase(i);
}

template <typename TVect>
TVect vect_sum( const TVect& a, const TVect& b )
{
TVect res;
res.reserve( a.size() + b.size() );

for ( intp i = 0; i < a.size(); i++ )	res.push_back( a[i] );
for ( intp i = 0; i < b.size(); i++ )	res.push_back( b[i] );

return res;
}

/** Reverse for vector.
**/
template < typename TVect, typename TData >
void vect_reverse( TVect& target )
{
int lim = target.size() / 2;
for ( int i = 0; i < lim; i++ )
{
int j = target.size() - i - 1;
std::swap( target[i], target[j] );
}
}

// O(n^2)
template<typename TVect>
void vect_remove_duplicates( TVect& target )
{
for ( intp i = 0; i < target.size(); i++ )
{
for ( intp j = i + 1; j < target.size(); j++ )
{
if ( target[i] == target[j] )
{
target.erase(j);
j--;
}
}
}
}

/** find smallest item in a vector.
@return -1 If vector is empty, otherwise the index of the minimum value.
If there are duplicates, it will be the first instance of the minimum.
**/
template< typename TVect, typename TData >
int vect_least( const TVect& items )
{
if ( items.size() == 0 )
return -1;
TData v = items[0];
int index = 0;
for ( intp i = 0; i < items.size(); i++ )
{
if ( items[i] < v )
{
v = items[i];
index = i;
}
}
return index;
}

/** find greatest item in a vector.
@return -1 If vector is empty, otherwise the index of the maximum value.
If there are duplicates, it will be the first instance of the maximum.
**/
template< typename TVect, typename TData >
int vect_greatest( const TVect& items )
{
if ( items.size() == 0 )
return -1;
TData v = items[0];
int index = 0;
for ( intp i = 0; i < items.size(); i++ )
{
if ( v < items[i] )
{
v = items[i];
index = i;
}
}
return index;
}

template< typename TVect >
bool vect_is_sorted( const TVect& v )
{
for ( intp i = 1; i < v.size(); i++ )
{
if ( v[i] < v[i - 1] ) return false;
}
return true;
}

template< typename TData >
bool array_is_sorted( intp _size, const TData* a )
{
uintp size = _size;
for ( uintp i = 1; i < size; i++ )
{
if ( a[i] < a[i - 1] ) return false;
}
return true;
}

// SYNC-BMH-QSORT
template < typename TData >
void vect_sort_cx( TData* target, intp i, intp j, void* context, int (*compare) (void* context, const TData& a, const TData& b), int stackDepth = 0 )
{
if ( j <= i ) return;
if ( j == i + 1 )
{
// pair
if ( compare( context, target[j], target[i] ) < 0 )
std::swap( target[i], target[j] );
return;
}

// choose alternate pivot if we detect that the list is inversely sorted.
// not doing so will produce a stack overflow with even a relatively small set.
TData* pivot = target + i + ((j - i) / 2);
if ( stackDepth > 40 )
pivot = target + i + (rand() % (1 + j - i));

intp inI = i;
intp inJ = j;
i--;
j++;
while ( i < j )
{
j--;
while ( compare(context, *pivot, target[j]) < 0 && i < j )
j--;

if ( i != j )
i++;
while ( compare(context, target[i], *pivot) < 0 && i < j )
i++;

if ( i < j )
{
if ( pivot == target + i )		pivot = target + j;
else if ( pivot == target + j ) pivot = target + i;
std::swap( target[i], target[j] );
}
}
if ( inI < i )			vect_sort_cx<TData>( target, inI, i, context, compare, stackDepth + 1 );
if ( i + 1 < inJ )		vect_sort_cx<TData>( target, i + 1, inJ, context, compare, stackDepth + 1 );
}

// Wrap static TData::less_than function for use as a contexual compare() function
template< typename TData >
int less_than_2_compare( void* context, const TData& a, const TData& b )
{
return TData::less_than( a, b ) ? -1 : 0;
};

// Wrap a special TData::less_than providing class for use as a contexual compare() function
template< typename TData, typename TCompare >
int less_than_t_2_compare( void* context, const TData& a, const TData& b )
{
return TCompare::less_than( a, b ) ? -1 : 0;
};

template< typename TData >
int compare_default_contexual( void* context, const TData& a, const TData& b )
{
return a < b ? -1 : 0;
};

// We use the context to transmit the comparison function. The comparison function that the sorter
// sees is actually this function right here. This extra indirection is the price you pay for
// always supporting a context in the comparator, and also supporting context-less comparison function pointers.
template< typename TData >
int marshal_context_is_compare( void* context, const TData& a, const TData& b )
{
typedef int (*tcompare)(const TData& a, const TData& b);
return ((tcompare)context)( a, b );
};

/** Sort for vector.
TCompare is a struct/class that has a static function less_than, which
takes two argument and looks like "bool less_than(const TData& a, const TData& b)".
**/
template < typename TVect, typename TData, typename TCompare >
void vect_sort( TVect& target )
{
if ( target.size() == 0 ) return;
vect_sort_cx( &target[0], 0, target.size() - 1, NULL, &less_than_t_2_compare<TData, TCompare> );
}

template < typename TVect, typename TData >
void vect_sort( TVect& target )
{
if ( target.size() == 0 ) return;
vect_sort_cx( &target[0], 0, target.size() - 1, NULL, &less_than_2_compare<TData> );
}


template < typename TData >
void vect_sort( TData* target, int i, int j )
{
vect_sort_cx( &target[0], 0, j, NULL, &compare_default_contexual<TData> );
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Do not sort original data - sort a table that points into the original data

template<typename TData>
struct indirect_sort_context
{
const TData*	Data;
void*			OrgContext;
int				(*OrgCompare)(void* context, const TData& a, const TData& b);
};

template<typename TData, typename TOrder>
int indirect_compare( void* context, const TOrder& ia, const TOrder& ib )
{
indirect_sort_context<TData>* cx = (indirect_sort_context<TData>*) context;
return cx->OrgCompare( cx->OrgContext, cx->Data[ia], cx->Data[ib] );
}

template <typename TData, typename TOrder>
void vect_sort_indirect( const TData* target, TOrder* ordering, intp n, void* context, int (*compare) (void* context, const TData& a, const TData& b) )
{
indirect_sort_context<TData> wrappedcx;
wrappedcx.Data = target;
wrappedcx.OrgContext = context;
wrappedcx.OrgCompare = compare;

for ( TOrder k = 0; k < (TOrder) n; k++ ) ordering[k] = k;
vect_sort_cx( ordering, 0, n - 1, &wrappedcx, indirect_compare<TData,TOrder> );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Explicit half-instantiation of template utils, to reduce template ambiguity.
#define INSTANTIATE_VECTOR_FUNCTIONS(VECT) \
template <class T> VECT<T> operator+( const VECT<T>& a, const VECT<T>& b ) { return vect_sum< VECT<T> >(a, b); } \
\
template<typename TData>	void	reverse( VECT<TData>& target )					{ vect_reverse< VECT<TData>, TData >( target ); } \
template<typename TData>	int		greatest( const VECT<TData>& target )			{ return vect_greatest<VECT<TData>, TData>( target ); } \
template<typename TData>	int		least( const VECT<TData>& target )				{ return vect_least<VECT<TData>, TData>( target ); } \
template<typename TData>	void	remove_duplicates( const VECT<TData>& target )	{ return vect_remove_duplicates< VECT<TData> >( target ); } \
template<typename TData>	bool	is_sorted( const VECT<TData>& target )			{ return vect_is_sorted< VECT<TData> >( target ); } \
\
template<typename TData, typename TCompare>	void sort( VECT<TData>& target )					{ vect_sort_cx( target.data, 0, target.size() - 1, NULL, &less_than_t_2_compare<TData, TCompare> ); }\
template<typename TData>					void sort( VECT<TData>& target )					{ vect_sort_cx( target.data, 0, target.size() - 1, NULL, &compare_default_contexual<TData> ); }\
template<typename TData>					void sort( VECT<TData>& target, intp i, intp j )	{ vect_sort_cx( target.data, i, j, NULL, &compare_default_contexual<TData> ); }\
template<typename TData, typename TCompare>	void sort( VECT<TData>& target, intp i, intp j )	{ vect_sort_cx( target.data, i, j, NULL, &less_than_t_2_compare<TData, TCompare> ); }\
template<typename TData>					void sort( VECT<TData>& target, int (*compare) (const TData& a, const TData& b) )							{ vect_sort_cx( target.data, 0, target.size() - 1, compare, marshal_context_is_compare<TData> ); }\
template<typename TData>					void sort( VECT<TData>& target, void* context, int (*compare) (void* cx, const TData& a, const TData& b) ) { vect_sort_cx( target.data, 0, target.size() - 1, context, compare ); } \
template<typename TData, typename TOrder>	void sort_indirect( VECT<TData>& target, TOrder* ordering, void* context, int (*compare) (void* cx, const TData& a, const TData& b) ) { vect_sort_indirect( target.data, ordering, target.size(), context, compare ); }



#endif

#ifndef ABCORE_INCLUDED_PVECT_H
#define ABCORE_INCLUDED_PVECT_H

// Pointer to <> classes, without necessary compiler support for template specialization
// Note that all functions take "intp" values, but internally we store 32-bit integers.
// Should the day arrive when we need to store more than 4g items, then we'll change.


#ifndef PVECT_DECL_SPEC
#define PVECT_DECL_SPEC
#endif

//#define PVECT_RANGE_CHECK 1

#define PVINT int

class PVECT_DECL_SPEC pvoidvect
{
public:
// These data members are made public here so that the vector can be used as a plain array.
void**	data;
PVINT	count;
PVINT	capacity;

pvoidvect()
{
count = 0;
capacity = 0;
data = NULL;
}
explicit pvoidvect(intp _reserve)
{
count = 0;
capacity = 0;
data = NULL;
reserve(_reserve);
}

// copy constructor
pvoidvect(const pvoidvect& b)
{
data = NULL;
capacity = 0;
count = 0;
if (b.count > 0)
{
reserve(b.count);
// The data != NULL check is superfluous, but necessary to satisfy the VS 2012 static analyzer
if (data != NULL)
memcpy(data, b.data, sizeof(void*)*b.count);
}
count = b.count;
}

~pvoidvect()
{
if (data)
delete []data;
}

void hack( intp _count, intp _capacity, void** _data )
{
count = PVINT(_count);
capacity = PVINT(_capacity);
data = _data;
}

pvoidvect& operator=(const pvoidvect &b)
{
if ( this != &b )
{
if ( b.count != capacity ) clear();
if ( b.count > 0 )
{
reserve(b.count);
memcpy(data, b.data, sizeof(void*)*b.count);
}
count = b.count;
}
return *this;
}

bool operator==( const pvoidvect& b ) const
{
if ( count != b.count ) return false;
for ( PVINT i = 0; i < count; i++ )
if ( data[i] != b.data[i] ) return false;
return true;
}
bool operator!=( const pvoidvect& b ) const { return !(*this == b); }

// safe set. Will resize if necessary
void set(intp _pos, const void* a)
{
PVINT pos = PVINT(_pos);
if (pos >= count)
{
// Do we need to resize, or can we just up our count?
if (pos >= capacity)
resize(pos+1);
else
count = pos+1;
}
data[pos] = const_cast<void*>(a);
}

void insert(intp _pos, const void* a)
{
PVINT pos = PVINT(_pos);
if (pos >= capacity || count+1 > capacity)
reserve(_MAX_(capacity*2, pos+4));
PVINT nmove = count - pos;
if (nmove > 0)
memmove(&(data[pos+1]), &(data[pos]), nmove*sizeof(void*));
data[pos] = const_cast<void*>(a);
count++;
}

void erase(intp _pos1, intp _pos2 = -1)
{
PVINT pos1 = PVINT(_pos1);
PVINT pos2 = PVINT(_pos2);
if ( pos2 == -1 )			pos2 = pos1;
else if ( pos2 >= count )	pos2 = count -1;
ASSERT( pos1 >= 0 && pos1 <= pos2 );

PVINT nmove = (count - pos2) - 1;
if (nmove > 0)
memmove(&(data[pos1]), &(data[pos2+1]), nmove*sizeof(void*));
count -= 1 + (pos2 - pos1);
}

// Grift.... this causes no problems because we know that a void* is only 4 bytes.
void* pop_back()
{
if (count > 0)
count--;
return data[count];
}

void push_back(const void* a)
{
if (count >= capacity)
reserve( _MAX_(capacity*2, 2) );
data[count++] = const_cast<void*>(a);
}

#ifdef PVECT_RANGE_CHECK
const void* operator[](intp _i) const
{
PVINT i = PVINT(_i);
ASSERT( i >= 0 && i < count );
return data[_i];
}
#else
const void* operator[](intp _i) const { return data[_i]; }
#endif

#ifdef PVECT_RANGE_CHECK
void*& operator[](intp _i)
{
PVINT i = PVINT(_i);
ASSERT( i >= 0 && i < count );
return data[_i];
}
#else
void*& operator[](intp _i) { return data[_i]; }
#endif

void addn( intp n, void** p )
{
for ( intp i = 0; i < n; i++ ) push_back(p[i]);
}

void* front() const
{
return data[0];
}
void*& front()
{
return data[0];
}

void* back() const
{
return data[count-1];
}
void*& back()
{
return data[count-1];
}

bool contains( const void* t ) const { return find(t) != -1; }

// returns -1 on failure
intp find( const void* t ) const
{
for ( PVINT i = 0; i < count; i++ )
if ( data[i] == t ) return i;
return -1;
}

void nullfill()
{
for ( PVINT i = 0; i < count; i++ )
data[i] = NULL;
}

void clear()
{
delete[] data;
data = NULL;
count = 0;
capacity = 0;
}

// frees our heap storage and sets data to null (but does not touch capacity or count)
void dealloc()
{
delete[] data;
data = NULL;
}

// can be used to avoid reallocs
void clear_noalloc()
{
count = 0;
}

intp size() const { return count; }

// preserves existing entities but doesn't set count
void reserve( intp _newsize )
{
PVINT newsize = PVINT(_newsize);
if ( newsize <= capacity ) return;
PVINT oc = count;
resize(_MAX_(newsize, count));
count = oc;
}
// preserves existing entities and sets count to newsize
// does not realloc unless size is larger than existing capacity
void resize( intp newsize )
{
if ( newsize > capacity )
{
void** nd = new void*[newsize];
if (count > 0)
memcpy( nd, data, sizeof(void*) * count );
delete []data;
data = nd;
capacity = (PVINT) newsize;
}
count = (PVINT) newsize;
}

protected:
void add( const pvoidvect& a )
{
for ( PVINT i = 0; i < a.count; i++ )
push_back( a[i] );
}

template<typename TYPE> TYPE _MAX_( TYPE a, TYPE b ) { return a < b ? b : a; }
};


template < class T > class PVECT_DECL_SPEC pvect : public pvoidvect
{
public:
typedef pvoidvect	Base;
typedef T			TElem;

pvect() : Base() {}

explicit pvect(intp reserve) : Base(reserve) {}

pvect(const pvect& b) : Base(b) {}

pvect& operator=(const pvect &b) { return (pvect&) Base::operator=(b); }

bool operator==( const pvoidvect& b ) const { return Base::operator==(b); }
bool operator!=( const pvoidvect& b ) const { return Base::operator!=(b); }

void set(intp pos, const T a) { Base::set(pos, (const void*) a); }

void insert(intp pos, const T a) { Base::insert(pos, (const void*) a); }

void erase(intp pos1, intp pos2 = -1) { Base::erase(pos1, pos2); }

T pop_back()	{ return static_cast<T>(Base::pop_back()); }
T pop()			{ return static_cast<T>(Base::pop_back()); }

void push_back( const T a ) { Base::push_back( (const void*) a ); }

void addn( intp n, const T* p ) { Base::addn(n, (void**) p); }

pvect& operator+=( const T a ) { push_back( a ); return *this; }

pvect& operator+=( const pvect& a ) { add( a ); return *this; }

//const T operator[](intp i) const { return static_cast<const T>(Base::operator[](i)); }
const T operator[](intp i) const { return (const T) Base::operator[](i); }

T& operator[](intp i) { return (T&) Base::operator[](i); }

// sometimes it's not pretty to force a dereference in order to use operator[]
//const T get(intp i) const { return static_cast<const T>(Base::operator[](i)); }
const T get(intp i) const { return (const T) Base::operator[](i); }

T& get(intp i) { return (T&) Base::operator[](i); }

const T back() const { return (const T) Base::back(); }
T& back() { return (T&) Base::back(); }

const T front() const { return (const T) Base::front(); }
T& front() { return (T&) Base::front(); }

intp find( const T a ) const { return Base::find((const void*) a); }

void clear() { Base::clear(); }

// deletes void* storage, but does not call destructor.
void dealloc() { Base::dealloc(); }

void nullfill() { Base::nullfill(); }

intp size() const { return Base::size(); }

void reserve(intp newsize) { Base::reserve(newsize); }

void resize(intp newsize) { Base::resize(newsize); }
};

/** erase and delete for pvect
**/
template < typename TData >
void erase_delete( pvect<TData>& target, intp pos1, intp pos2 = -1 )
{
if ( pos2 == -1 )						pos2 = pos1;
else if ( pos2 >= target.count )		pos2 = target.count - 1;
ASSERT( pos1 >= 0 && pos1 <= pos2 );
for ( intp i = pos1; i <= pos2; i++ )
delete target[i];
target.erase( pos1, pos2 );
}

/** clear and delete all for pvect.
**/
template < typename TData >
void delete_all( pvect<TData>& target )
{
for ( intp i = 0; i < target.size(); i++ )
delete target[i];
target.clear();
}

/** concatenation for pvect.
**/
template < typename TData >
pvect<TData> operator+( const pvect<TData>& a, const pvect<TData>& b )
{
pvect<TData> c = a;
c += b;
return c;
}

/** Reverse for pvect.
**/
template < typename TData >
void reverse( pvect<TData>& target )
{
intp lim = target.size() / 2;
for ( intp i = 0; i < lim; i++ )
{
intp j = target.size() - i - 1;
TData tt = target[i];
target[i] = target[j];
target[j] = tt;
}
}

// Sort for pvect.
// These have to be custom written so that they can dereference the objects inside the pvect.

template <typename T> int pvect_compare_operator_lt( void* context, const T& a, const T& b )
{
return *a < *b ? -1 : 0;
}

// See marshal_context_is_compare in cont_utils.h for an explanation.
// We do the extra work of dereferencing
template <typename T>
int pvect_marshal_context_is_compare( void* context, const T& a, const T& b )
{
// It's easier to go from T* to TType than the other way around.
typedef decltype(*a) TType;
typedef int (*tcompare)(const TType& a, const TType& b);
return ((tcompare) context)( *a, *b );
}

struct pvect_double_context
{
void* Context;
void* Compare;
};

// We need two levels of indirection because we need to perform the dereference first
template <typename T>
int pvect_double_marshal_context_is_compare( void* context, const T& a, const T& b )
{
// save decltype() technique as above
typedef decltype(*a) TType;
typedef int (*tcompare)(void* context, const TType& a, const TType& b);

pvect_double_context* cxA = (pvect_double_context*) context;

return ((tcompare) cxA->Compare)( cxA->Context, *a, *b );
}

template <typename T> void sort( pvect<T*>& target )
{
vect_sort_cx<T*>( &target[0], 0, target.size() - 1, NULL, pvect_compare_operator_lt<T*> );
}

template <typename T> void sort( pvect<T*>& target, int (*compare) (const T& a, const T& b) )
{
vect_sort_cx<T*>( &target[0], 0, target.size() - 1, (void*) compare, pvect_marshal_context_is_compare<T*> );
}

template <typename T> void sort( pvect<T*>& target, void* context, int (*compare) (void* context, const T& a, const T& b) )
{
// double-trouble!
pvect_double_context cxA;
cxA.Compare = (void*) compare;
cxA.Context = context;
vect_sort_cx<T*>( &target[0], 0, target.size() - 1, &cxA, pvect_double_marshal_context_is_compare<T*> );
}

// Returns a copy of the pvect, sorted based on your comparison function
template< typename T >
pvect<T*> sorted_by( const pvect<T*>& unsorted, int (*compare) (const T& a, const T& b) )
{
pvect<T*> all = unsorted;
sort( all, compare );
return all;
}


template < typename TData >
void sort_insertion( pvect<TData>& target )
{
sort_insertion( target, 0, target.size() - 1 );
}

/** Very simple insertion sort for pvect.
The idea behind this is to avoid generating all the code needed for qsort,
when only a very simple sort for a tiny set is required.
**/
template < typename TData >
void sort_insertion( pvect<TData>& target, intp i, intp j )
{
pvect<TData> rep;
for ( intp k = i; k <= j; k++ )
{
TData a = target[k];
intp q;
for ( q = 0; q < rep.size(); q++ )
{
if ( *a < *rep[q] )
{
rep.insert( q, a );
break;
}
}
if ( q == rep.size() )
rep.push_back( a );
}
for ( intp k = i, s = 0; k <= j; k++, s++ )
target[k] = rep[s];
}

/** Generic sort item.
Most custom sorts can be made using the following structure that has
for it's template argument either a string, float, or integer.
The idea is that you use these to reduce bloat.
**/
template< typename ST >
struct sort_item
{
ST Key;
void* Object;
bool operator< ( const sort_item& b ) const
{
return Key < b.Key;
}
};


template< typename TData >
intp least( const pvect<TData>& items )
{
if ( items.size() == 0 ) { ASSERT(false); return -1; }
TData v = items[0];
intp index = 0;
for ( intp i = 0; i < items.size(); i++ )
{
if ( *items[i] < *v )
{
v = items[i];
index = i;
}
}
return index;
}

template< typename TData >
intp greatest( const pvect<TData>& items )
{
if ( items.size() == 0 ) { ASSERT(false); return -1; }
TData v = items[0];
intp index = 0;
for ( intp i = 0; i < items.size(); i++ )
{
if ( *v < *items[i] )
{
v = items[i];
index = i;
}
}
return index;
}

template<typename TData> void remove_duplicates( pvect<TData>& target )	{ return vect_remove_duplicates( target ); }


#undef PVINT
#endif



#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4345)	// POD type is default-initialized with () syntax
#endif


/*

This is a cut-down vector<>, but built for types that adhere to a specific protocol.

Benefits of using podvec:
* Memory move semantics. If you are storing a vector of XString objects, and the vector needs to grow,
then we don't need to realloc memory for the content of all those XString objects. Because we simply do a
memcpy, we avoid that.
This functionality is what you get from C++11 rvalue references, except we do it here without all
that pain - and this was written before C++11 was born.

Requirements for types for which podvec_ispod() is false:
1. A zero fill must initialize the object.
2. Nobody (including the class itself) may store internal pointers to the object. We need to be able to move objects around.
3. The destructor must be a no-op when the object has been zero-initialized. Whenever podvec needs to destroy an object,
it explicitly calls its destructor, and then does a memset(0) on the contents of the object's memory. This sequence
of events must leave the object in its initialized state (which is the same as constraint #1).
4. No support for polymorphic classes. That is anything with a virtual function (including a virtual destructor).

Additional requirements for types for which podvec_ispod() is true:
5. No constructor necessary.
6. No destructor necessary.
7. The object can be copied with memcpy. ie. The object doesn't "own" any pointers. A string is an example of a type
that violates this constraint, because if you memcpy'd a string into the vector, then you would end up with two
strings pointing to the same block of memory, and that memory would eventually be freed twice.

The lack of protected data members (count,capacity,data) makes it a little easier to deal with
when all you want is a managed array.

podvec_ispod() is opt-in, because the requirements are stricter.

Accessors and size() are signed pointer-sized, because historically I use "for (int i = 0; i < v.size(); i++)", and I don't want to break all of that
by littering signed/unsigned comparison warnings -- which is a warning always worth heeding.

In addition, signed comparisons are generally more robust, because you don't wrap around under zero.

Internally we store unsigned pointer-sized integers.
*/

template<typename T> bool podvec_ispod() { return false; }

template<typename T>
struct podvec
{
typedef T TElem;

uintp	count;
uintp	capacity;
T*		data;

static bool ispod()				{ return podvec_ispod<T>(); }
static void panic()				{ AbcPanicHere(); }

podvec()
{
construct();
}
podvec( const podvec& b )
{
construct();
*this = b;
}
podvec( std::initializer_list<T> list )
{
construct();
if ( ispod() )
{
resize_uninitialized( list.size() );
memcpy( data, list.begin(), sizeof(T) * list.size() );
}
else
{
resize( list.size() );
for ( size_t i = 0; i < list.size(); i++ )
data[i] = list.begin()[i];
}
}

~podvec()
{
clear();
}

void hack( intp _count, intp _capacity, T* _data )
{
count = _count;
capacity = _capacity;
data = _data;
}

intp size() const { return count; }

// We are consistent here with the stl's erase, which takes [start,last), where last is one beyond the last element to erase.
void erase( intp _start, intp _end = -1 )
{
uintp start = _start;
uintp end = _end;
if ( end == -1 ) end = start + 1;
if ( start == end ) return;			// on an empty set, you must be able to do erase(0,0), and have it be a nop
if ( start >= count )	panic();	// erase is rare enough that I feel it's worth it to pay this branch penalty for an early crash.
if ( end > count )		panic();
uintp remain = count - end;
for ( uintp i = start; i < end; i++ ) dtor( data[i] );
memmove( data + start, data + end, remain * sizeof(T) );
memset( data + start + remain, 0, (end - start) * sizeof(T) );
count = start + remain;
}

// written originally for adding bytes to a podvec<u8>. Will grow the buffer in powers of 2.
void addn( const T* arr, intp _n )
{
if ( isinternal(arr) ) panic();
uintp n = _n;
if ( count + n > capacity ) growfor( count + n );
if ( ispod() )	{ memcpy( data + count, arr, n * sizeof(T) ); count += n; }
else			{ for ( uintp i = 0; i < n; i++ ) data[count++] = arr[i]; }
}

T& add()
{
push( T() );
return back();
}

void resize( intp _inewsize )
{
resize_internal( _inewsize, true );
}

// This is intended to be the equivalent of a raw malloc(), for the cases where you don't
// want to pay the cost of zero-initializing the memory that you're about to fill up anyway.
void resize_uninitialized( intp _inewsize )
{
resize_internal( _inewsize, false );
}

void reserve( intp _newcap )
{
uintp newcap = _newcap;
if ( newcap <= count ) return;		// resize may not alter count, therefore we do nothing in this case
resizeto( newcap, true );
}

// This is intended to be the equivalent of a raw malloc(), for the cases where you don't
// want to pay the cost of zero-initializing the memory that you're about to fill up anyway.
void reserve_uninitialized( intp _newcap )
{
uintp newcap = _newcap;
if ( newcap <= count ) return;		// resize may not alter count, therefore we do nothing in this case
resizeto( newcap, false );
}

intp remaining_capacity() const
{
return capacity - count;
}

void fill( const T& v )
{
for ( uintp i = 0; i < count; i++ )
data[i] = v;
}

void insert( intp _pos, const T& v )
{
uintp pos = _pos;
if ( pos > count ) panic();
if ( isinternal(&v) )
{
T copy = v;
grow();
if ( count != capacity ) dtorz_block( 1, data + count );
memmove( data + pos + 1, data + pos, (count - pos) * sizeof(T) );
//memset( data + pos, 0, sizeof(T) );
ctor( data[pos] );
data[pos] = copy;
}
else
{
grow();
if ( count != capacity ) dtorz_block( 1, data + count );
memmove( data + pos + 1, data + pos, (count - pos) * sizeof(T) );
//memset( data + pos, 0, sizeof(T) );
ctor( data[pos] );
data[pos] = v;
}
count++;
}

void	push_back( const T& v )	{ push(v); }
void	pop_back()				{ count--; }
void	pop()					{ pop_back(); }
T		rpop()					{ T v = back(); pop(); return v; }

void push( const T& v )
{
if ( count == capacity )
{
if ( isinternal(&v) )
{
// aliased
T copy = v;
grow();
data[count++] = copy;
}
else
{
grow();
data[count++] = v;
}
}
else data[count++] = v;
}

void clear_noalloc() { count = 0; }
void clear()
{
for ( uintp i = 0; i < capacity; i++ ) dtor(data[i]);
free(data);
data = NULL;
count = capacity = 0;
}

intp		find( const T& v ) const		{ for ( uintp i = 0; i < count; i++ ) if (data[i] == v) return i; return -1; }
bool		contains( const T& v ) const	{ return find(v) != -1; }

T&			get( intp i )					{ return data[i]; }
const T&	get( intp i ) const				{ return data[i]; }
void		set( intp i, const T& v )		{ data[i] = v; }

T&			operator[]( intp i )			{ return data[i]; }
const T&	operator[]( intp i ) const		{ return data[i]; }

T&			front()							{ return data[0]; }
const T&	front() const					{ return data[0]; }
T&			back()							{ return data[count-1]; }
const T&	back() const					{ return data[count-1]; }

void operator+=( const T& v )			{ push(v); }
void operator+=( const podvec& b )		{ addn( b.data, b.count ); }

void operator=( const podvec& b )
{
if ( count != b.count )
{
clear();
resizeto( b.count, !ispod() );
}
count = b.count;
if ( ispod() )	{ memcpy( data, b.data, count * sizeof(T) ); }
else			{ for ( uintp i = 0; i < b.count; i++ ) data[i] = b.data[i]; }
}

void grow() { growfor( count + 1 ); }

protected:
void construct()
{
count = capacity = 0;
data = NULL;
}
void dtor( T& v )
{
if ( !ispod() )
v.T::~T();
}
void dtorz_block( uintp n, T* block )
{
if ( ispod() ) return;
for ( uintp i = 0; i < n; i++ )
block[i].T::~T();
memset( block, 0, sizeof(T) * n );
}
void ctor( T& v )
{
//if ( ispod() )
//	memset( &v, 0, sizeof(T) );
//else
//	new (&v) T();
// On debug builds the memset is awful
new (&v) T();
}
void ctor_block( uintp n, T* block )
{
if ( ispod() )
memset( block, 0, sizeof(T) * n );
else
{
for ( uintp i = 0; i < n; i++ )
new (&block[i]) T();
}
}

bool isinternal( const T* p ) const
{
return (uintp) (p - data) < capacity;
}

void growfor( uintp target )
{
// Regular growth rate is 2.0, which is what most containers (.NET, STL) use.
// There is no theoretical optimal. It's simply a trade-off between memcpy time and wasted VM.
uintp ncap = capacity ? capacity : 1;
while ( ncap < target )
ncap = ncap * 2;
if ( !try_resizeto( ncap, true ) )
{
/* Special out of memory behaviour when growing the vector.
When realloc fails, we try again to grow at a rate of 1.25 instead of our regular exponent of 2.
The exponent 1.25 is a thumbsuck. There is no theoretically optimal behaviour here.
This is only intended to save users when arrays are in the range of around 500MB or so, on a 32-bit machine.
In this type of scenario, moving from 500 to 562 is better than 500 to 1000.
Trying to recover from out of memory conditions is a dubious game. It's not worth it to try
too hard, because the user is likely going to run out in the near future in a place where
a realloc fail is not recoverable.
*/
ncap = capacity;
if ( ncap < 4 ) ncap = 4;
while ( ncap < target )
ncap = ncap + ncap / 4;
if ( !try_resizeto( ncap, true ) )
AbcMemoryExhausted();
}
}

void resize_internal( uintp newsize, bool initmem )
{
if ( newsize == count ) return;
if ( newsize == 0 )		{ clear(); return; }
if ( newsize < capacity ) dtorz_block( capacity - (uintp) newsize, data + newsize );
resizeto( newsize, initmem );
count = newsize;
}

void resizeto( uintp newcap, bool initmem )
{
if ( !try_resizeto( newcap, initmem ) )
AbcMemoryExhausted();
}

bool try_resizeto( uintp newcap, bool initmem )
{
if ( newcap == 0 )
return true;
T* newdata = (T*) realloc( data, newcap * sizeof(T) );
if ( newdata == NULL )
return false;
data = newdata;
if ( newcap > capacity && initmem )
{
//memset( data + capacity, 0, (newcap - capacity) * sizeof(T) );
ctor_block( newcap - capacity, data + capacity );
}
capacity = newcap;
return true;
}

const T* pbegin()	const { return data; }
const T* pend()		const { return data + capacity; }
};

template < typename T >
void delete_all( podvec<T>& target )
{
for ( intp i = 0; i < target.size(); i++ ) delete target[i];
target.clear();
}

template<typename T>
bool operator==( const podvec<T>& a, const podvec<T>& b )
{
uintp asize = a.size();
if ( asize != b.size() ) return false;
for ( uintp i = 0; i < asize; i++ )
{
if ( a.data[i] != b.data[i] ) return false;
}
return true;
}
template<typename T>
bool operator!=( const podvec<T>& a, const podvec<T>& b )
{
return !(a == b);
}

template<> inline bool podvec_ispod<int8>()		{ return true; }
template<> inline bool podvec_ispod<int16>()	{ return true; }
template<> inline bool podvec_ispod<int32>()	{ return true; }
template<> inline bool podvec_ispod<int64>()	{ return true; }
template<> inline bool podvec_ispod<uint8>()	{ return true; }
template<> inline bool podvec_ispod<uint16>()	{ return true; }
template<> inline bool podvec_ispod<uint32>()	{ return true; }
template<> inline bool podvec_ispod<uint64>()	{ return true; }
template<> inline bool podvec_ispod<float>()	{ return true; }
template<> inline bool podvec_ispod<double>()	{ return true; }

template<> inline bool podvec_ispod<bool>()		{ return true; }
template<> inline bool podvec_ispod<void*>()	{ return true; }

namespace std
{
template<typename T> inline void swap( podvec<T>& a, podvec<T>& b )
{
char tmp[sizeof(podvec<T>)];
memcpy( tmp, &a, sizeof(a) );
memcpy( &a, &b, sizeof(a) );
memcpy( &b, tmp, sizeof(a) );
}
}

INSTANTIATE_VECTOR_FUNCTIONS(podvec)

#ifdef _MSC_VER
#pragma warning(pop)
#endif



struct AbcMachineInformation
{
int		PhysicalCoreCount;	// On linux this is wrong, and simply equal to LogicalCoreCount
int		LogicalCoreCount;
uint64	PhysicalMemory;
};

PAPI void				AbcMachineInformationGet( AbcMachineInformation& info );
PAPI uint64				AbcPhysicalMemory(); // Wrapper around AbcMachineInformationGet()



#ifdef _WIN32
typedef DWORD					AbcProcessID;
typedef HANDLE					AbcForkedProcessHandle;
#else
typedef pid_t					AbcProcessID;
typedef FILE*					AbcForkedProcessHandle;
#endif

struct AbcProcessStatistics
{
uint64	UserCpuTimeMicroseconds;
uint64	KernelCpuTimeMicroseconds;
uint64	WorkingSetBytes;			// On linux, this is the same as MaxWorkingSetBytes
uint64	MaxWorkingSetBytes;
uint64	AddressSpaceCommittedBytes;	// I don't know how to get this number for linux, so it is always zero on linux.
};

PAPI bool				AbcProcessCreate( const char* cmd, AbcForkedProcessHandle* handle, AbcProcessID* pid );
PAPI bool				AbcProcessWait( AbcForkedProcessHandle handle, int* exitCode );
PAPI void 				AbcProcessCloseHandle( AbcForkedProcessHandle handle );
PAPI AbcProcessID		AbcProcessGetPID();
PAPI void				AbcProcessGetPath( char* path, size_t maxPath );		// Return full path of executing process, for example "c:\programs\notepad.exe"
#ifdef XSTRING_DEFINED
PAPI XString			AbcProcessGetPath();									// Return full path of executing process, for example "c:\programs\notepad.exe"
#endif
PAPI void				AbcProcessesEnum( podvec<AbcProcessID>& pids );
PAPI void				AbcProcessGetStatistics( AbcProcessStatistics& stats );
PAPI uint64				AbcProcessWorkingSetBytes();							// wrapper around AbcProcessGetStatistics. On linux, this is the same as AbcProcessMaxWorkingSetBytes().
PAPI uint64				AbcProcessMaxWorkingSetBytes();							// wrapper around AbcProcessGetStatistics
PAPI uint64				AbcProcessVirtualCommittedBytes();						// wrapper around AbcProcessGetStatistics. Only supported on Win32. Returns 0 on any other OS.



/*
Declare a thread function as follows:
AbcThreadReturnType AbcKernelCallbackDecl MyFunction( void* threadContext )

*/

#ifdef _WIN32
typedef HANDLE					AbcThreadHandle;
typedef DWORD					AbcThreadID;			// Use AbcThreadEqual to compare for equality
typedef DWORD					AbcThreadReturnType;
typedef LPTHREAD_START_ROUTINE	AbcThreadFunc;
#define AbcKernelCallbackDecl	WINAPI
#else
typedef pthread_t				AbcThreadHandle;
typedef pthread_t				AbcThreadID;			// Use AbcThreadEqual to compare for equality
typedef void*					AbcThreadReturnType;
typedef void* (*AbcThreadFunc)(void*);
#define AbcKernelCallbackDecl
#endif

// All of these are currently ignored on linux
enum AbcThreadPriority
{
AbcThreadPriorityIdle,
AbcThreadPriorityNormal,
AbcThreadPriorityHigh,
AbcThreadPriorityBackgroundBegin,
AbcThreadPriorityBackgroundEnd,
};

PAPI bool				AbcThreadCreate( AbcThreadFunc threadfunc, void* context, AbcThreadHandle& handle );
PAPI bool				AbcThreadJoin( AbcThreadHandle handle );
PAPI bool				AbcThreadJoinAndCloseHandle( AbcThreadHandle handle );
PAPI void				AbcThreadCloseHandle( AbcThreadHandle handle );
PAPI AbcThreadHandle	AbcThreadCurrent();
PAPI AbcThreadID		AbcThreadCurrentID();
PAPI bool				AbcThreadIDEqual( AbcThreadID a, AbcThreadID b );
// This is currently a no-op on linux
PAPI void				AbcThreadSetPriority( AbcThreadHandle handle, AbcThreadPriority priority );



#ifndef _WIN32
#endif

// We need to include "thread.h" for AbcGuardedCriticalSection::ThreadID

#ifdef _WIN32
typedef HANDLE					AbcMutex;
typedef CRITICAL_SECTION		AbcCriticalSection;
typedef HANDLE					AbcSemaphore;
#define AbcINFINITE				INFINITE
#else
typedef pthread_mutex_t			AbcMutex;
typedef pthread_mutex_t			AbcCriticalSection;
typedef sem_t					AbcSemaphore;
#define AbcINFINITE				-1
#endif

// A Windows CRITICAL_SECTION is re-enterable, but a pthread_mutex_t is not.
// This structure allows us to verify that Windows code is not re-entering.
struct AbcGuardedCriticalSection
{
AbcCriticalSection	CS;			// This must be first. TakeCriticalSection assumes this is true.
AbcThreadID			ThreadID;

bool				DebugIsInside() const	// This is not MT safe, but can be useful for debugging
{
return ThreadID == AbcThreadCurrentID();
}
};

PAPI void				AbcMutexCreate( AbcMutex& mutex, const char* name );
PAPI void				AbcMutexDestroy( AbcMutex& mutex );
PAPI bool				AbcMutexWait( AbcMutex& mutex, DWORD waitMS );
PAPI void				AbcMutexRelease( AbcMutex& mutex );

// On Windows CRITICAL_SECTION is re-enterable, but not so on linux (where we use a pthread mutex).
// So don't write re-entering code.
// This is a good principle to abide by regardless of your platform: http://cbloomrants.blogspot.com/2012/06/06-19-12-two-learnings.html
PAPI void				AbcCriticalSectionInitialize( AbcCriticalSection& cs, unsigned int spinCount = 0 );
PAPI void				AbcCriticalSectionInitialize( AbcGuardedCriticalSection& cs, unsigned int spinCount = 0 );
PAPI void				AbcCriticalSectionDestroy( AbcCriticalSection& cs );
PAPI void				AbcCriticalSectionDestroy( AbcGuardedCriticalSection& cs );
PAPI bool				AbcCriticalSectionTryEnter( AbcCriticalSection& cs );
PAPI void				AbcCriticalSectionEnter( AbcCriticalSection& cs );
PAPI void				AbcCriticalSectionLeave( AbcCriticalSection& cs );

PAPI void				AbcSemaphoreInitialize( AbcSemaphore& sem );
PAPI void				AbcSemaphoreDestroy( AbcSemaphore& sem );
PAPI bool				AbcSemaphoreWait( AbcSemaphore& sem, DWORD waitMS );
// On linux we can only release one semaphore at a time, so the 'count' > 1 is not atomic.
// Be careful not to architect your applications around that assumption.
// Also, this operation is O(count) on linux.
PAPI void				AbcSemaphoreRelease( AbcSemaphore& sem, DWORD count );

PAPI void				AbcSleep( int milliseconds );

// Use AbcPause() inside a spinlock: http://x86.renejeschke.de/html/file_module_x86_id_232.html
#ifdef _MSC_VER
#define 				AbcPause()		YieldProcessor()
#else
#define					AbcPause()		asm volatile("pause\n": : :"memory")
#endif

PAPI int				AbcLockFileLock( const char* path );	// Creates a 1 byte file and locks that 1 byte region. Returns -1 on failure. Does not block.
PAPI void				AbcLockFileRelease( int f );			// Releases a lockfile created with AbcLockFileLock

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// TODO: Get rid of these functions, and replace them with mintomic
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// AbcInterlockedAdd		returns the PREVIOUS value
// AbcInterlockedOr			returns the PREVIOUS value
// AbcInterlockedAnd		returns the PREVIOUS value
// AbcInterlockedIncrement	returns the NEW value
// AbcInterlockedDecrement	returns the NEW value
// AbcCmpXChg				returns the PREVIOUS value
#ifdef _WIN32
inline void			AbcInterlockedSet( volatile unsigned int* p, int newval )				{ _InterlockedExchange( (volatile long*) p, (long) newval ); }
inline unsigned int	AbcInterlockedAdd( volatile unsigned int* p, int addval )				{ return (unsigned int) _InterlockedExchangeAdd( (volatile long*) p, (long) addval ); }
inline unsigned int	AbcInterlockedOr( volatile unsigned int* p, int orval )					{ return (unsigned int) _InterlockedOr( (volatile long*) p, (long) orval ); }
inline unsigned int	AbcInterlockedAnd( volatile unsigned int* p, int andval )				{ return (unsigned int) _InterlockedAnd( (volatile long*) p, (long) andval ); }
inline unsigned int	AbcInterlockedXor( volatile unsigned int* p, int xorval )				{ return (unsigned int) _InterlockedXor( (volatile long*) p, (long) xorval ); }
inline void			AbcSetWithRelease( volatile unsigned int* p, int newval )				{ *p = newval; _WriteBarrier(); }
inline unsigned int	AbcCmpXChg( volatile unsigned int* p, int newval, int oldval )			{ return _InterlockedCompareExchange( (volatile long*) p, (long) newval, (long) oldval ); }
inline unsigned int	AbcInterlockedIncrement( volatile unsigned int* p )						{ return (unsigned int) _InterlockedIncrement( (volatile long*) p ); }
inline unsigned int	AbcInterlockedDecrement( volatile unsigned int* p )						{ return (unsigned int) _InterlockedDecrement( (volatile long*) p ); }
#else
// Clang has __sync_swap(), which is what you want here when compiling with Clang
// #	ifdef ANDROID
// //inline void			AbcInterlockedSet( volatile unsigned int* p, int newval )				{ __atomic_swap( newval, (volatile int*) p ); }
// //inline void			AbcSetWithRelease( volatile unsigned int* p, int newval )				{ __atomic_store_n( p, newval, __ATOMIC_RELEASE ); }
// inline void			AbcInterlockedSet( volatile unsigned int* p, int newval )				{ *p = newval; }
// inline void			AbcSetWithRelease( volatile unsigned int* p, int newval )				{ *p = newval; __sync_synchronize(); }
// inline unsigned int AbcCmpXChg( volatile unsigned int* p, int newval, int oldval )			{ return __sync_val_compare_and_swap( p, oldval, newval ); }
// #	elif __GNUC__
inline void			AbcInterlockedSet( volatile unsigned int* p, int newval )				{ *p = newval; }
inline unsigned int	AbcInterlockedAdd( volatile unsigned int* p, int addval )				{ return __sync_fetch_and_add( p, addval ); }
inline unsigned int	AbcInterlockedOr( volatile unsigned int* p, int orval )					{ return __sync_fetch_and_or( p, orval ); }
inline unsigned int	AbcInterlockedAnd( volatile unsigned int* p, int andval )				{ return __sync_fetch_and_and( p, andval ); }
inline unsigned int	AbcInterlockedXor( volatile unsigned int* p, int xorval )				{ return __sync_fetch_and_xor( p, xorval ); }
inline void			AbcSetWithRelease( volatile unsigned int* p, int newval )				{ *p = newval; __sync_synchronize(); } // I think there is a better implementation of this, using __sync_lock_test_and_set followed by __sync_lock_release
inline unsigned int AbcCmpXChg( volatile unsigned int* p, int newval, int oldval )			{ return __sync_val_compare_and_swap( p, oldval, newval ); }
inline unsigned int	AbcInterlockedIncrement( volatile unsigned int* p )						{ return __sync_add_and_fetch( p, 1 ); }
inline unsigned int	AbcInterlockedDecrement( volatile unsigned int* p )						{ return __sync_sub_and_fetch( p, 1 ); }
//#	endif
#endif


PAPI void		AbcSpinLockWait( volatile unsigned int* p );		// Spins until we can set p from 0 to 1. Assumes your hold your lock for a handful of clock cycles.
PAPI void		AbcSpinLockRelease( volatile unsigned int* p );		// Sets p to 0 with release semantics.

/// Scope-based AbcSpinLock___
class TakeSpinLock
{
public:
volatile unsigned int* P;
TakeSpinLock( volatile unsigned int* p )
{
P = p;
AbcSpinLockWait(P);
}
~TakeSpinLock()
{
AbcSpinLockRelease(P);
}
};

/// Scope-based critical section acquisition
class PAPI TakeCriticalSection
{
public:
AbcGuardedCriticalSection*	CS;
bool						UseGuard;

TakeCriticalSection( AbcCriticalSection& cs );
TakeCriticalSection( AbcGuardedCriticalSection& cs );
~TakeCriticalSection();
};

struct AbcMutexStackEnter
{
AbcMutex* Mutex;
AbcMutexStackEnter( AbcMutex& m )
{
Mutex = &m;
AbcMutexWait( *Mutex, AbcINFINITE );
}
~AbcMutexStackEnter()
{
AbcMutexRelease( *Mutex );
}
};

/*

[2013-10-22 BMH] This thing needs proper testing. I am not sure that the semaphore semantics are as expected.

Simulates CreateEvent/SetEvent/Wait for linux.

I don't understand why people say you can use a condition variable to simulate a Windows Event.
In the condition variable scenario, the waiters need to lock the mutex, which means there can
only be a single thread waiting on the event at any particular time. This breaks one of the
primary	uses of an event: multiple workers waiting on a single event.

On Windows, we just use the native Events.

On linux, we use semaphores.

Regarding the 'persistent' parameter, we are trying to duplicate the semantics of
the Windows manual-reset event type.
The following documentation	is copied from MSDN:
If this parameter is TRUE, the function creates a manual-reset event object, which requires
the use of the ResetEvent function to set the event state to nonsignaled. If this parameter
is FALSE, the function creates an auto-reset event object, and system automatically resets
the event state to nonsignaled after a single waiting thread has been released.

Note that internally on linux, since we are using a semaphore, we cannot reproduce the
Windows functionality completely.

What we do on linux is instead a bit of a hack, but I have scanned through all of my present
usages of events on Windows, and this workaround will suffice for all of them.
I do fear somebody using this incorrectly in the future though. It would likely
introduce a subtle and hard to understand bug. I simply cannot find a pthreads
alternative though.

The technique we use is this (applies only when persistent = true):
1. The initial call to SetEvent() calls sem_post 32 times. The number 32 is chosen
to match the expected number of general purpose threads on a machine. There
is no way we can avoid the event from flipping in and out of the signaled state,
so all we're doing here is trying to ensure that performance is decent.
1. Whenever a thread is awakened, it immediately calls sem_post() again. The semaphore
number will thus hover around 32.

Note that this does mean that the event is going to flip in and out of the signaled state.
Unfortunately I cannot think of a bullet-proof way to implement this.

The destructor calls Destroy()
*/
struct PAPI AbcSyncEvent
{
#ifdef _WIN32
HANDLE				Event;
AbcSyncEvent()		: Event(0) {}
~AbcSyncEvent();
#else
static const int	PersistentPostCount = 32;
AbcSemaphore		Sem;
bool				Persistent;
bool				Initialized;
AbcSyncEvent();
~AbcSyncEvent();
#endif

void Initialize( bool persistent );
void Destroy();
void Signal();
bool Wait( DWORD waitMS );
};




inline i64 AbcFileTimeToMicroseconds( const FILETIME& ft )
{
u64 time = ((u64) ft.dwHighDateTime << 32) | ft.dwLowDateTime;
i64 stime = (i64) time;
return stime / 10;
}

inline double AbcFileTimeToUnixSeconds( const FILETIME& ft )
{
const i64 days_from_1601_to_1970 = 370 * 365 - 276;
const i64 microsecondsPerDay = 24 * 3600 * (i64) 1000000;
i64 micro = AbcFileTimeToMicroseconds( ft );
return (micro - (days_from_1601_to_1970 * microsecondsPerDay)) * (1.0 / 1000000.0);
}

PAPI double AbcTimeAccurateRTSeconds();




#ifdef _WIN32
#define ABC_DIR_SEP_STR		 "\\"
#define ABC_DIR_SEP_STR_W	L"\\"
#else
#define ABC_DIR_SEP_STR		 "/"
#define ABC_DIR_SEP_STR_W	L"/"
#endif

struct AbcFilesystemItem
{
const char* Root;		// Directory of file
const char* Name;		// Name of file
double		TimeModify;	// Seconds since unix epoch, UTC
bool		IsDir : 1;
};

/*
Enumerate files and directories inside the given directory.
The directory name must be pure, without any wildcards.
This function appends a '*' itself.
The callback must respond in the following ways
- If 'item' is a directory
Return true to cause the directory to be entered
Return false to skip entering the directory
- If 'item' is a file
Return true to cause iteration to continue
Return false to stop iteration of this directory
This function returns false if an error occurred other than "no files found"
*/
bool AbcFilesystemFindFiles( const char* dir, std::function<bool(const AbcFilesystemItem& item)> callback );

/*
* Copyright 2001-2004 Unicode, Inc.
*
* Disclaimer
*
* This source code is provided as is by Unicode, Inc. No claims are
* made as to fitness for any particular purpose. No warranties of any
* kind are expressed or implied. The recipient agrees to determine
* applicability of information provided. If this file has been
* purchased on magnetic or optical media from Unicode, Inc., the
* sole remedy for any claim will be exchange of defective media
* within 90 days of receipt.
*
* Limitations on Rights to Redistribute This Code
*
* Unicode, Inc. hereby grants the right to freely use the information
* supplied in this file in the creation of products supporting the
* Unicode Standard, and to make copies of this file in any form
* for internal or external distribution as long as this notice
* remains attached.
*/

/* ---------------------------------------------------------------------

Conversions between UTF32, UTF-16, and UTF-8.  Header file.

Several funtions are included here, forming a complete set of
conversions between the three formats.  UTF-7 is not included
here, but is handled in a separate source file.

Each of these routines takes pointers to input buffers and output
buffers.  The input buffers are const.

Each routine converts the text between *sourceStart and sourceEnd,
putting the result into the buffer between *targetStart and
targetEnd. Note: the end pointers are *after* the last item: e.g.
*(sourceEnd - 1) is the last item.

The return result indicates whether the conversion was successful,
and if not, whether the problem was in the source or target buffers.
(Only the first encountered problem is indicated.)

After the conversion, *sourceStart and *targetStart are both
updated to point to the end of last text successfully converted in
the respective buffers.

Input parameters:
sourceStart - pointer to a pointer to the source buffer.
The contents of this are modified on return so that
it points at the next thing to be converted.
targetStart - similarly, pointer to pointer to the target buffer.
sourceEnd, targetEnd - respectively pointers to the ends of the
two buffers, for overflow checking only.

These conversion functions take a ConversionFlags argument. When this
flag is set to strict, both irregular sequences and isolated surrogates
will cause an error.  When the flag is set to lenient, both irregular
sequences and isolated surrogates are converted.

Whether the flag is strict or lenient, all illegal sequences will cause
an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
must check for illegal sequences.

When the flag is set to lenient, characters over 0x10FFFF are converted
to the replacement character; otherwise (when the flag is set to strict)
they constitute an error.

Output parameters:
The value "sourceIllegal" is returned from some routines if the input
sequence is malformed.  When "sourceIllegal" is returned, the source
value will point to the illegal value that caused the problem. E.g.,
in UTF-8 when a sequence is malformed, it points to the start of the
malformed sequence.

Author: Mark E. Davis, 1994.
Rev History: Rick McGowan, fixes & updates May 2001.
Fixes & updates, Sept 2001.

------------------------------------------------------------------------ */

#ifndef CONVERT_UTF_INCLUDED
#define CONVERT_UTF_INCLUDED


/// Returns true if any characters in the string are greater than 127
inline bool IsHighAscii( const char* src )
{
while ( *src )
if ( *src++ < 0 ) return true;
return false;
}

/// Returns true if any characters in the string are greater than 127
inline bool IsHighAscii( const char* src, size_t maxLen )
{
size_t p = 0;
while ( src[p] && p < maxLen )
if ( src[p++] < 0 ) return true;
return false;
}

/// Returns true if all characters in the string are less than 128.
inline bool IsLowAscii( const wchar_t* src )
{
while ( *src )
if ( *src++ > 127 ) return false;
return true;
}

/// Returns true if all characters in the string are less than 128.
inline bool IsLowAscii( const wchar_t* src, size_t maxLen )
{
size_t p = 0;
while ( src[p] && p < maxLen )
if ( src[p++] > 127 ) return false;
return true;
}

#ifdef XSTRING_DEFINED
XStringA	PAPI ConvertHighAsciiToUTF8( const XStringA& src );
XStringA	PAPI ConvertUTF8ToHighAscii( const XStringA& src );
XStringW	PAPI ConvertUTF8ToWide( const XStringA& src );
XStringA	PAPI ConvertWideToUTF8( const XStringW& src );
#endif

#ifdef _STRING_
std::wstring	PAPI ConvertUTF8ToWide( const std::string& src );
std::string		PAPI ConvertWideToUTF8( const std::wstring& src );
#endif

/** Convert UTF16 to UTF8.
@param src Source buffer. May be NULL, which is equivalent to making srcLen = 0.
@param srcLen Length in characters of sources. If -1, then we determine the length by looking for a null terminator.
@param dst The destination buffer.
@param dstLen The length in characters of the destination buffer.
@param relaxNullTerminator If true, then we don't make sure that we can add a null terminator to dst.
**/
bool		PAPI ConvertWideToUTF8( const wchar_t* src, size_t srcLen, char* dst, size_t& dstLen, bool relaxNullTerminator = false );

/// Analogue of ConvertWideToUTF8
bool		PAPI ConvertUTF8ToWide( const char* src, size_t srcLen, wchar_t* dst, size_t& dstLen, bool relaxNullTerminator = false );

/** Returns the maximum number of UTF8 bytes necessary in order to represent any legal UTF16 string of the indicated number of UTF16 characters.

Maximum length of a UTF8 sequence is 4 bytes.
Maximum length of a UTF16 sequence is 2 bytes.
Therefore, when converting a UTF16 string to UTF8, in order to be safe against any possible inputs, you must allocate
N * 4 bytes, where N is the number of 16-bit characters. However, 4 byte UTF8 sequences are only necessary for values
of 0x10000 and greater. Likewise, UTF16 pairs are only necessary for values greater than or equal to 0x10000. So,
for values less than 0x10000, we have the maximum number of UTF8 bytes equal to N * 3. For values greater than or
equal to 0x10000, we need (N/2) * 4 = N * 2. So the maximum number of bytes necessary is N * 3.

**/
inline size_t MaximumUtf8FromUtf16( size_t utf16Len )
{
return utf16Len * 3;
}

inline size_t MaximumUtf8FromUtf32( size_t utf32Len )
{
return utf32Len * 4;
}

inline size_t MaximumUtf8FromWide( size_t wideLen )
{
return sizeof(wchar_t) == 2 ? MaximumUtf8FromUtf16(wideLen) : MaximumUtf8FromUtf32(wideLen);
}

inline size_t MaximumUtf16FromUtf8( size_t utf8Len )
{
return utf8Len * 2;
}

inline size_t MaximumUtf32FromUtf8( size_t utf8Len )
{
return utf8Len;
}

inline size_t MaximumWideFromUtf8( size_t utf8Len )
{
return sizeof(wchar_t) == 2 ? MaximumUtf16FromUtf8(utf8Len) : MaximumUtf32FromUtf8(utf8Len);
}

namespace Unicode
{

/* ---------------------------------------------------------------------
The following 4 definitions are compiler-specific.
The C standard does not guarantee that wchar_t has at least
16 bits, so wchar_t is no less portable than unsigned short!
All should be unsigned values to avoid sign extension during
bit mask & shift operations.
------------------------------------------------------------------------ */

typedef unsigned long	UTF32;	/* at least 32 bits */
typedef unsigned short	UTF16;	/* at least 16 bits */
typedef unsigned char	UTF8;	/* typically 8 bits */

/* Some fundamental constants */
#define UNI_REPLACEMENT_CHAR	(UTF32)0x0000FFFD
#define UNI_MAX_BMP				(UTF32)0x0000FFFF
#define UNI_MAX_UTF16			(UTF32)0x0010FFFF
#define UNI_MAX_UTF32			(UTF32)0x7FFFFFFF
#define UNI_MAX_LEGAL_UTF32		(UTF32)0x0010FFFF

enum ConversionResult
{
ConversionOk, 						// Conversion successful.
ConversionResultSourceExhausted,	// Partial character in source, but hit end.
ConversionResultTargetExhausted,	// Insufficient room in target for conversion.
ConversionResultSourceIllegal		// Source sequence is illegal/malformed.
};

enum ConversionFlags
{
ConversionStrict = 0,
ConversionLenient
};

ConversionResult PAPI ConvertUTF8toUTF16 ( const UTF8** sourceStart, const UTF8* sourceEnd,
UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags );

ConversionResult PAPI ConvertUTF16toUTF8 ( const UTF16** sourceStart, const UTF16* sourceEnd,
UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags );

ConversionResult PAPI ConvertUTF8toUTF32 (	const UTF8** sourceStart, const UTF8* sourceEnd,
UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags );

ConversionResult PAPI ConvertUTF32toUTF8 ( const UTF32** sourceStart, const UTF32* sourceEnd,
UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags );

ConversionResult PAPI ConvertUTF16toUTF32 ( const UTF16** sourceStart, const UTF16* sourceEnd,
UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags );

ConversionResult PAPI ConvertUTF32toUTF16 ( const UTF32** sourceStart, const UTF32* sourceEnd,
UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags );

bool PAPI IsLegalUTF8Sequence( const UTF8 *source, const UTF8 *sourceEnd );

}

#endif



/*

Work/job queue
==============

* Multithreaded
* Simple FIFO
* Ring buffer

We follow ryg's recommendations here from http://fgiesen.wordpress.com/2010/12/14/ring-buffers-and-queues/
Particularly, ring size is always a power of 2, and we use at most N-1 slots. This removes the ambiguity caused
by a full buffer, wherein Head = Tail, which is the same as an empty buffer.

CAVEAT!

If you choose to use the semaphore, then ALL of your queue consumers MUST obey this pattern:
1 Wait for the semaphore to be signaled
2 Fetch one item from the queue
3 Go back to (1)

*/
class PAPI AbcQueue
{
public:
AbcCriticalSection	Lock;			// Lock on the queue data structures
AbcSemaphore		Semaphore;		// Can be used to wait for detection of a non-empty queue. Only valid if semaphore was enabled during call to Initialize(). Read CAVEAT.

AbcQueue();
~AbcQueue();
void	Initialize( bool useSemaphore, size_t itemSize );	// Every item must be the same size
void	Add( const void* item );							// Add to head. We copy in itemSize bytes, from base address 'item'
bool	PopTail( void* item );								// Pop the tail of the queue. Returns false if the queue is empty.
bool	PeekTail( void* item );								// Get the tail of the queue, but do not pop it. Obviously useless for multithreaded scenarios, unless you have acquired the lock.
int32	Size();

private:
bool				HaveSemaphore;
u32					Tail;
u32					Head;
u32					RingSize;				// Size of the ring buffer. Always a power of 2.
u32					ItemSize;
void*				Buffer;
u32					Mask() const				{ return RingSize - 1; }
void*				Slot( u32 pos ) const		{ return (byte*) Buffer + (pos * ItemSize); }
void				Increment( u32& i ) const	{ i = (i + 1) & Mask(); }
int32				SizeInternal() const		{ return (Head - Tail) & Mask(); }

void	Grow();
};

// Typed wrapper around AbcQueue
template<typename T>
class TAbcQueue
{
public:
TAbcQueue()							{ Q.Initialize( false, sizeof(T) ); }
void					Initialize( bool useSemaphore )		{ Q.Initialize( useSemaphore, sizeof(T) ); }
void					Add( const T& item )				{ Q.Add( &item ); }
bool					PopTail( T& item )					{ return Q.PopTail( &item ); }
bool					PeekTail( T& item )					{ return Q.PeekTail( &item ); }
T						PopTailR()							{ T t = T(); PopTail( t ); return t; }
T						PeekTailR()							{ T t = T(); PeekTail( t ); return t; }
int32					Size()								{ return Q.Size(); }
AbcCriticalSection&		LockObj()							{ return Q.Lock; }
AbcSemaphore&			SemaphoreObj()						{ return Q.Semaphore; }
private:
AbcQueue Q;
};



#define ABC_HAVE_ALIGNED_MALLOC 1
//#define ABC_HAVE_POSIX_MEMALIGN 1		// uncomment this once all posix systems support it (including Android)

#if defined(ABC_HAVE_ALIGNED_MALLOC)

#ifdef __cplusplus
#	define O_INLINE inline
#else
#	define O_INLINE
#endif

/*
How do we implement this manually?

Alignment must be a power of 2. If it is not, then AbcAlignedMalloc returns NULL.

Some examples illustrating 4 byte alignment, allocating 8 bytes of usable memory:

. Wasted byte at start
# Our byte that tells us how many bytes of wasted space before the usable memory
- Usable, aligned memory
* Wasted byte at end

Bytes before alignment point
1					#--------***			(# = 1) There are 3 bytes extra at the end of the usable space
2					.#--------**			(# = 2) There are 2 bytes extra at the end of the usable space
3					..#--------*			(# = 3) There is 1 byte extra at the end of the usable space
4					...#--------			(# = 4) Original malloc result was perfect. We had to burn 4 bytes. Zero bytes extra at the end of the usable space.

We always allocate (bytes + alignment), we always waste extract "alignment" bytes.
*/

O_INLINE void* AbcAlignedMalloc( size_t bytes, size_t alignment );
O_INLINE void* AbcAlignedRealloc( size_t original_block_bytes, void* block, size_t bytes, size_t alignment );
O_INLINE void  AbcAlignedFree( void* block );

O_INLINE void* AbcAlignedMalloc( size_t bytes, size_t alignment )
{
#ifdef _WIN32
return _aligned_malloc( bytes, alignment );
#elif defined(ABC_HAVE_POSIX_MEMALIGN)
void* p = NULL;
if ( 0 != posix_memalign( &p, alignment, bytes ) )
return NULL;
return p;
#else
size_t alignment_mask = alignment - 1;

// Ensure that alignment is a power of 2
if ( (alignment_mask & alignment) != 0 )
return NULL;

size_t raw		= (size_t) malloc( bytes + alignment );
size_t usable	= 0;
if ( raw )
{
usable = (raw + alignment) & ~alignment_mask;
*((unsigned char*) (usable - 1)) = (unsigned char) (usable - raw);
}
return (void*) usable;
#endif
}

// alignment must be the same as the original block
O_INLINE void* AbcAlignedRealloc( size_t original_block_bytes, void* block, size_t bytes, size_t alignment )
{
#ifdef _WIN32
return _aligned_realloc( block, bytes, alignment );
#else
void* p = AbcAlignedMalloc( bytes, alignment );
if ( !p )
return NULL;
memcpy( p, block, original_block_bytes );
AbcAlignedFree( block );
return p;
#endif
}

O_INLINE void AbcAlignedFree( void* block )
{
#ifdef _WIN32
_aligned_free( block );
#elif defined(ABC_HAVE_POSIX_MEMALIGN)
free( block );
#else
unsigned char* usable = (unsigned char*) block;
unsigned char* raw = usable - usable[-1];
free(raw);
#endif
}

#undef O_INLINE
#endif



namespace AbCore
{
typedef void* (*CxAllocFunc)	( void* context, size_t bytes );
typedef void (*CxFreeFunc)		( void* context, void* ptr );
inline void* CxAllocFunc_Default	( void* context, size_t bytes ) { return malloc(bytes); }
inline void CxFreeFunc_Default		( void* context, void* ptr )	{ free(ptr); }

struct ABC_ALIGN(16) Bytes16Aligned
{
int64 Space[4];
};

struct IAllocator
{
virtual void* Alloc( size_t bytes ) = 0;
virtual void Free( void* ptr ) = 0;
};

struct DefaultAllocator : public IAllocator
{
virtual void* Alloc( size_t bytes )		{ return malloc(bytes); }
virtual void Free( void* ptr )			{ return free(ptr); }
};

/** Allocator that initially uses a single fixed-size block off the stack, and thereafter goes to the general heap.
**/
struct SingleStackAllocator : public IAllocator
{
virtual void* Alloc( size_t bytes )
{
if ( bytes <= StackBlockSize ) { StackBlockSize = 0; return StackBlock; }
else return malloc(bytes);
}

virtual void Free( void* ptr )
{
if ( ptr != StackBlock )
free(ptr);
}

SingleStackAllocator( void* block, size_t bytes )
{
StackBlock = block;
StackBlockSize = bytes;
}

void Init( void* block, size_t bytes )
{
StackBlock = block;
StackBlockSize = bytes;
}

void* StackBlock;
size_t StackBlockSize;
};

template< typename TData >
class CxStack
{
public:
typedef unsigned int TRef;
AbCore::IAllocator*		Allocator;
TData*					Data;
TRef					Capacity, Count;

CxStack()
{
Allocator = NULL;
Data = NULL;
Count = 0;
Capacity = 0;
}

~CxStack()
{
Allocator->Free( Data );
}

TData& operator[]( int i ) { return Data[i]; }

TData& Back() { return Data[Count - 1]; }

void Clear()
{
Allocator->Free( Data );
Data = NULL;
Count = 0;
Capacity = 0;
}

TRef Size() { return Count; }

void Reserve( int n )
{
ABCASSERT( Capacity == 0 && Data == NULL );
Data = (TData*) Allocator->Alloc( n * sizeof(TData) );
Capacity = n;
}

void Resize( int n )
{
ABCASSERT( Count == 0 );
if ( (TRef) n > Capacity )
Grow( n );
Count = n;
}

void Push( const TData& d )
{
if ( Count == Capacity ) Grow(1);
Data[Count++] = d;
}

void Pop()
{
ABCASSERT( Count > 0 );
Count--;
}

protected:

void Grow( TRef needed )
{
TRef ocap = Capacity;
if ( Capacity == 0 ) Capacity = 1;
else Capacity = Capacity * 2;
if ( needed > Capacity )
Capacity = needed;
TData* d = (TData*) Allocator->Alloc( Capacity * sizeof(TData) );
memcpy( d, Data, ocap * sizeof(TData) );
Allocator->Free( Data );
Data = d;
}

};

/// Contiguous block of memory, initially on the stack, then on the heap
// NOTE! It's probably easier to use smallvec_stack. This was a dumb thing to create.
// Actually... not so entirely. This thing is in fact useful when you want the size of your stack buffer to be independent of the container.
// See also StackBufferT, below.
class StackBuffer
{
public:
typedef unsigned char byte;
byte*		Buffer;		// The buffer
size_t		Pos;		// The number of bytes appended
size_t		Capacity;	// Capacity of 'Buffer'
bool		OwnBuffer;	// If true, then our destructor does "free(Buffer)"

template< typename TBuf, size_t elements >
StackBuffer( TBuf (&stack_buffer)[elements] )
{
OwnBuffer = false;
Pos = 0;
Buffer = (byte*) stack_buffer;
Capacity = sizeof(stack_buffer[0]) * elements;
}

~StackBuffer()
{
if ( OwnBuffer ) free(Buffer);
}

void Reserve( size_t bytes )
{
if ( Pos + bytes > Capacity )
{
size_t ncap = Capacity * 2;
if ( ncap < Pos + bytes ) ncap = Pos + bytes;
byte* nbuf = (byte*) AbcMallocOrDie( ncap );
memcpy( nbuf, Buffer, Pos );
Capacity = ncap;
if ( OwnBuffer ) free(Buffer);
OwnBuffer = true;
Buffer = nbuf;
}
}

/// Current position
byte* Current()					{ return Buffer + Pos; }

template< typename T >
T* TCurrent()					{ return (T*) (Buffer + Pos); }

template< typename T >
T& TItem( int el )				{ return ((T*) Buffer)[el]; }

template< typename T >
int TSize() const				{ return int(Pos / sizeof(T)); }

void MoveCurrentPos( intp bytes )	{ Pos += bytes; ABCASSERT(Pos <= Capacity); }

byte* Add( size_t bytes )
{
Reserve( bytes );
byte* p = Buffer + Pos;
Pos += bytes;
return p;
}

void Add( const void* p, size_t bytes )
{
memcpy( Add(bytes), p, bytes );
}

template< typename T >
void AddItem( const T& v )
{
Add( &v, sizeof(v) );
}

};
}

//	Usage pattern:
//	func() {
//		StackBufferT<double,32> zbuf;
//		..
//		zbuf.Init(n);					-- Call Init ONCE
//		zbuf[i..n] = xyz;
//
//	You can also use the parameterized constructor, which simply calls Init()

template < typename VT, size_t TStaticSize >
class StackBufferT
{
DISALLOW_COPY_AND_ASSIGN(StackBufferT);
public:
u32 Count;
VT* Data;
VT	Static[TStaticSize];

StackBufferT()
{
// I considered leaving this uninitialized, but I don't think it's worth the robustness tradeoff
// One might be tempted to make Data = Static initially, but this opens one up to the possibility of forgetting to call Init()
// when the data size is indeed large enough. Your tests may not stress the oversize case, and you'll blow up when it's inconvenient.
Data = NULL;
}

StackBufferT( int s )
{
Data = NULL;
Init(s);
}

~StackBufferT()
{
if ( Data != Static ) delete[] Data;
}

void Init( int s )
{
Count = s;
if ( Count > TStaticSize )
Data = new VT[Count];
else
Data = Static;
}
void Fill( const VT& v )		{ for ( u32 i = 0; i < Count; i++ ) Data[i] = v; }

operator VT*()					{ return Data; }
};




inline int MemCmpBits( const void* a, const void* b, size_t bits )
{
size_t bytes = bits >> 3;
size_t remain = bits & 7;
if ( memcmp( a, b, bytes ) != 0 ) return 1;
if ( remain != 0 )
{
BYTE av = *(((BYTE*) a) + bytes);
BYTE bv = *(((BYTE*) b) + bytes);
for ( size_t i = 0; i < remain; i++ )
{
if ( (1 & (av >> i)) != (1 & (bv >> i)) )
return 1;
}
}
return 0;
}

/** A simple Bit Map.
The raw size of the map is always guaranteed to be on 128-bit boundaries,
which allows fast searching for on/off bits, using the raw map.

Usage:
Most functions require a static sized bitmap, ie create a bitmap of a specific size
using Resize(), then use Get() and Set().<br/>
However, the Add() function will intelligently increase the capacity
of the bitmap if necessary. For this purpose the bitmap holds a CapacityBits field,
which is used to grow the bitmap at a 2x rate, like vectors.
**/
class PAPI BitMap
{
public:

#ifdef _WIN64
typedef UINT64 TUnit;
#else
typedef UINT32 TUnit;
#endif

static const int UnitSize = sizeof(TUnit) * 8;
static const TUnit UnitFill = -1;

#ifndef MIN
template<typename TV> static TV MIN(TV a, TV b) { return a < b ? a : b; }
#endif
#ifndef MAX
template<typename TV> static TV MAX(TV a, TV b) { return a < b ? b : a; }
#endif

BitMap()
{
Construct();
}
BitMap( const BitMap& b )
{
Construct();
*this = b;
}
~BitMap()
{
Clear();
}

/** Necessary raw block byte alignment.
16 might seem wide, but it's in view of SSE optimizations. I think SSE4 has a count bits instruction that operates
on a 128 bit word.
WARNING: This is not currently used. If you DO use it, then remove the non-aligned BmpAlloc/BmpFree implementations.
**/
static const int Alignment = 16;

/** Set the buffer to an external source.
**/
void SetExternal( int bits, void* buffer, int allocatedBits )
{
ASSERT( allocatedBits >= 8 && allocatedBits % 8 == 0 );
CanFind = allocatedBits % (Alignment * 8) == 0;
Clear();
External = true;
SizeBytes = bits / 8;
CapacityBits = bits;
SizeBits = CapacityBits;
Map = (BYTE*) buffer;
}

BitMap& operator=( const BitMap& b )
{
ASSERT( !External && !b.External );
CapacityBits = b.SizeBits;
SizeBytes = b.SizeBytes;
SizeBits = b.SizeBits;
CanFind = b.CanFind;
BmpFree( Map );
Map = (BYTE*) BmpAlloc( SizeBytes );
memcpy( Map, b.Map, SizeBytes );
return *this;
}

/// Will shrink the bitmap to it's minimum required size (only necessary after using Add()).
void Shrink()
{
if ( External ) { ASSERT(false); return; }
if ( CapacityBits == SizeBits ) return;
if ( SizeBits == 0 ) { Clear(); return; }
Resize( SizeBits );
}

/// Size in bits
int Size() const { return SizeBits; }

/// Capacity in bits (used for testing)
int Capacity() const { return CapacityBits; }

/// Set size to zero and free memory.
void Clear()
{
if ( !External ) BmpFree( Map );
Map = NULL;
SizeBits = 0;
SizeBytes = 0;
CapacityBits = 0;
CanFind = true;
External = false;
}

/** Fill a block of bits with a value.
This will not automatically increase the size. If the specified bit range
is invalid, then the function takes no action and debug asserts.
**/
void Fill( int bitStart, int bitEndInclusive, bool value )
{
int bitEnd = bitEndInclusive;
if ( bitEnd < bitStart - 1 )	{ ASSERT(false); return; }
if ( bitStart < 0 )				{ ASSERT(false); return; }
if ( (UINT32) bitEnd >= SizeBits )		{ ASSERT(false); return; }

// this covers the case where we're writing within one byte.
if ( bitEnd - bitStart < 8 )
{
for ( UINT32 i = (UINT32) bitStart; i <= (UINT32) bitEnd; i++ )
Set( i, value );
return;
}

// set beginning odd bits
while ( bitStart % 8 != 0 )
{
Set( bitStart, value );
bitStart++;
}

UINT32 sbyte = bitStart / 8;
UINT32 ebyte = bitEnd / 8;
if ( (bitEnd + 1) % 8 == 0 ) ebyte++;
BYTE bval = value ? 0xFF : 0x00;
for ( UINT32 i = sbyte; i < ebyte; i++ )
Map[i] = bval;

// set end odd bits
while ( (bitEnd + 1) % 8 != 0 )
{
Set( bitEnd, value );
bitEnd--;
}
}

/** Resizes preserving existing data.
@return False only if there is a memory allocation failure.
**/
bool Resize( UINT32 bits, bool fillNewSectionWith = false )
{
if ( bits == 0 ) { Clear(); return true; }
if ( External ) { ASSERT(false); return false; }
if ( bits == SizeBits ) return true;

BYTE* oldMap = Map;
UINT32 oldBytes = SizeBytes;
UINT32 oldBits = SizeBits;
SizeBits = bits;
SizeBytes = (bits + 7) / 8;
CapacityBits = SizeBits;
CanFind = true;

// align size to next 128-bit boundary
UINT32 alignedSize = ((SizeBytes + Alignment - 1) / Alignment) * Alignment;
Map = (BYTE*) BmpAlloc( alignedSize );

if ( Map != NULL && oldMap != NULL )
{
UINT32 copy = MIN( oldBytes, SizeBytes );
memcpy( Map, oldMap, copy );
BmpFree( oldMap );
}

if ( Map != NULL && bits > oldBits )
{
Fill( oldBits, bits - 1, fillNewSectionWith );
}

return Map != NULL;
}

/** Add a bit.
This is the only function that will automatically increase the size of the bitmap.
**/
void Add( bool value )
{
if ( External ) { ASSERT(false); return; }
if ( SizeBits >= CapacityBits )
{
int oldSize = SizeBits;
int newSize = MAX( SizeBits * 2, 64u );
if ( !Resize( newSize ) ) return;
SizeBits = oldSize;
}
Set( SizeBits, value );
SizeBits++;
}

/// Alias for Add()
BitMap& operator+= ( bool value )
{
Add( value );
return *this;
}

/// Automatically grow if necessary
void SetAutoGrow( UINT32 bit, bool value, bool fillNewSectionWith = false )
{
if ( bit == SizeBits )
{
Add( value );
return;
}
else if ( bit >= SizeBits )
{
if ( bit >= CapacityBits )
{
UINT32 nCap = MAX( CapacityBits * 2, bit + 1 );
Resize( nCap, fillNewSectionWith );
}
SizeBits = bit + 1;
}
Set( bit, value );
}

/// Set a bit
void Set( UINT32 bit, bool value )
{
UINT32 pword = bit >> 5;
UINT32 pbit = bit & 31;
#ifdef _WIN32
if ( value )	_bittestandset( ((LONG*) Map) + pword, pbit );
else			_bittestandreset( ((LONG*) Map) + pword, pbit );
#else
if ( value )	((UINT32*)Map)[pword] |= (1 << pbit);
else			((UINT32*)Map)[pword] &= ~(1 << pbit);
#endif
}

/// Get a bit, but return the passed-in default value if the bit requested is larger than the table.
bool GetOrDefault( UINT32 bit, bool default_value ) const
{
if ( bit >= SizeBits ) return default_value;
return Get( bit );
}

/// Get a bit
bool Get( UINT32 bit ) const
{
ASSERT( bit < SizeBits );
UINT32 pword = bit >> 5;
UINT32 pbit = bit & 31;
#ifdef _WIN32
return 0 != _bittest( ((LONG*) Map) + pword, pbit );
#else
return 0 != (((UINT32*)Map)[pword] & (1 << pbit));
#endif
}

bool operator[]( UINT32 bit ) const { return Get(bit); }

/** Counts the number of true bits in the specified range.
This is not optimized, but in future I may indeed do that.
**/
int CountTrueBits( UINT32 fromBit = 0, UINT32 toBitInclusive = -1 ) const
{
if ( toBitInclusive == -1 ) toBitInclusive = SizeBits - 1;
UINT32 count = 0;
for ( UINT32 i = fromBit; i < toBitInclusive; i++ )
{
if ( Get(i) )
count++;
}
return count;
}

/** Counts the number of false bits in the specified range.
**/
int CountFalseBits( UINT32 fromBit = 0, UINT32 toBitInclusive = -1 ) const
{
if ( toBitInclusive == -1 ) toBitInclusive = SizeBits - 1;
UINT32 size = 1 + toBitInclusive - fromBit;
return size - CountTrueBits( fromBit, toBitInclusive );
}

/// Returns the raw map
void* GetMap() const { return Map; }

/// Linearly searches the map for the first true bit.
int FirstTrueBit( UINT32 firstBit = 0, UINT32 lastBitInclusive = -1 ) const { return FirstBit( true, firstBit, lastBitInclusive ); }

/// Linearly searches the map for the first false bit.
int FirstFalseBit( UINT32 firstBit = 0, UINT32 lastBitInclusive = -1 ) const { return FirstBit( false, firstBit, lastBitInclusive ); }

/** Linearly searches the map for the first true or false bit, and returns -1 if none is found.
@firstBit Begin searching at the indicated bit.
@lastBitInclusive Stop searching on the specified bit.
@return The first bit found in the requested state, or -1 if there is no such bit.
**/
UINT32 FirstBit( bool state, UINT32 firstBit = 0, UINT32 lastBitInclusive = -1 ) const
{
if ( !CanFind ) { ASSERT(false); return -1; }
if ( firstBit < 0 ) firstBit = 0;
if ( SizeBits == 0 ) return -1;
if ( lastBitInclusive == -1 ) lastBitInclusive = SizeBits - 1;
lastBitInclusive = MIN( lastBitInclusive, SizeBits - 1 );
// the second pass is for the following case:
// the bitmap looks like this: ([] denotes a 32-bit block).
// [01000..0][001000..0]
// and the search is ( true, 3 ).
// This causes us to begin our search on the first block, and then we
// false-positively exit on the first byte.. ergo the second pass.
for ( int pass = 0; pass < 2; pass++ )
{
if ( firstBit > lastBitInclusive ) return -1;
UINT32 searchBytes = 1 + (lastBitInclusive / 8);
TUnit* base = (TUnit*) Map;
base += firstBit / UnitSize;
TUnit* p = base;
TUnit* porg = base;
TUnit* pb = (TUnit*) Map;
TUnit* pt = (TUnit*) (Map + searchBytes);
if ( state )
{
for ( ; p < pt; p++ ) if ( *p != 0 ) break;
}
else
{
for ( ; p < pt; p++ ) if ( *p != UnitFill ) break;
}
UINT32 sbit = UINT32((p - pb) * UnitSize);
sbit = MAX( sbit, firstBit );
UINT32 ebit = MIN( sbit + UnitSize, lastBitInclusive + 1 );
if ( state )
{
for ( UINT32 i = sbit; i < ebit; i++ ) if ( Get(i) ) return i;
}
else
{
for ( UINT32 i = sbit; i < ebit; i++ ) if ( !Get(i) ) return i;
}
// this is the only condition necessitating a 2nd pass
if ( firstBit % UnitSize != 0 && p == porg )
{
firstBit = ((firstBit + UnitSize - 1) / UnitSize) * UnitSize;
continue;
}
return -1;
}
return -1;
}

protected:
bool External;
bool CanFind;	///< Only true if our data is aligned on 128 bits.
UINT32 CapacityBits;
UINT32 SizeBits;
UINT32 SizeBytes;
BYTE* Map;

void Construct()
{
External = false;
CanFind = false;
CapacityBits = 0;
SizeBytes = 0;
SizeBits = 0;
Map = NULL;
}

#if defined(ABC_HAVE_ALIGNED_MALLOC)
void* BmpAlloc( size_t bytes )
{
return AbcAlignedMalloc( bytes, Alignment );
}
void BmpFree( void* p )
{
return AbcAlignedFree( p );
}
#else
// This business of being 128-byte aligned is not actually necessary.. it's just a future looking thing
void* BmpAlloc( size_t bytes )
{
return malloc( bytes );
}
void BmpFree( void* p )
{
return free( p );
}
#endif

};


/** A free list, built on top of BitMap.

We run a secondary bitmap that records groups of 32 slots, marking a 1
if all 32 slots are occupied, and a zero otherwise. This allows us to
search for 1024 free slots with a single 32-bit integer comparison.
The reason for this is because every bit in the secondary map covers
32 bits in the main map, and 32 * 32 = 1024.

For a 64-bit map, this becomes 4096. I guess optimal performance depends
on the particular use case. Note that it will not be 64 * 64 until we have
made BitMap capable of using 64-bits... let's do it now...

We pad our main map's size up so that it fits the group size,
and we set the extra bits to 1, so that they are marked as 'used'.
**/
template< typename GType >
class TFreeList
{
public:
TFreeList()
{
Guess = 0;
Used = 0;
Size = 0;
External = false;
}

/// Group bits
static const int GBits = sizeof(GType) * 8;
static const GType GFull = -1;

void Reset()
{
if ( External )
{
Secondary.Clear();
Main.Clear();
Size = 0;
External = false;
}
else
{
Resize(0);
}
Used = 0;
Guess = 0;
}

int RequiredMainBits( int bits )
{
return ((bits + GBits - 1) / GBits) * GBits;
}

void Resize( int bits )
{
ResizeInternal( bits, true );
}

void SetMap( int bits, int used, const void* raw )
{
if ( External ) Reset();
ResizeInternal( bits, false );
memcpy( Main.GetMap(), raw, (bits + 7) / 8 );
SetOverBits( true );
Used = used;
RebuildSecondaryInternal();
}

/** Set the main map from an externally allocated memory block.
It is illegal to resize the bitmap when it is external. If you want to recycle the object,
call Clear(), which makes it non-external.
**/
bool SetMapExternal( int bits, int used, void* raw, int bitsReserved )
{
// bitsReserved is here for no purpose other than to ensure that you understand that you might
// needs to have extra bits on the end to pad things out to 32/64
if ( RequiredMainBits(bits) > bitsReserved ) { ASSERT(false); return false; }
Main.SetExternal( bits, raw, bitsReserved );
Size = bits;
External = true;
SetOverBits( true );
Used = used;
RebuildSecondaryInternal();
return true;
}

void* GetMain()
{
return Main.GetMap();
}

int Capacity() const { return Size; }
int SlotsUsed() const { return Used; }

bool Get( int slot ) const { return Main.Get(slot); }

/** Find a free item.

The item is marked non-free before the function returns.

@return A free item, or -1 if all items are used.
**/
int Acquire()
{
if ( Used == Size ) return -1;
int slot = -1;
if ( Guess >= 0 && Guess < Size )
{
if ( !Main.Get(Guess) )
slot = Guess;
}
if ( slot == -1 )
{
slot = Search();
}
if ( slot == -1 ) { ASSERT(false); return -1; } // this ought to be impossible.
Main.Set( slot, true );
Update( slot );
Used++;
Guess = slot + 1;
return slot;
}


void Release( int slot )
{
ASSERT( slot >= 0 && slot < Size );
ASSERT( Main.Get(slot) );
Main.Set( slot, false );
Update( slot );
Used--;
Guess = slot;
}

/** Rebuild the secondary map.
Use this only if you have updated the underlying bitmap (which you COULD only do if you were operating with external data).
You must respecify the number of free slots here.
**/
void RebuildSecondary( int used )
{
Used = used;
RebuildSecondaryInternal();
}

/// If you modify the underlying map, you better call RebuildSecondary afterwards.
BitMap& GetMainMap()
{
return Main;
}

protected:
int Guess;
int Size;
int GroupSize() { return Size / GBits; }
int Used;
bool External;
BitMap Main, Secondary;

void Update( int forBit )
{
GType* prim = (GType*) Main.GetMap();
int g = forBit / GBits;
Secondary.Set( g, prim[g] == GFull );
}

int Search()
{
int g = Secondary.FirstFalseBit( 0 );
if ( g < 0 ) { ASSERT(false); return -1; } // by design, should never happen, because we keep track of Used vs Size.
return Main.FirstFalseBit( g * GBits );
}

void SetOverBits( bool used )
{
// set the over bits (which pad our main buffer up to a GBit boundary)
for ( int i = Size; i < Main.Size(); i++ )
Main.Set( i, used );
}

void ResizeInternal( int bits, bool rebuild_secondary = true )
{
if ( External ) { ASSERT(false); return; }
//ASSERT( bits >= Size );
//Used = 0;
SetOverBits( false );
Size = bits;
int actual = ((bits + GBits - 1) / GBits) * GBits;
Main.Resize( actual, false );
SetOverBits( true );
if ( rebuild_secondary )
RebuildSecondaryInternal();
}

void RebuildSecondaryInternal()
{
int ns = Main.Size() / GBits;
Secondary.Resize( ns );
GType* mb = (GType*) Main.GetMap();
for ( int i = 0; i < ns; i++ )
{
Secondary.Set( i, mb[i] == GFull );
}
}

};

typedef TFreeList< UINT32 > FreeList32;
typedef TFreeList< UINT64 > FreeList64;

#ifdef _WIN64
typedef FreeList64 FreeList;
#else
typedef FreeList32 FreeList;
#endif


/* fhash - my final hash table (!).
I wrote this because I was sick of agonizing over the code bloat every time I wanted to add a new hash table.
So this basically uses a table of function pointers.

Examples
========

string -> string
----------------

namespace space { class mystring { uint32 GetHashCode() const {...} }; }

// This must be done in the global namespace
FHASH_SETUP_CLASS_GETHASHCODE( space::mystring, mystring );

fhashmap<mystring,mystring> t;
t.insert( "a", "A" );



ptr* -> int32			Using the address as the hash code
--------------------------------------------------------

struct myobj {}

// As always, this must be written in the global namespace
FHASH_SETUP_POINTER_ADDRESS( myobj );



object -> int32			Using a member function of the form "uint GetHashCode() const"
------------------------------------------------------------------------------------

struct myobj { uint32 GetHashCode() const {...}; }

FHASH_SETUP_CLASS_GETHASHCODE( myobj, myobj );



object -> int32			Using your own hash function
------------------------------------------------------

struct myobj {}


FHASH_SETUP_CLASS_CTOR_DTOR( myobj );	// For classes
FHASH_SETUP_POD_CTOR_DTOR( myobj );		// For PODs that you want default-initialized
FHASH_SETUP_TOR_NOP( myobj );			// For PODs that you want no initialization performed upon

template<> inline uint32 fhash_gethash(const myobj& obj) { return obj.x ^ obj.y; }


BMH
*/

#ifndef FHASHTABLE_H
#define FHASHTABLE_H


#ifndef FHASH_NORETURN
#	ifdef _MSC_VER
#		define FHASH_NORETURN __declspec(noreturn)
#	else
#		define FHASH_NORETURN __attribute__ ((noreturn))
#	endif
#endif

#ifndef PAPI
#define PAPI
#endif
#ifndef ASSERT
//#define ASSERT(condition) if !(condition) { int* p = 0; *p = 0; }
#define ASSERT(condition) (void)0
#endif
#ifndef NULL
#define NULL    0
#endif

#ifdef _MSC_VER
#ifndef __cplusplus_cli
// 7% speedup over __cdecl - but annoying warnings from CLR compilation
#define FHASH_CALL __fastcall
#else
#define FHASH_CALL
#endif
#else
#define FHASH_CALL
#endif

typedef signed char			int8;
typedef unsigned char		uint8;

typedef short				int16;
typedef unsigned short		uint16;

typedef          int		int32;
typedef unsigned int		uint32;

#ifdef _MSC_VER
typedef          __int64	int64;
typedef unsigned __int64	uint64;
#else
typedef int64_t				int64;
typedef uint64_t			uint64;
#endif

typedef unsigned char		fhashstate_t;
typedef unsigned char		byte;
typedef unsigned int		uint;
typedef uint32				fhashkey_t;

static const size_t fhash_npos = -1;
static const size_t fhash_min_autoshrink_count = 32;

inline size_t fhash_next_power_of_2( size_t v )
{
size_t s = 1;
while ( s < v ) s <<= 1;
return s;
}

inline FHASH_NORETURN void fhash_die()
{
*((int*)0) = 0;
while (1) {} // necessary to satisfy GCC
}

// _tor is ctor or dtor
enum fhash_tor_type
{
fhash_TOR_FUNC,	///< Function call
fhash_TOR_ZERO,	///< memset(0) -- illegal for dtor
fhash_TOR_NOP	///< nop
};

enum fhash_key_states
{
// can't have more than 4... only 2 bits available
fhash_Null = 0,
fhash_Full = 1,
fhash_Deleted = 2,
fhash_ERROR = 3
};

inline size_t fhash_state_array_size( size_t asize )
{
// every item needs 2 bits, so that's 16 items per int32
return (asize / 4) + 8;
}

// returns the state of a given position in the table
inline fhash_key_states fhash_get_state( fhashstate_t state_array[], size_t pos )
{
size_t        bytepos = pos >> 2;
unsigned char bitpos = pos & 3;
unsigned char masks[4] = { 3, 12, 48, 192 };
fhash_key_states ks = (fhash_key_states) ( (state_array[bytepos] & masks[bitpos]) >> (bitpos << 1) );
return ks;
}

inline void fhash_set_state( fhashstate_t state_array[], size_t pos, fhash_key_states newState )
{
size_t        bytepos = pos >> 2;
unsigned char bitpos = pos & 3;
unsigned char masks[4] = { (unsigned char) ~3, (unsigned char) ~12, (unsigned char) ~48, (unsigned char) ~192 };
unsigned char state = state_array[bytepos] & masks[bitpos];
state |= newState << (bitpos << 1);
state_array[bytepos] = state;
}

typedef void	(FHASH_CALL *fhash_func_xfer)			(void* dst, const void* src, size_t obj_size);
typedef void	(FHASH_CALL *fhash_func_ctor)			(void* obj);
typedef void	(FHASH_CALL *fhash_func_dtor)			(void* obj);
typedef int		(FHASH_CALL *fhash_func_keycmp)			(const void* a, const void* b);
typedef uint32	(FHASH_CALL *fhash_func_gethash)		(const void* obj, size_t obj_size);

inline void fhash_null_ctor(void* obj) {}
inline void fhash_null_dtor(void* obj) {}
inline void FHASH_CALL fhash_pod_move(void* dst, const void* src, size_t obj_size) { memcpy(dst, src, obj_size); }
inline void FHASH_CALL fhash_pod_copy(void* dst, const void* src, size_t obj_size) { memcpy(dst, src, obj_size); }

// Types of constructors and destructors required by your type
template< typename T > void fhash_tor_types( fhash_tor_type& ctor, fhash_tor_type& dtor ) { ctor = fhash_TOR_FUNC; dtor = fhash_TOR_FUNC; }

// Use operator= to copy a value
template< typename T >
void FHASH_CALL fhash_type_copy(void* dst, const void* src, size_t obj_size)
{
T* tdst = (T*) dst;
const T* tsrc = (const T*) src;
*tdst = *tsrc;
}

// Use operator= for pairs of tightly packed Key,Value objects
template< typename K, typename V >
void FHASH_CALL fhash_type_copy_pair(void* dst, const void* src, size_t obj_size)
{
K* kdst = (K*) dst;
V* vdst = (V*) (kdst + 1);
K* ksrc = (K*) src;
V* vsrc = (V*) (ksrc + 1);
*kdst = *ksrc;
*vdst = *vsrc;
}

template<typename TPod>
int FHASH_CALL fhash_pod_keycmp(const void* a, const void* b) { return !(*((const TPod*)a) == *((const TPod*)b)); }

template<typename T>
int FHASH_CALL fhash_keycmp(const void* a, const void* b) { return fhash_pod_keycmp<T>(a,b); }

inline uint32 fhash_gethash_int32(const void* obj) { return *((const uint32*)obj); }
inline uint32 fhash_gethash_int64(const void* obj) { uint64 v = *((const uint64*)obj); return uint32(v ^ (v >> 32)); }

#if ARCH_64
inline uint32 fhash_gethash_ptr(const void* ptr) { uint64 v = reinterpret_cast<uint64>(ptr); return uint32(v) ^ uint32(v >> 32); }
#else
inline uint32 fhash_gethash_ptr(const void* ptr) { return reinterpret_cast<uint32>(ptr); }
#endif

// Provide a specialization of these for your type
template< typename T > uint32 fhash_gethash(const T& obj);

template<> inline uint32 fhash_gethash(const int8& v)		{ return (uint32) v; }
template<> inline uint32 fhash_gethash(const uint8& v)		{ return (uint32) v; }
template<> inline uint32 fhash_gethash(const int16& v)		{ return (uint32) v; }
template<> inline uint32 fhash_gethash(const uint16& v)		{ return (uint32) v; }
template<> inline uint32 fhash_gethash(const int32& v)		{ return fhash_gethash_int32(&v); }
template<> inline uint32 fhash_gethash(const uint32& v)		{ return fhash_gethash_int32(&v); }
template<> inline uint32 fhash_gethash(const int64& v)		{ return fhash_gethash_int64(&v); }
template<> inline uint32 fhash_gethash(const uint64& v)		{ return fhash_gethash_int64(&v); }

template<typename T> uint32 FHASH_CALL fhash_gethash_gen_wrap(const void* v, size_t obj_size)
{
return fhash_gethash<T>( *((const T*)v) );
}

// hash the pointer itself - not what it points to
template<> inline uint32 FHASH_CALL fhash_gethash_gen_wrap<void*>(const void* v, size_t obj_size)
{
return fhash_gethash_ptr(v);
}

// constructor of your type
template< typename T > void fhash_ctor(T& obj);

// destructor of your type
template< typename T > void fhash_dtor(T& obj);

// Define NULL constructors and destructors for PODs
// Hm. probably better to initialize to zero than to leave uninitialized, because of partial writes.
#define FHASH_SETUP_POD_CTOR_DTOR(T) \
template<> inline void fhash_ctor(T& obj) { obj = T(); } \
template<> inline void fhash_dtor(T& obj) {}

#define FHASH_SETUP_TOR_NOP(T) \
template<> inline void fhash_ctor(T& obj) {} \
template<> inline void fhash_dtor(T& obj) {}

// POD, ctor=nop dtor=nop
#define FHASH_SETUP_POD(T) \
FHASH_SETUP_TOR_NOP(T) \
template<> inline void fhash_tor_types<T>( fhash_tor_type& ctor, fhash_tor_type& dtor ) { ctor = fhash_TOR_NOP; dtor = fhash_TOR_NOP; }

// Create pass-through placement new (and delete, to satisfy compiler) operators for the type
// Note: We memset(0) after destroying. This is because most destructors are not callable more than once, but we need to be.
// This won't work for everything, but at least it covers pointers inside objects.
#define FHASH_SETUP_CLASS_CTOR_DTOR(NST,T) \
inline void* operator new( size_t bytes, NST* pos ) { return pos; } \
inline void  operator delete( void* obj, NST* pos ) {} \
template<> inline void fhash_ctor(NST& obj) { new(&obj) NST(); } \
template<> inline void fhash_dtor(NST& obj) { obj.~T(); memset(&obj, 0, sizeof(obj)); }

FHASH_SETUP_POD(int8)
FHASH_SETUP_POD(int16)
FHASH_SETUP_POD(int32)
FHASH_SETUP_POD(int64)
FHASH_SETUP_POD(uint8)
FHASH_SETUP_POD(uint16)
FHASH_SETUP_POD(uint32)
FHASH_SETUP_POD(uint64)

// Setup for a class that has an "int GetHashCode() const" function,
// but doesn't need to be constructed or destructed. The omission of
// the constructor and destructor calls is a performance optimization.
#define FHASH_SETUP_POD_GETHASHCODE(T) \
FHASH_SETUP_TOR_NOP(T) \
template<> inline uint32 fhash_gethash(const T& obj) { return obj.GetHashCode(); }

// Setup for a class that has a regular constructor and destructor
// This is usable then as fhashmap<TheClass,Value>
// See also FHASH_SETUP_POINTER_GETHASHCODE, if you want to use a pointer to the class as the key
#define FHASH_SETUP_CLASS_GETHASHCODE(NST,T) \
FHASH_SETUP_CLASS_CTOR_DTOR(NST,T) \
template<> inline uint32 fhash_gethash(const NST& obj) { return obj.GetHashCode(); }

// Pointer to object that has an "int GetHashCode() const" function
// This is usable then as fhashmap<TheClass*,Value>
#define FHASH_SETUP_POINTER_GETHASHCODE(T) \
template<> inline void fhash_ctor<T*>(T*& obj)		{} \
template<> inline void fhash_dtor<T*>(T*& obj)		{} \
template<> inline uint32 fhash_gethash<T*>(T* const &obj)										{ return obj->GetHashCode();} \
template<> inline void fhash_tor_types<T*>( fhash_tor_type& ctor, fhash_tor_type& dtor )		{ ctor = fhash_TOR_NOP; dtor = fhash_TOR_NOP; } \
template<> inline int FHASH_CALL fhash_keycmp<T*>(const void* a, const void* b)					{ return **((T**) a) == **((T**) b) ? 0 : 1; }

// Pointer = object identity (and therefore hash value)
#define FHASH_SETUP_POINTER_ADDRESS(T) \
template<> inline void fhash_ctor<T*>(T*& obj)		{} \
template<> inline void fhash_dtor<T*>(T*& obj)		{} \
template<> inline uint32 fhash_gethash<T*>(T* const &obj)										{ return fhash_gethash_ptr(obj);} \
template<> inline void fhash_tor_types<T*>( fhash_tor_type& ctor, fhash_tor_type& dtor )		{ ctor = fhash_TOR_NOP; dtor = fhash_TOR_NOP; }

template< typename K > void FHASH_CALL fhash_type_ctor(void* obj) { fhash_ctor( *((K*) obj) ); }
template< typename K > void FHASH_CALL fhash_type_dtor(void* obj) { fhash_dtor( *((K*) obj) ); }

template< typename K, typename V >
void FHASH_CALL fhash_type_ctor_pair(void* obj)
{
K* kobj = (K*) obj;
V* vobj = (V*) (kobj + 1);
fhash_ctor( *kobj );
fhash_ctor( *vobj );
}

template< typename K, typename V >
void FHASH_CALL fhash_type_dtor_pair(void* obj)
{
K* kobj = (K*) obj;
V* vobj = (V*) (kobj + 1);
fhash_dtor( *kobj );
fhash_dtor( *vobj );
}

// Convenience method to delete all objects from a map<obj1*, obj2*>
template< typename TMap >
void fhash_delete_all_keys_and_values( TMap& m )
{
for ( typename TMap::iterator it = m.begin(); it != m.end(); it++ )
{
delete it.key();
delete it.val();
}
m.clear();
}

// Convenience method to delete all keys from a map<key*, ANYTHING>
template< typename TMap >
void fhash_delete_all_keys( TMap& m )
{
for ( typename TMap::iterator it = m.begin(); it != m.end(); it++ )
delete it.key();
m.clear();
}

// Convenience method to delete all values from a map<ANYTHING, value*>
template< typename TMap >
void fhash_delete_all_values( TMap& m )
{
for ( typename TMap::iterator it = m.begin(); it != m.end(); it++ )
delete it.val();
m.clear();
}

struct fhash_iface
{
size_t				Stride;
fhash_tor_type		NCTor;
fhash_tor_type		NDTor;
fhash_func_xfer		Move;
fhash_func_xfer		Copy;
fhash_func_ctor		Create;
fhash_func_dtor		Delete;
fhash_func_keycmp	KeyCmp;
fhash_func_gethash	GetHash;
bool BothNOP() const { return NCTor == fhash_TOR_NOP && NDTor == fhash_TOR_NOP; }
};

class PAPI fhashtable_base
{
public:

/** Provides a bi-directional iterator through the set.
A note on iterator consistency:
If you want to be able to iterate through a table and delete selected items from it,
then you must first disable the autoshrink mechanism. Failure to do so will result
in an invalid iterator.
**/
class iterator
{
public:
iterator()
{
_index = -1;
pos = fhash_npos;
end = false;
parent = 0;
}
iterator( const fhashtable_base *p, size_t itpos )
{
_index = -1;
pos = itpos;
end = pos == fhash_npos;
parent = p;
}
iterator(const iterator &copy)
{
_index = copy._index;
pos = copy.pos;
end = copy.end;
parent = copy.parent;
}
iterator(const fhashtable_base *p)
{
pos = 0;
_index = 0;
end = false;
parent = const_cast<fhashtable_base*>(p);
if (parent->mCount == 0 || parent->mSize == 0)
{
end = true;
}
else
{
// make iterator point to first object if it isn't already so
fhash_key_states state = fhash_get_state(parent->mState, pos);
if (state != fhash_Full)
(*this)++;
}
_index = 0;
}

bool operator==( const iterator& b )
{
if ( end && b.end ) return true;
if ( end != b.end ) return false;
return pos == b.pos;
}

bool operator!=( const iterator& b )
{
return !( *this == b );
}

void* operator->() const
{
return parent->dpos(pos);
}
void* operator*() const
{
return parent->dpos(pos);
}

// (int) --> postfix
/// Increment
iterator& operator++(int)
{
if (pos >= parent->mSize) return *this;
pos++;
while ( pos < parent->mSize && fhash_get_state(parent->mState, pos) != fhash_Full )
{
pos++;
}
_index++;
if (pos >= parent->mSize) end = true;
return *this;
}
// (int) --> postfix
/// Decrement
iterator& operator--(int)
{
if (pos == -1) return *this;
pos--;
while ( pos != -1 && fhash_get_state(parent->mState, pos) != fhash_Full )
{
pos--;
}
_index--;
if (pos == -1) end = true;
return *this;
}

/** Signals that iteration has ended.
This will be flagged on 3 occasions:
- The set is empty.
- Forward iteration with operator++ has caused us to step onto the last entity.
- Backward iteration with operator-- has caused us to step onto the first entity.

Note that in neither of two latter cases will the iterator point to an object that is
not inside the set / table.
**/
bool end;

/** Returns the index of the current object.
The index is zero for the element referred to after begin(), then incremented
for every operator++, and decremented for every operator--.

It does not have widespread use, but can be handy in some cases where the set must be
referred to as a vector.
**/
size_t index() const
{
return _index;
}

protected:
const fhashtable_base *parent;
size_t pos;
size_t _index; // valid range is [0, mCount]
};

fhashtable_base()
{
base_init();
}
fhashtable_base( const fhashtable_base& copy )
{
base_init();
mConfig = copy.mConfig;
*this = copy;
}
fhashtable_base& operator=( const fhashtable_base& copy )
{
if ( this == &copy ) return *this;

free_arrays();

mMask = copy.mMask;
mProbeOffset = copy.mProbeOffset;
mAutoShrink = copy.mAutoShrink;
mAge = copy.mAge;
mCount = copy.mCount;
mSize = copy.mSize;
mMaxCount = copy.mMaxCount;

if ( mCount == 0 )
{
mAge = 0;
mSize = 0;
}
else
{
size_t statesize = sizeof(fhashstate_t) * fhash_state_array_size(mSize);
mState = (fhashstate_t*) malloc( statesize );
if ( mState == NULL )
fhash_die();
memcpy( mState, copy.mState, statesize );
mData = (byte*) malloc( mConfig.Stride * mSize );
if ( mData == NULL )
fhash_die();

for ( size_t i = 0; i < mSize; i++ )
{
create_obj( dpos(i) );
if ( fhash_get_state(mState, i) == fhash_Full )
mConfig.Copy( dpos(i), copy.dpos(i), mConfig.Stride );
}
}

return *this;
}

~fhashtable_base()
{
free_arrays();
}

void init( const fhash_iface& f )
{
mConfig = f;
}

/// Clears the set
void clear()
{
free_arrays();
mSize = 0;
mMaxCount = 0;
mMask = 0;
mProbeOffset = 0;
mCount = 0;
mAge = 0;
}

/// Clears the set, but keeps our raw size the same
void clear_noalloc()
{
if ( mSize == 0 ) return;

ASSERT( fhash_Null == 0 );

if ( mConfig.BothNOP() )
{
// do nothing (such as for PODs)
}
else
{
for ( size_t i = 0; i < mSize; i++ )
{
if ( fhash_get_state(mState, i) == fhash_Full )
{
mConfig.Delete( dpos(i) );
mConfig.Create( dpos(i) );
}
}
}
memset( mState, 0, sizeof(fhashstate_t) * fhash_state_array_size(mSize) );

mCount = 0;
mAge = 0;
}

/// Number of elements in set
size_t size() const
{
return mCount;
}

/// Raw size of table
size_t raw_size() const
{
return mSize;
}

/** Resize the hashtable.
In general this is used to prepare the hashtable for a large number of insertions.
The hashtable is automatically resized during normal use.
There are some conditions that apply:
- If newsize == 0, the table is cleared.
- If 0 < newsize < 2 then newsize = 2.
- If newsize < mCount * mFillRatio then we debug assert, increase newsize, and proceed.
- If none of the above conditions apply, then newsize = NextPrime( newsize )
**/
void resize( size_t newsize )
{
if ( newsize < mCount * 2 )
newsize = mCount * 2;

if ( newsize == 0 ) { clear(); return; }

if ( newsize < 2 ) newsize = 2;
else newsize = fhash_next_power_of_2( newsize );

// save our current sate
byte			*odata = mData;
fhashstate_t	*ostate = mState;
size_t			 osize = mSize;

// allocate the new keys
mData = (byte*) malloc( newsize * mConfig.Stride );
mState = (fhashstate_t*) malloc( fhash_state_array_size(newsize) );
if ( mData == NULL || mState == NULL )
fhash_die();

// Make all the states null
memset( mState, 0, fhash_state_array_size(newsize) );

if ( mConfig.NCTor == fhash_TOR_NOP )		{}
else if ( mConfig.NCTor == fhash_TOR_ZERO )	memset( mData, 0, newsize * mConfig.Stride );
else
{
// Delay construction until after the move of the existing values. In that case, only slots that are not occupied need to be constructed.
// The delayed-construction thing could apply to the fhash_TOR_ZERO case too, but my guess is that it's probably better to let an efficient memset()
// do it's job - esp regarding write combining, etc.
//for ( size_t i = 0; i < newsize; i++ )
//	mConfig.Create( dpos(i) );
}

mCount = 0;
mSize = newsize;
mMaxCount = mSize >> 1;
mMask = mSize - 1;
mProbeOffset = mSize >> 1;
mAge = 0;

// Copy values
for ( size_t i = 0; i < osize; i++ )
if ( fhash_get_state( ostate, i ) == fhash_Full )
insert_no_check( false, odata + i * mConfig.Stride );

// Run constructors for new objects that were not copied
if ( mConfig.NCTor == fhash_TOR_FUNC )
{
for ( size_t i = 0; i < newsize; i++ )
if ( fhash_get_state( mState, i ) != fhash_Full )
mConfig.Create( dpos(i) );
}

// Run destructors for old objects that were not copied
if ( mConfig.NDTor == fhash_TOR_FUNC )
{
for ( size_t i = 0; i < osize; i++ )
if ( fhash_get_state( ostate, i ) == fhash_Null )
mConfig.Delete( odata + i * mConfig.Stride );
}

if (odata)	free(odata);
if (ostate) free(ostate);
}

void resize_for( size_t count )
{
return resize( count * 2 );
}

bool contains( const void* obj ) const
{
return _find( obj ) != fhash_npos;
}

iterator find( const void* obj )
{
return iterator( this, _find( obj ) );
}

/// \internal Searches linearly (for debugging this class)
bool linearfind( const void* obj ) const
{
for ( size_t i = 0; i < mSize; i++ )
{
if ( mConfig.KeyCmp( dpos(i), obj ) == 0 )
return true;
}
return false;
}

/// Returns the size of the data array + the size of the state array
size_t mem_usage() const
{
return mConfig.Stride * mSize + fhash_state_array_size(mSize);
}

/// Merge
fhashtable_base& operator+=( const fhashtable_base& b )
{
for ( iterator it = b.begin(); it != b.end(); it++ )
insert_check_exist( *it );
return *this;
}

/// Subtract
fhashtable_base& operator-=( const fhashtable_base& b )
{
for ( iterator it = b.begin(); it != b.end(); it++ )
_erase( *it );
return *this;
}

// Internal access
void* dpos( size_t i ) const { return mData + mConfig.Stride * i; }

/** Serializes the table to a file. Since this is a memory dump, it should only be used on tables whos elements contain no pointers.
After serialization the hash table is useless, and must not be touched again until after calling deserialize_pod.
@param mem The buffer in which to serialize.
@param bytes The size of the buffer. If the size is too small, then nothing will be written, and bytes will contain the necessary size.
**/
//void serialize_pod( void* mem, size_t& bytes )
//{
//	size_t s1 = mSize * sizeof(TData);
//	size_t s2 = stateArraySize( mSize ) * sizeof(fhashstate_t);
//	size_t required = s1 + s2;
//	if ( bytes < required )
//	{
//		bytes = required;
//		return;
//	}
//	if ( s1 + s2 == 0 ) return;
//	if ( mem == NULL ) { ASSERT(false); return; }
//	BYTE* bmem = (BYTE*) mem;
//	memcpy( bmem, mData, s1 );
//	memcpy( bmem + s1, mState, s2 );
//	free_arrays();
//}

/** Deserializes the table from a file.
No checks are made to ensure that you haven't touched the vector since it was serialized.
**/
//void deserialize_pod( const void* mem )
//{
//	ASSERT( mSize > 0 );
//	ASSERT( mData = NULL );

//	mState = new fhashstate_t[ stateArraySize(mSize) ];
//	mData = new TData[ mSize ];

//	size_t s1 = mSize * sizeof(TData);
//	size_t s2 = stateArraySize( mSize ) * sizeof(fhashstate_t);
//	if ( s1 + s2 == 0 ) return;
//	if ( mem == NULL ) { ASSERT(false); return; }
//	const BYTE* bmem = (const BYTE*) mem;
//	memcpy( mData, bmem, s1 );
//	memcpy( mState, bmem + s1, s2 );
//}

//size_t debug_table_pos( const TKey& obj, int i ) const
//{
//	fhashkey_t hkey = THashFunc::gethashcode( obj );
//	size_t pos = table_pos( hkey, i );
//	return pos;
//}

protected:

void base_init()
{
memset( &mConfig, 0, sizeof(mConfig) );
mData = NULL;
mState = NULL;
mMaxCount = 0;
mSize = 0;
mMask = 0;
mProbeOffset = 0;
mCount = 0;
mAge = 0;
mAutoShrink = true;
}

fhashkey_t get_hash_code( const void* obj ) const
{
return mConfig.GetHash( obj, mConfig.Stride );
}

/** Erases an item.
\return True if the item was found. False if the item was not found.
**/
bool _erase( const void* obj )
{
size_t pos = _find( obj );
if ( pos != fhash_npos )
{
mAge++;
mCount--;
fhash_set_state( mState, pos, fhash_Deleted );
delete_obj( dpos(pos) );
autoshrink();
return true;
}
else
return false;
}

void insert_check_resize()
{
if ( mCount >= mMaxCount )
resize( (mCount + 1) << 1 );
}

void copy_or_move( bool copy, void* dst, const void* obj )
{
if ( copy ) mConfig.Copy( dst, obj, mConfig.Stride );
else
{
// The ONLY path that hits this is when resizing the array, and copying over existing values. In that case, we have a target array of freshly constructed objects.
// We cannot simply memcpy over those fresh objects. We need to call their destructors first.
//if ( mConfig.NDTor == fhash_TOR_FUNC ) mConfig.Delete( dst );
// ALTERATION: We can simply memcpy over. The reason is because I've changed the initialization to delay running the constructors until after we've copied
// the existing values in. This is better because we avoid an unnecessary construction/destruction cycle.
mConfig.Move( dst, obj, mConfig.Stride );
}
}

/// Insert an item into the set without checking if it exists. Returns position of insertion.
size_t insert_no_check( bool copy, const void* obj )
{
insert_check_resize();
fhashkey_t hkey = get_hash_code( obj );
size_t pos = table_pos( hkey );
fhash_key_states state = fhash_get_state( mState, pos );
if ( state == fhash_Full )
{
// Search for an empty slot
uint i = 0;
while ( state == fhash_Full )
{
pos = table_pos( hkey, ++i );
state = fhash_get_state( mState, pos );
if ( i >= mSize ) ASSERT( false );
}
}
fhash_set_state( mState, pos, fhash_Full );
copy_or_move( copy, dpos(pos), obj );
mCount++;
return pos;
}

/** Insert an item into the set.

@param overwrite If true, then we overwrite any existing value for the specified key. This is a specialization
that is only applicable to hash maps (not hash sets).

@return fhash_npos if item already in table (only possible if overwrite is false).

**/
size_t insert_check_exist( const void* obj, bool overwrite = false )
{
insert_check_resize();

fhashkey_t hkey = get_hash_code( obj );

// We insert at the first deleted slot, or the first null slot, whichever comes first
// However, we must scan until (1. Find existing) or (2. Scanned entire table)
size_t pos = fhash_npos;
size_t pos_ins = fhash_npos; // remember the first fhash_Deleted position, because that is where we will insert, if we're not already existent
for ( uint i = 0; i != mSize; i++ )
{
pos = table_pos( hkey, i );
fhash_key_states ks = fhash_get_state( mState, pos );
if ( ks == fhash_Full )
{
if ( mConfig.KeyCmp( dpos(pos), obj ) == 0 )
{
// key already present
if ( overwrite )
{
copy_or_move( true, dpos(pos), obj );
return pos;
}
else
return fhash_npos;
}
}
else if ( ks == fhash_Null )
{
if ( pos_ins == fhash_npos ) pos_ins = pos;
break;
}
else /* if ( state == fhash_Deleted ) */
{
if ( pos_ins == fhash_npos ) pos_ins = pos;
}
}

// insert here
fhash_set_state( mState, pos_ins, fhash_Full );
copy_or_move( true, dpos(pos_ins), obj );
mCount++;
return pos_ins;
}

void free_arrays()
{
if ( mConfig.NDTor == fhash_TOR_NOP ) {}
else
{
for ( size_t i = 0; i < mSize; i++ )
mConfig.Delete( dpos(i) );
}

free(mData); mData = NULL;
free(mState); mState = NULL;
}

void delete_obj( void* obj )
{
if ( mConfig.NDTor == fhash_TOR_NOP ) return;
mConfig.Delete( obj );
}

void create_obj( void* obj )
{
if ( mConfig.NCTor == fhash_TOR_NOP ) return;
mConfig.Create( obj );
}

/// Returns the position of an item if existent
size_t _find( const void* obj ) const
{
if ( mSize == 0 ) return fhash_npos;
fhashkey_t hkey = get_hash_code( obj );
size_t pos = table_pos( hkey );
size_t first = pos;
// quick positive/empty check
fhash_key_states ks = fhash_get_state( mState, pos );
if ( ks == fhash_Full && mConfig.KeyCmp( dpos(pos), obj ) == 0 ) return pos;
else if ( ks == fhash_Null ) return fhash_npos;
else
{
// exhaustive
uint i = 0;
pos = table_pos( hkey, ++i );
while ( fhash_get_state(mState, pos) != fhash_Null )
{
if ( fhash_get_state(mState, pos) == fhash_Full && mConfig.KeyCmp( dpos(pos), obj ) == 0 ) return pos;
pos = table_pos( hkey, ++i );
if ( pos == first ) break;
}
return fhash_npos;
}
}

/// Erases all instances of key. Returns number of items erased.
size_t _erase_all( const void* obj )
{
if ( mSize == 0 ) return 0;
fhashkey_t hkey = get_hash_code( obj );
size_t pos = table_pos( hkey );
size_t first = pos;
size_t del = 0;
uint i = 0;
while ( true )
{
fhash_key_states state = fhash_get_state(mState, pos);
if ( state == fhash_Full && mConfig.KeyCmp( dpos(pos), obj ) == 0 )
{
del++;
delete_obj( dpos(pos) );
fhash_set_state( mState, pos, fhash_Deleted );
}
else if ( state == fhash_Null ) break;
pos = table_pos( hkey, ++i );
if ( pos == first ) break;
}
return del;
}

/// The hash function (optimization of generic table_pos with i = 0)
size_t table_pos( fhashkey_t key ) const
{
return (size_t) (fold(key) & mMask);
}

/// probe (when i = 0, this function must be identical to table_pos(key))
size_t table_pos( fhashkey_t key, uint i ) const
{
key = fold(key);
uint mul = key >> 1;
mul |= 1; // ensure multiplier is odd
return (size_t) ((key + i * mul) & mMask);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// NOTE: This code used to be inside table_pos, but it is invalid. It violates our "visit every slot exactly once" rule.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// This offset particularly helps speed up failed lookups when our table is a dense array of integers (consecutive hashes).
//// The layout in that case is that half of the table is completely occupied, and the other half (remember our fill factor -- there is always an 'other half')
//// is completely empty. This probe offset immediately sends us into the territory of the 'other half', thereby reducing the time that we spend walking through
//// the populated half.

//// The difference here seems to be negligible, but the simpler version should be better for future compilers.
//uint offset = i == 0 ? 0 : (uint) mProbeOffset;
////uint offset = ~(int(i - 1) >> 31) & mProbeOffset; // branch-less version
//return (size_t) ((key + offset + i * mul) & mMask);
///////////////////////////////////////////////////////////////////////////////


// Very simple mix function that at least gives us better behaviour when the only entropy is higher than our mask.
// This simplistic function probably causes evil behaviour in certain pathological cases, but it's better than not having it at all.
// This mixing solves cases such as values of the form 0x03000000, 0x04000000, 0x05000000. Without this folding
// function, those keys would all end up with the same table position, unless the table was larger than 0x0fffffff.
static fhashkey_t fold( fhashkey_t k )
{
uint32 u = k;
u = u ^ (u >> 16);
u = u ^ (u >> 8);
return u;
}

void autoshrink()
{
if ( (mAge & (32-1)) != 0 || !mAutoShrink ) return;

// Only shrink when we're more than 2x the size we need to be. The reason this is not
// simply 1x is to avoid possible ping-ponging during a repeated insert/erase pattern.
size_t necessary = fhash_next_power_of_2( mCount * 2 );

// I don't like having this heuristic here of fhash_min_autoshrink_count, but in all practicality, I have never made a hash table with such a huge key size
// that it would matter that you're storing 64 and not 32 or 16.
if ( mSize > necessary * 2 && mSize > fhash_min_autoshrink_count )
resize( 0 );
}

void move( void* dst, const void* src )
{
mConfig.Move( dst, src, mConfig.Stride );
}
void copy( void* dst, const void* src )
{
mConfig.Copy( dst, src, mConfig.Stride );
}

byte			*mData;			///< Key Array
fhashstate_t	*mState;		///< State Array (null, occupied, deleted)
unsigned int	mAge;			///< Incremented when item is erased
size_t			mMaxCount;		///< Maximum count before we must increase our raw size
size_t			mSize;			///< Size of table
size_t			mProbeOffset;	///< Initial offset of probe	(only used when not OHASH_PRIME_SIZE)
size_t			mMask;			///< Size of table - 1			(only used when not OHASH_PRIME_SIZE)
size_t			mCount;			///< Number of items in set
bool			mAutoShrink;	///< If true, then the table automatically shrinks itself when it's mAge reaches a certain limit

fhash_iface		mConfig;

public:

/** Enables or disables auto-shrinking.
Auto-shrinking needs to be disabled if you wish to iterate through the set and erase items as you are going.
**/
void auto_shrink( bool on )
{
if ( on == mAutoShrink ) return;
mAutoShrink = on;
if ( on ) autoshrink();
}

iterator begin() const	{ return iterator (this); }
iterator end() const	{ return iterator (this, fhash_npos); }

friend class fhashtable_base::iterator;
};

// This is basically just here for packing two things together in memory before calling into the base hash table
template< typename TKey, typename TVal >
struct fhash_pair
{
fhash_pair( const TKey& k, const TVal& v )
{
Key = k;
Val = v;
}
TKey Key;
TVal Val;
};

template< typename TKey >
void fhash_setup_set( fhash_iface& f )
{
f.Stride = sizeof(TKey);
fhash_tor_types<TKey>( f.NCTor, f.NDTor );
ASSERT( f.NDTor != fhash_TOR_ZERO ); // not allowed. use either FUNC or NOP for dtor
f.Create = &fhash_type_ctor<TKey>;
f.Delete = &fhash_type_dtor<TKey>;
f.Copy = &fhash_type_copy<TKey>;
f.Move = &fhash_pod_move;
f.KeyCmp = &fhash_keycmp<TKey>;
f.GetHash = &fhash_gethash_gen_wrap<TKey>;
}

inline fhash_tor_type fhash_reduce( fhash_tor_type a, fhash_tor_type b )
{
if ( a == fhash_TOR_NOP && b == fhash_TOR_NOP ) return fhash_TOR_NOP;
if ( a == fhash_TOR_FUNC || b == fhash_TOR_FUNC ) return fhash_TOR_FUNC;
return fhash_TOR_ZERO;
}

template< typename TKey, typename TVal >
void fhash_setup_map( fhash_iface& f, size_t msize )
{
f.Stride = msize;
fhash_tor_type ckey, dkey;
fhash_tor_type cval, dval;
fhash_tor_types<TKey>( ckey, dkey );
fhash_tor_types<TVal>( cval, dval );
ASSERT( dkey != fhash_TOR_ZERO && dval != fhash_TOR_ZERO ); // not allowed. use either FUNC or NOP for dtor
f.NCTor = fhash_reduce( ckey, cval );
f.NDTor = fhash_reduce( dkey, dval );
f.Create = &fhash_type_ctor_pair<TKey, TVal>;
f.Delete = &fhash_type_dtor_pair<TKey, TVal>;
f.Copy = &fhash_type_copy_pair<TKey, TVal>;
f.Move = &fhash_pod_move;
f.KeyCmp = &fhash_keycmp<TKey>;
f.GetHash = &fhash_gethash_gen_wrap<TKey>;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hash Map
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template< typename TKey, typename TVal >
class fhashmap : public fhashtable_base
{
public:
typedef fhash_pair<TKey, TVal> TPair;
static const size_t TSize = sizeof(TKey) + sizeof(TVal);

fhashmap()
{
fhash_setup_map<TKey, TVal>( mConfig, sizeof(TKey) + sizeof(TVal) );
}

void insert( const TKey& key, const TVal& val, bool overwrite = true )
{
char t[TSize];
memcpy( t, &key, sizeof(TKey) );
memcpy( t + sizeof(TKey), &val, sizeof(TVal) );
insert_check_exist( t, overwrite );
}

bool erase( const TKey& key )
{
return _erase( &key );
}

bool contains( const TKey& key ) const { return _find(&key) != fhash_npos; }

TVal* getp( const TKey& key ) const
{
size_t pos = _find( &key );
if ( pos == fhash_npos ) return NULL;
return offset_val(dpos(pos));
}

TVal get( const TKey& key ) const
{
TVal* p = getp( key );
return p ? *p : TVal();
}

bool get( const TKey& key, TVal& val ) const
{
TVal* p = getp( key );
if ( p ) val = *p;
return p != NULL;
}

template<typename TContainer>
void keys( TContainer& keys ) const
{
for ( auto it = begin(); it != end(); it++ )
keys += it.key();
}

template<typename TContainer>
void values( TContainer& vals ) const
{
for ( auto it = begin(); it != end(); it++ )
vals += it.val();
}

// We do not allow assignment via operator[], because it is ambiguous. You don't know whether you're assigning
// an empty string or fetching a value without knowing whether your instance is const or now, and I've burned myself like that.
TVal operator[]( const TKey& key ) const
{
return get(key);
}

/////////////////////////////////////////////////////////////////////////////////////
// Iterator
/////////////////////////////////////////////////////////////////////////////////////

class iterator : public fhashtable_base::iterator
{
public:
typedef fhashtable_base::iterator base;
iterator() : base() {}
iterator( const fhashtable_base* p, size_t itpos ) : base(p,itpos) {}
iterator( const fhashtable_base* p ) : base(p) {}

const TKey& key() const	{ return *((const TKey*) parent->dpos(pos)); }
const TVal& val() const { return *((const TVal*) offset_val(parent->dpos(pos))); }
};

friend class iterator;

iterator begin() const	{ return iterator(this); }
iterator end() const	{ return iterator(this, fhash_npos); }

protected:
static TVal* offset_val( void* p ) { return (TVal*) ((char*) p + sizeof(TKey)); }
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hash Set
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template< typename TKey >
class fhashset : public fhashtable_base
{
public:
static const size_t TSize = sizeof(TKey);

fhashset()
{
fhash_setup_set<TKey>( mConfig );
}

void insert( const TKey& key )				{ insert_check_exist( &key, false ); }
bool erase( const TKey& key )				{ return _erase( &key ); }
bool contains( const TKey& key ) const		{ return _find(&key) != fhash_npos; }

fhashset& operator+=( const TKey& key )		{ insert(key); return *this; }
fhashset& operator-=( const TKey& key )		{ erase(key); return *this; }

/////////////////////////////////////////////////////////////////////////////////////
// Iterator
/////////////////////////////////////////////////////////////////////////////////////

class iterator : public fhashtable_base::iterator
{
public:
typedef fhashtable_base::iterator base;
iterator() : base() {}
iterator( const fhashtable_base* p, size_t itpos ) : base(p,itpos) {}
iterator( const fhashtable_base* p ) : base(p) {}

const TKey& operator*() const	{ return *((const TKey*) parent->dpos(pos)); }
};

friend class iterator;

iterator begin() const	{ return iterator(this); }
iterator end() const	{ return iterator(this, fhash_npos); }
};


#endif



// These types must always be resolvable by the linker as simply what you see here. No templates, and no constructors.
// Basically the only important thing here is the memory layout.

struct vec2
{
double x, y;
};

struct vec2f
{
float x, y;
};

struct vec3
{
double x, y, z;
};

struct vec3f
{
float x, y, z;
};

struct vec4
{
double x, y, z, w;
};

struct vec4f
{
float x, y, z, w;
};

template<typename T>	bool vec_IsNaN( T v )			{ return v != v; }
inline					bool vec_IsFinite( float v )	{ return v <= FLT_MAX && v >= -FLT_MAX; }
inline					bool vec_IsFinite( double v )	{ return v <= DBL_MAX && v >= -DBL_MAX; }


//#ifndef MIX_NO_AXIS_NAMES
//enum Axis {X=0, Y=1, Z=2, W=3};
//#define MIX_NO_AXIS_NAMES
//#endif
#define X (0)
#define Y (1)
#define Z (2)
#define W (3)

// in matrix, which column mean Right, Up, and Normal
#define UL_R (X)
#define UL_U (Y)
#define UL_N (Z)

#define XX row[0].x
#define XY row[0].y
#define XZ row[0].z
#define XW row[0].w

#define YX row[1].x
#define YY row[1].y
#define YZ row[1].z
#define YW row[1].w

#define ZX row[2].x
#define ZY row[2].y
#define ZZ row[2].z
#define ZW row[2].w

#define WX row[3].x
#define WY row[3].y
#define WZ row[3].z
#define WW row[3].w



/*
Why do we have VecBase2T and Vec2T ?
VecBase2T exists so that we can include it inside unions. Thus, it defines no constructors.
Users of these classes should not need to know about VecBase2T. They should simply use Vec2T.
Unless, of course, they need to include these things inside unions. In that case the facade breaks
down.
*/


#ifndef DEFINED_Vec2
#define DEFINED_Vec2

template <typename vreal>
class Vec2Traits
{
public:
static const TCHAR* StringFormat() { return _T("[ %g %g ]"); }
static const TCHAR* StringFormatBare() { return _T("%g %g"); }
static const char* StringAFormatBare() { return "%g %g"; }
};

template <>
class Vec2Traits<float>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.6g %.6g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.6g %.6g"); }
static const char* StringAFormatBare() { return "%.6g %.6g"; }
};

template <>
class Vec2Traits<double>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.10g %.10g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.10g %.10g"); }
static const char* StringAFormatBare() { return "%.10g %.10g"; }
};

// The "Base" class has no constructor, so that it can be included inside a union
// Inside the base class, we do not expose any functions that leak our type
// For example, we cannot expose component-wise multiply, because that would
// leak VecBase2T to the outside world.
template <typename vreal>
class VecBase2T
{
public:
static const int Dimensions = 2;
typedef vreal FT;

vreal x, y;

/////////////////////////////////////////////////////////////////////////////////////////////
// Mutating operations
/////////////////////////////////////////////////////////////////////////////////////////////

void set(const vreal _x, const vreal _y)
{
x = _x;
y = _y;
}

void normalize()
{
double r = 1.0 / sqrt(x * x + y * y);
x *= r;
y *= r;
}

void normalizeIfNotZero()
{
double lenSq = x * x + y * y;
if ( lenSq != 0 )
{
double r = 1.0 / sqrt(lenSq);
x *= r;
y *= r;
}
}

void scale(vreal _scale)
{
x *= _scale;
y *= _scale;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// const operations
/////////////////////////////////////////////////////////////////////////////////////////////

vreal operator&(const VecBase2T &b) const {
return x*b.x + y*b.y;
}
vreal dot(const VecBase2T &b) const {
return x*b.x + y*b.y;
}

// comparison operators
bool operator==(const VecBase2T& v) const
{
return x == v.x && y == v.y;
}
bool operator!=(const VecBase2T& v) const
{
return x != v.x || y != v.y;
}

vreal sizeSquared() const {
return x*x + y*y;
}
vreal size() const {
return sqrt(x*x + y*y);
}

vreal distance(const VecBase2T &b) const	{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y)); }
vreal distance2d(const VecBase2T &b) const	{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y)); }
vreal distance3d(const VecBase2T &b) const	{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y)); }
vreal distanceSQ(const VecBase2T &b) const	{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }

vreal distance2dSQ(const VecBase2T &b) const	{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }
vreal distance3dSQ(const VecBase2T &b) const	{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y); }

// makes sure all members are not NaN
bool checkNaN() const
{
if ( vec_IsNaN(x) || vec_IsNaN(y) )
return false;
return true;
}

/// Only valid for Vec2T<double>. Checks whether we won't overflow if converted to float.
bool checkFloatOverflow() const
{
if (	x > FLT_MAX || x < -FLT_MAX ||
y > FLT_MAX || y < -FLT_MAX ) return false;
return true;
}

void copyTo( vreal *dst ) const
{
dst[0] = x;
dst[1] = y;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Duplicated inside Vec2T
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
VecBase2T& operator-=(const VecBase2T &b)	{ x -= b.x; y -= b.y; return *this; }
VecBase2T& operator+=(const VecBase2T &b)	{ x += b.x; y += b.y; return *this; }
VecBase2T& operator*=(const VecBase2T &b)	{ x *= b.x; y *= b.y; return *this; }
VecBase2T& operator/=(const VecBase2T &b)	{ x /= b.x; y /= b.y; return *this; }
VecBase2T& operator/=(vreal s)				{ vreal r = 1.0 / s; 	x *= r; y *= r;	return *this; }
VecBase2T& operator*=(vreal s)				{						x *= s; y *= s; return *this; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

};

template <typename vreal>
class Vec2T : public VecBase2T<vreal>
{
public:
typedef vreal FT;
using VecBase2T<vreal>::x;
using VecBase2T<vreal>::y;

Vec2T()													{}
Vec2T( vreal _x, vreal _y )								{ x = _x; y = _y; }
Vec2T( const VecBase2T<vreal>& b )						{ x = b.x; y = b.y; }

static Vec2T Create( vreal x, vreal y )
{
Vec2T v;
v.x = x;
v.y = y;
return v;
}

/// Returns a vector that is [cos(angle), sin(angle)]
static Vec2T AtAngle( vreal angle )
{
return Vec2T::Create( cos(angle), sin(angle) );
}

const Vec2T& AsVec2() const { return *this; }
Vec2T& AsVec2()       { return *this; }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Duplicated inside VecBase2T
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
Vec2T& operator-=(const Vec2T &b)		{ x -= b.x; y -= b.y; return *this; }
Vec2T& operator+=(const Vec2T &b)		{ x += b.x; y += b.y; return *this; }
Vec2T& operator*=(const Vec2T &b)		{ x *= b.x; y *= b.y; return *this; }
Vec2T& operator/=(const Vec2T &b)		{ x /= b.x; y /= b.y; return *this; }
Vec2T& operator/=(vreal s)				{ vreal r = 1.0 / s; 	x *= r; y *= r;	return *this; }
Vec2T& operator*=(vreal s)				{						x *= s; y *= s; return *this; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

Vec2T normalized() const
{
Vec2T copy = *this;
copy.normalize();
return copy;
}

Vec2T normalizedIfNotZero() const
{
Vec2T copy = *this;
copy.normalizeIfNotZero();
return copy;
}

// unary
Vec2T operator-() const  {  return Vec2T(-x, -y);  }

/// Returns the result of sprintf
int ToStringABare( char* buff, size_t buffChars ) const
{
return sprintf_s( buff, buffChars, Vec2Traits<vreal>::StringAFormatBare(), x, y );
}

#ifndef NO_XSTRING
/// Writes "[ %g %g ]"
XString ToString() const
{
XString s;
s.Format( Vec2Traits<vreal>::StringFormat(), x, y );
return s;
}

/// Writes "%g %g"
XString ToStringBare() const
{
XString s;
s.Format( Vec2Traits<vreal>::StringFormatBare(), x, y );
return s;
}

/// Writes "[ %g %g ]" or "%g %g"
XString ToString( int significant_digits, bool bare = false ) const
{
XString f, s;
if ( bare ) f.Format( _T("%%.%dg %%.%dg"), significant_digits, significant_digits );
else		f.Format( _T("[ %%.%dg %%.%dg ]"), significant_digits, significant_digits );
s.Format( f, x, y );
return s;
}

/// Parses "[ x y ]", "x y", "x,y"
bool Parse( const XString& str )
{
double a, b;
#ifdef LM_VS2005_SECURE
if ( _stscanf_s( str, _T("[ %lf %lf ]"), &a, &b ) != 2 )
{
if ( _stscanf_s( str, _T("%lf %lf"), &a, &b ) != 2 )
{
if ( _stscanf_s( str, _T("%lf, %lf"), &a, &b ) != 2 )
{
return false;
}
}
}
#else
if ( _stscanf( str, _T("[ %lf %lf ]"), &a, &b ) != 2 )
{
if ( _stscanf( str, _T("%lf %lf"), &a, &b ) != 2 )
{
if ( _stscanf( str, _T("%lf, %lf"), &a, &b ) != 2 )
{
return false;
}
}
}
#endif
x = (vreal) a;
y = (vreal) b;

return true;
}

static Vec2T FromString( const XString& str )
{
Vec2T v;
v.Parse( str );
return v;
}

#endif

};

template<typename vreal> inline Vec2T<vreal> operator*(const VecBase2T<vreal> &a, vreal s)							{ return Vec2T<vreal>(a.x * s,   a.y * s); }
template<typename vreal> inline Vec2T<vreal> operator*(vreal s, const VecBase2T<vreal> &a)							{ return Vec2T<vreal>(a.x * s,   a.y * s); }
template<typename vreal> inline Vec2T<vreal> operator*(const VecBase2T<vreal> &a, const VecBase2T<vreal> &b)		{ return Vec2T<vreal>(a.x * b.x, a.y * b.y); }
template<typename vreal> inline Vec2T<vreal> operator+(const VecBase2T<vreal> &a, const VecBase2T<vreal> &b)		{ return Vec2T<vreal>(a.x + b.x, a.y + b.y); }
template<typename vreal> inline Vec2T<vreal> operator-(const VecBase2T<vreal> &a, const VecBase2T<vreal> &b)		{ return Vec2T<vreal>(a.x - b.x, a.y - b.y); }
template<typename vreal> inline Vec2T<vreal> operator/(const VecBase2T<vreal> &a, const VecBase2T<vreal> &b)		{ return Vec2T<vreal>(a.x / b.x, a.y / b.y); }
template<typename vreal> inline Vec2T<vreal> operator/(const vreal s, const Vec2T<vreal> &b)						{ return Vec2T<vreal>(s   / b.x, s   / b.y ); }
template<typename vreal> inline vreal        dot(const VecBase2T<vreal>& a, const VecBase2T<vreal>& b)				{ return a.x * b.x + a.y * b.y; }
template<typename vreal> inline Vec2T<vreal> operator/(const VecBase2T<vreal> &a, const vreal s)					{ vreal rec = (vreal) 1.0 / s; return Vec2T<vreal>(a.x * rec, a.y * rec); }
template<typename vreal> inline Vec2T<vreal> normalize(const VecBase2T<vreal>& a)									{ Vec2T<vreal> copy = a; copy.normalized(); return copy; }
template<typename vreal> inline vreal        length(const VecBase2T<vreal>& a)										{ return a.size(); }
template<typename vreal> inline vreal        lengthSQ(const VecBase2T<vreal>& a)									{ return a.sizeSquared(); }

template <class vreal> INLINE bool
operator <= (const Vec2T<vreal>& v1, const Vec2T<vreal>& v2)
{
return v1.x <= v2.x && v1.y <= v2.y;
}

template <class vreal> INLINE bool
operator < (const Vec2T<vreal>& v1, const Vec2T<vreal>& v2)
{
return v1.x < v2.x && v1.y < v2.y;
}


template <class vreal> INLINE bool
operator > (const Vec2T<vreal>& v1, const Vec2T<vreal>& v2)
{
return v1.x > v2.x && v1.y > v2.y;
}

template <class vreal> INLINE bool
operator >= (const Vec2T<vreal>& v1, const Vec2T<vreal>& v2)
{
return v1.x >= v2.x && v1.y >= v2.y;
}

typedef Vec2T<double> Vec2d;
typedef Vec2T<float> Vec2f;
typedef Vec2d Vec2;

#ifdef DVECT_DEFINED
typedef dvect< Vec2f > Vec2fVect;
typedef dvect< Vec2d > Vec2dVect;
#endif

inline Vec2		ToVec2( vec2 v )  { return Vec2::Create( v.x, v.y ); }
inline Vec2		ToVec2( Vec2f v ) { return Vec2::Create( v.x, v.y ); }
inline Vec2f	ToVec2f( Vec2 v ) { return Vec2f::Create( (float) v.x, (float) v.y ); }

#endif // DEFINED_Vec2



// See Vec2.h for a readme of what we are doing here
#ifndef DEFINED_Vec3
#define DEFINED_Vec3

template <typename vreal>
class Vec3Traits
{
public:
static const TCHAR* StringFormat() { return _T("[ %g %g %g ]"); }
static const TCHAR* StringFormatBare() { return _T("%g %g %g"); }
static const char* StringAFormatBare() { return "%g %g %g"; }
};

template <>
class Vec3Traits<float>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.6g %.6g %.6g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.6g %.6g %.6g"); }
static const char* StringAFormatBare() { return "%.6g %.6g %.6g"; }
};

template <>
class Vec3Traits<double>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.10g %.10g %.10g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.10g %.10g %.10g"); }
static const char* StringAFormatBare() { return "%.10g %.10g %.10g"; }
};

// The "Base" class has no constructor, so that it can be included inside a union
// Inside the base class, we do not expose any functions that leak our type
// For example, we cannot expose component-wise multiply, because that would
// leak VecBase3T to the outside world.
template <typename vreal>
class VecBase3T
{
public:
static const int Dimensions = 3;
typedef vreal FT;

union
{
struct
{
vreal x,y,z;
};
struct
{
vreal v[3];
};
struct
{
VecBase2T<vreal> vec2;
};
struct
{
vreal n[3];
};
};

static VecBase3T create(vreal _x, vreal _y, vreal _z) { VecBase3T b = {_x,_y,_z}; return b; }

void set(const vreal _x, const vreal _y, const vreal _z) {		x = _x;		y = _y;		z = _z;	}

// fills all with _uniform
void set( const vreal _uniform ) 	{	x = _uniform;	y = _uniform;	z = _uniform;	}

void scale(vreal _scale)
{
x *= _scale;
y *= _scale;
z *= _scale;
}

vreal size() const								{ return sqrt(x*x + y*y + z*z); }
vreal sizeSquared() const						{ return x*x + y*y + z*z; }
vreal size2Squared() const						{ return x*x + y*y; }
vreal distance(const VecBase3T &b) const		{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z)); }
vreal distance3d(const VecBase3T &b) const		{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z)); }
vreal distance2d(const VecBase3T &b) const		{ return sqrt((b.x-x)*(b.x-x) + (b.y-y)*(b.y-y)); }
vreal distance3dSQ(const VecBase3T &b) const	{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z); }
vreal distanceSQ(const VecBase3T &b) const		{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z); }
vreal distance2dSQ(const VecBase3T &b) const	{ return (b.x-x)*(b.x-x) + (b.y-y)*(b.y-y); }

vreal	operator[](int i) const { return v[i]; }
vreal&	operator[](int i)		{ return v[i]; }

vreal	operator()(int i) const { return v[i]; }
vreal&	operator()(int i)		{ return v[i]; }

void cross(const VecBase3T &u, const VecBase3T &v)
{
x = u.y * v.z - u.z * v.y;
y = u.z * v.x - u.x * v.z;
z = u.x * v.y - u.y * v.x;
}

/// Clamps values individually
void clamp( vreal vmin, vreal vmax )
{
x = CLAMP( x, vmin, vmax );
y = CLAMP( y, vmin, vmax );
z = CLAMP( z, vmin, vmax );
}

// Returns false if any member is a NaN.
bool checkNaN() const
{
return !IsNan();
}

/// Returns true if any member is a NaN.
bool IsNan() const
{
return vec_IsNaN(x) || vec_IsNaN(y) || vec_IsNaN(z);
}

/// Only valid for VecBase3T<double>. Checks whether we won't overflow if converted to float.
bool checkFloatOverflow() const
{
if (	x > FLT_MAX || x < -FLT_MAX ||
y > FLT_MAX || y < -FLT_MAX ||
z > FLT_MAX || z < -FLT_MAX ) return false;
return true;
}

// sets all values to FLT_MIN
void setNull()
{
x = FLT_MIN;
y = FLT_MIN;
z = FLT_MIN;
}

bool isNull() const
{
return x == FLT_MIN && y == FLT_MIN && z == FLT_MIN;
}

void normalize()
{
vreal s = (vreal) 1.0 / sqrt(sizeSquared());
x *= s;
y *= s;
z *= s;
}

void copyTo( vreal *dst ) const
{
dst[0] = x;
dst[1] = y;
dst[2] = z;
}

// only normalizes if size is not zero. Returns 0 if size() > 0
// Sets vector to (1,0,0) if size is 0, and returns -1.
int normalizeCheck()
{
vreal s = sizeSquared();
if (s == 0)
{
x = 1;
y = 0;
z = 0;
return -1;
}
s = (vreal) 1.0 / sqrt(s);
x *= s;
y *= s;
z *= s;
return 0;
}

VecBase3T operator-() const { return VecBase3T::create(-x, -y, -z); }

// comparison operators
bool operator==(const VecBase3T& v) const { return x == v.x && y == v.y && z == v.z; }
bool operator!=(const VecBase3T& v) const { return x != v.x || y != v.y || z != v.z; }

vreal dot(const VecBase3T& b) const { return x * b.x + y * b.y + z * b.z; }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Duplicated inside Vec3T
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
VecBase3T& operator+=(const VecBase3T &b)	{ x += b.x; y += b.y; z += b.z;						return *this; }
VecBase3T& operator-=(const VecBase3T &b)	{ x -= b.x; y -= b.y; z -= b.z;						return *this; }
VecBase3T& operator*=(const VecBase3T &b)	{ x *= b.x; y *= b.y; z *= b.z;						return *this; }
VecBase3T& operator*=(const vreal d)		{ 						x *= d;	y *= d; z *= d;		return *this; }
VecBase3T& operator/=(const vreal d)		{ vreal r = 1.0 / d;	x *= r; y *= r; z *= r;		return *this; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
};

template <typename vreal>
class Vec3T : public VecBase3T<vreal>
{
public:
typedef vreal FT;
using VecBase3T<vreal>::x;
using VecBase3T<vreal>::y;
using VecBase3T<vreal>::z;
using VecBase3T<vreal>::v;
using VecBase3T<vreal>::vec2;
using VecBase3T<vreal>::n;
using VecBase3T<vreal>::normalizeCheck;

Vec3T()													{}
Vec3T( vreal _x, vreal _y, vreal _z )					{ x = _x; y = _y; z = _z; }
Vec3T( const VecBase3T<vreal>& b )						{ x = b.x; y = b.y; z = b.z; }
Vec3T( const VecBase2T<vreal>& v2, const vreal _z )		{ x = v2.x, y = v2.y, z = _z; }
explicit Vec3T( vreal _uniform )						{ x = y = z = _uniform; }

static Vec3T Create( vreal x, vreal y, vreal z )
{
Vec3T v;
v.x = x;
v.y = y;
v.z = z;
return v;
}

static Vec3T null()
{
Vec3T v;
v.setNull();
return v;
}

/// Returns a vector that is [cos(angle), sin(angle), 0]
static Vec3T AtAngle( vreal angle )
{
return Vec3T::Create( cos(angle), sin(angle), 0 );
}

const Vec2T<vreal>& AsVec2() const    	{ return (const Vec2T<vreal>&) vec2; }
Vec2T<vreal>& AsVec2()          	{ return (Vec2T<vreal>&) vec2; }
const Vec3T<vreal>& AsVec3() const		{ return *this; }
Vec3T<vreal>& AsVec3()			{ return *this; }

Vec3T operator-() const { return Vec3T(-x, -y, -z); }

Vec3T projectionOn3dLine(const VecBase3T<vreal> &p1, const VecBase3T<vreal> &p2) const
{
double u = ((*this - p1) & (p2 - p1)) / (p2 - p1).sizeSquared();
return p1 + u*(p2-p1);
}

Vec3T normalized() const
{
Vec3T copy = *this;
copy.normalize();
return copy;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Duplicated inside VecBase3T
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
Vec3T& operator+=(const Vec3T &b)	{ x += b.x; y += b.y; z += b.z;						return *this; }
Vec3T& operator-=(const Vec3T &b)	{ x -= b.x; y -= b.y; z -= b.z;						return *this; }
Vec3T& operator*=(const Vec3T &b)	{ x *= b.x; y *= b.y; z *= b.z;						return *this; }
Vec3T& operator*=(const vreal d)	{ 						x *= d;	y *= d; z *= d;		return *this; }
Vec3T& operator/=(const vreal d)	{ vreal r = 1.0 / d;	x *= r; y *= r; z *= r;		return *this; }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

// some swizzlers... i doubt these are used much
Vec2T<vreal>	xx() const		{ return Vec2T<vreal>(x, x); }
Vec2T<vreal>	yy() const		{ return Vec2T<vreal>(y, y); }
Vec2T<vreal>	xy() const		{ return Vec2T<vreal>(x, y); }
Vec2T<vreal>	yx() const		{ return Vec2T<vreal>(y, x); }
Vec3T			xxx() const		{ return Vec3T::Create(x, x, x); }
Vec3T			yyy() const		{ return Vec3T::Create(y, y, y); }
Vec3T			zzz() const		{ return Vec3T::Create(z, z, z); }
Vec3T			zyx() const		{ return Vec3T::Create(z, y, x); }

Vec3T        operator^(const VecBase3T<vreal>& v) const;
int MakeOrthonormalBasis(VecBase3T<vreal> & base1, VecBase3T<vreal> & base2);

int ToStringABare( char* buff, size_t buffChars ) const
{
return sprintf_s( buff, buffChars, Vec3Traits<vreal>::StringAFormatBare(), x, y, z );
}

#ifndef NO_XSTRING
/// Writes "[ %.8g %.8g %.8g ]"
XString ToString() const
{
XString s;
s.Format( Vec3Traits<vreal>::StringFormat(), x, y, z );
return s;
}

/// Writes "%lf %lf %lf"
XString ToStringBare() const
{
XString s;
s.Format( Vec3Traits<vreal>::StringFormatBare(), x, y, z );
return s;
}

XString ToString( int significant_digits, bool bare = false ) const
{
XString f, s;
if ( bare ) f.Format( _T("%%.%dg %%.%dg %%.%dg"), significant_digits, significant_digits, significant_digits );
else		f.Format( _T("[ %%.%dg %%.%dg %%.%dg ]"), significant_digits, significant_digits, significant_digits );
s.Format( f, x, y, z );
return s;
}

/// Parses "[ x y z ]", "x y z", "x,y,z"
bool Parse( const XString& str )
{
double a, b, c;
#ifdef LM_VS2005_SECURE
if ( _stscanf_s( str, _T("[ %lf %lf %lf ]"), &a, &b, &c ) != 3 )
{
if ( _stscanf_s( str, _T("%lf %lf %lf"), &a, &b, &c ) != 3 )
{
if ( _stscanf_s( str, _T("%lf, %lf, %lf"), &a, &b, &c ) != 3 )
{
return false;
}
}
}
#else
if ( _stscanf( str, _T("[ %lf %lf %lf ]"), &a, &b, &c ) != 3 )
{
if ( _stscanf( str, _T("%lf %lf %lf"), &a, &b, &c ) != 3 )
{
if ( _stscanf( str, _T("%lf, %lf, %lf"), &a, &b, &c ) != 3 )
{
return false;
}
}
}
#endif
x = (vreal) a;
y = (vreal) b;
z = (vreal) c;

return true;
}

static Vec3T FromString( const XString& str )
{
Vec3T v;
v.Parse( str );
return v;
}

#endif

};


template <class vreal> INLINE bool
operator < (const VecBase3T<vreal>& v1, const VecBase3T<vreal>& v2)
{
return v1.x < v2.x && v1.y < v2.y && v1.z < v2.z;
}

template <class vreal> INLINE bool
operator <= (const VecBase3T<vreal>& v1, const VecBase3T<vreal>& v2)
{
return v1.x <= v2.x && v1.y <= v2.y && v1.z <= v2.z;
}


template <class vreal> INLINE bool
operator > (const VecBase3T<vreal>& v1, const VecBase3T<vreal>& v2)
{
return v1.x > v2.x && v1.y > v2.y && v1.z > v2.z;
}

template <class vreal> INLINE bool
operator >= (const VecBase3T<vreal>& v1, const VecBase3T<vreal>& v2)
{
return v1.x >= v2.x && v1.y >= v2.y && v1.z >= v2.z;
}

template<typename vreal> inline Vec3T<vreal> operator*(vreal s, const VecBase3T<vreal> &v)							{ return Vec3T<vreal>(v.x * s, v.y * s, v.z * s); }
template<typename vreal> inline Vec3T<vreal> operator*(const VecBase3T<vreal> &v, vreal s)							{ return Vec3T<vreal>(v.x * s, v.y * s, v.z * s); }
template<typename vreal> inline Vec3T<vreal> operator*(const VecBase3T<vreal> &a, const VecBase3T<vreal> &b)		{ return Vec3T<vreal>(a.x * b.x, a.y * b.y, a.z * b.z); }
template<typename vreal> inline Vec3T<vreal> operator/(const VecBase3T<vreal> &a, const VecBase3T<vreal> &b)		{ return Vec3T<vreal>(a.x / b.x, a.y / b.y, a.z / b.z); }
template<typename vreal> inline Vec3T<vreal> operator/(const VecBase3T<vreal> &a, vreal s)							{ vreal r = (vreal) 1.0 / s; return Vec3T<vreal>(a.x * r, a.y * r, a.z * r); }
template<typename vreal> inline Vec3T<vreal> operator+(const VecBase3T<vreal>& a, const VecBase3T<vreal>& b)		{ return Vec3T<vreal>(a.x + b.x, a.y + b.y, a.z + b.z ); }
template<typename vreal> inline Vec3T<vreal> operator-(const VecBase3T<vreal>& a, const VecBase3T<vreal>& b)		{ return Vec3T<vreal>(a.x - b.x, a.y - b.y, a.z - b.z ); }
template<typename vreal> inline vreal        dot(const VecBase3T<vreal>& a, const VecBase3T<vreal>& b)				{ return a.x * b.x + a.y * b.y + a.z * b.z; }
template<typename vreal> inline vreal        operator&(const VecBase3T<vreal>& a, const VecBase3T<vreal>& b)		{ return dot(a,b); }
template<typename vreal> inline Vec3T<vreal> normalize(const VecBase3T<vreal>& a)									{ Vec3T<vreal> copy = a; copy.normalize(); return copy; }
template<typename vreal> inline vreal        length(const VecBase3T<vreal>& a) 										{ return a.size(); }
template<typename vreal> inline vreal        lengthSQ(const VecBase3T<vreal>& a) 									{ return a.sizeSquared(); }

// cross
template<typename vreal> inline
Vec3T<vreal> Vec3T<vreal>::operator^(const VecBase3T<vreal>& v) const
{
return Vec3T<vreal>::Create( n[1]*v[2] - v[1]*n[2],
-n[0]*v[2] + v[0]*n[2],
n[0]*v[1] - v[0]*n[1] );
}


template <class vreal>
INLINE int Vec3T<vreal>::MakeOrthonormalBasis(VecBase3T<vreal> & base1, VecBase3T<vreal> & base2)
{

if (base1.normalizeCheck())
return -1;

if (base2.normalizeCheck())
return -1;

*this = base1 ^ base2;

// should be already normalized
if (normalizeCheck())
return -1;

base1 = base2 ^ *this;

// this too, should be already normalized
if (base1.normalizeCheck())
return -1;

return 0;
}

typedef Vec3T<double> Vec3d;
typedef Vec3T<float> Vec3f;
typedef Vec3d Vec3;

#ifdef OHASH_DEFINED
namespace ohash
{
template< class vreal >
class ohashfunc_Vec3T
{
public:
static ohash::hashkey_t gethashcode( const VecBase3T<vreal>& elem )
{
vreal sum = elem.x + elem.y + elem.z;
ohash::hashkey_t* hard = (ohash::hashkey_t*) &sum;
return *hard;
}
};

typedef ohashfunc_Vec3T<double> ohashfunc_Vec3;
typedef ohashfunc_Vec3T<double> ohashfunc_Vec3d;
typedef ohashfunc_Vec3T<float> ohashfunc_Vec3f;
}
#endif

inline Vec3		ToVec3( Vec3f v ) { return Vec3( v.x, v.y, v.z ); }
inline Vec3f	ToVec3f( Vec3 v ) { return Vec3f( (float) v.x, (float) v.y, (float) v.z ); }

#endif // DEFINED_Vec3




// See Vec2.h for a readme of what we are doing here
#ifndef DEFINED_Vec4
#define DEFINED_Vec4

template <class vreal>
class Vec4Traits
{
public:
static const TCHAR* StringFormat() { return _T("[ %g %g %g %g ]"); }
static const TCHAR* StringFormatBare() { return _T("%g %g %g %g"); }
static const char* StringAFormatBare() { return "%g %g %g %g"; }
};

template <>
class Vec4Traits<float>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.6g %.6g %.6g %.6g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.6g %.6g %.6g %.6g"); }
static const char* StringAFormatBare() { return "%.6g %.6g %.6g %.6g"; }
};

template <>
class Vec4Traits<double>
{
public:
static const TCHAR* StringFormat() { return _T("[ %.10g %.10g %.10g %.10g ]"); }
static const TCHAR* StringFormatBare() { return _T("%.10g %.10g %.10g %.10g"); }
static const char* StringAFormatBare() { return "%.10g %.10g %.10g %.10g"; }
};

// The "Base" class has no constructor, so that it can be included inside a union
// Inside the base class, we do not expose any functions that leak our type
// For example, we cannot expose component-wise multiply, because that would
// leak VecBase4T to the outside world.
template <class vreal>
class VecBase4T
{
public:
static const int Dimensions = 4;
typedef vreal FT;

union
{
vreal n[4];
struct
{
vreal x,y,z,w;
};
struct
{
VecBase3T<vreal> vec3;
};
struct
{
vreal r,g,b,a;
};
//struct
//{
//	vreal u,v,q,r;
//};
struct
{
VecBase2T<vreal> vec2;
VecBase2T<vreal> vec2_zw;
};
};

void set( vreal _x, vreal _y, vreal _z, vreal _w )
{
x = _x;
y = _y;
z = _z;
w = _w;
}

void scale(vreal _scale)
{
x *= _scale;
y *= _scale;
z *= _scale;
w *= _scale;
}

vreal size() const
{
return sqrt(sizeSquared());
}

vreal sizeSquared() const
{
return x*x + y*y + z*z + w*w;
}

void normalize()
{
double s = 1.0 / sqrt(x*x + y*y + z*z + w*w);
x *= s;
y *= s;
z *= s;
w *= s;
}

bool checkNaN() const
{
if ( vec_IsNaN(x) || vec_IsNaN(y) || vec_IsNaN(z) || vec_IsNaN(w))
return false;
return true;
}

vreal& operator[](int i)			{ return n[i]; };
const vreal& operator[](int i) const	{ return n[i]; }

vreal& operator()(int i)			{ return n[i]; };
const vreal& operator()(int i) const	{ return n[i]; }

const bool operator == ( const VecBase4T& v ) const
{
return x == v.x && y == v.y && z == v.z && w == v.w;
}

const bool operator != ( const VecBase4T &v ) const
{
return x != v.x || y != v.y || z != v.z || w != v.w;
}

};


template <class vreal>
class Vec4T : public VecBase4T<vreal>
{
public:
typedef vreal FT;
using VecBase4T<vreal>::x;
using VecBase4T<vreal>::y;
using VecBase4T<vreal>::z;
using VecBase4T<vreal>::w;
using VecBase4T<vreal>::n;
using VecBase4T<vreal>::vec2;
using VecBase4T<vreal>::vec3;

Vec4T() {}
Vec4T( const VecBase2T<vreal>& _v, vreal _z, vreal _w )		{ x = _v.x; y = _v.y; z = _z; w = _w; }
Vec4T( const VecBase3T<vreal>& _v, vreal _w )				{ x = _v.x; y = _v.y; z = _v.z; w = _w; }
Vec4T( const VecBase4T<vreal>& _v )							{ x = _v.x; y = _v.y; z = _v.z; w = _v.w; }
Vec4T( vreal _x, vreal _y, vreal _z, vreal _w )				{ x = _x; y = _y; z = _z; w = _w; }
explicit Vec4T( vreal uniform )								{ x = y = z = w = uniform; }

static Vec4T Create( vreal x, vreal y, vreal z, vreal w )
{
Vec4T v;
v.x = x;
v.y = y;
v.z = z;
v.w = w;
return v;
}

const Vec2T<vreal>&	AsVec2() const	{ return (const Vec2T<vreal>&) vec2; }
Vec2T<vreal>&	AsVec2()		{ return (Vec2T<vreal>&) vec2; }
const Vec3T<vreal>&	AsVec3() const	{ return (const Vec3T<vreal>&) vec3; }
Vec3T<vreal>&	AsVec3()		{ return (Vec3T<vreal>&) vec3; }
const Vec4T<vreal>&	AsVec4() const	{ return *this; }
Vec4T<vreal>&	AsVec4()		{ return *this; }

// lambda * v1 + (1 - lambda) * v2
static Vec4T Interpolate( const Vec4T &v1, const Vec4T &v2, vreal lambda )
{
return lambda * v1 + (1 - lambda) * v2;
}

// Assignment operators

Vec4T & operator += ( const Vec4T& v );     // incrementation by a Vec4T
Vec4T & operator -= ( const Vec4T& v );     // decrementation by a Vec4T
Vec4T & operator *= ( const vreal d );     // multiplication by a constant
Vec4T & operator /= ( const vreal d );     // division by a constant

// special functions

Vec4T normalized() const
{
Vec4T copy = *this;
copy.normalize();
return copy;
}

void copyTo( vreal *dst ) const
{
dst[0] = x;
dst[1] = y;
dst[2] = z;
dst[3] = w;
}


//    Vec4T& ApplyFunc(ulFuncPtrf fct);  // apply a func. to each component
void Homogenize( void );

Vec4T& operator *= (const Vec4T& v);
Vec4T& operator /= (const Vec4T& v);

// this *= s;
void scale(vreal s);

// this = v * s
void scale(const Vec4T &v, vreal s);
// this += v
void add(const Vec4T & v);
// this = v1 + v2
void add(const Vec4T & v1, const Vec4T & v2);


// min of all components
vreal Min() const;

// min abs of all components
vreal MinAbs() const;
// maximum of all components
vreal Max() const;
// max abs of components
vreal MaxAbs() const;

void Maximize( const Vec4T& rhs )
{
x = ( x > rhs.x ) ? x : rhs.x;
y = ( y > rhs.y ) ? y : rhs.y;
z = ( z > rhs.z ) ? z : rhs.z;
w = ( w > rhs.w ) ? w : rhs.w;
}
void Minimize( const Vec4T& rhs )
{
x = ( x < rhs.x ) ? x : rhs.x;
y = ( y < rhs.y ) ? y : rhs.y;
z = ( z < rhs.z ) ? z : rhs.z;
w = ( w < rhs.w ) ? w : rhs.w;
}
// this = -v
void negate(const Vec4T &v);
// this = -this
void negate();
// this -= v
void sub(const Vec4T &v);

// this = v1 - v2
void sub(const Vec4T &v1, const Vec4T &v2);
// this *= v
void mult(const Vec4T &v);
// this = v1 * v2
void mult(const Vec4T &v1, const Vec4T &v2);
//  this = v1 + lambda * v2;
void displace(const Vec4T &v1, const Vec4T &v2, vreal lambda);

//  this += lambda * v;
void displace(const Vec4T &v, vreal lambda);


vreal distance3d(const Vec4T &b) const		{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z)); }
vreal distance2d(const Vec4T &b) const		{ return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y)); }

vreal distance3dSQ(const Vec4T &b) const	{ return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z); }
vreal distance2dSQ(const Vec4T &b) const	{ return (b.x-x)*(b.x-x) + (b.y-y)*(b.y-y); }

// mag(this - other)
vreal distance(const Vec4T &b) const
{
return sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z) + (w-b.w)*(w-b.w));
}

// mag(this - other) ^2
vreal distanceSQ(const Vec4T &b) const
{
return (x-b.x)*(x-b.x) + (y-b.y)*(y-b.y) + (z-b.z)*(z-b.z) + (w-b.w)*(w-b.w);
}

/// Clamps values individually
void clamp( vreal vmin, vreal vmax );

/// Only valid for Vec4T<double>. Checks whether we won't overflow if converted to float.
bool checkFloatOverflow() const
{
if (	x > FLT_MAX || x < -FLT_MAX ||
y > FLT_MAX || y < -FLT_MAX ||
z > FLT_MAX || z < -FLT_MAX ||
w > FLT_MAX || w < -FLT_MAX ) return false;
return true;
}

int ToStringABare( char* buff, size_t buffChars ) const
{
return sprintf_s( buff, buffChars, Vec4Traits<vreal>::StringAFormatBare(), x, y, z, w );
}

#ifdef XSTRING_DEFINED
/// Writes "[ %g %g %g %g ]"
XString ToString() const
{
XString s;
s.Format( Vec4Traits<vreal>::StringFormat(), x, y, z, w );
return s;
}

/// Writes "%g %g %g %g"
XString ToStringBare() const
{
XString s;
s.Format( Vec4Traits<vreal>::StringFormatBare(), x, y, z, w );
return s;
}

XString ToString( int significant_digits, bool bare = false ) const
{
XString f, s;
if ( bare ) f.Format( _T("%%.%dg %%.%dg %%.%dg %%.%dg"), significant_digits, significant_digits, significant_digits, significant_digits );
else		f.Format( _T("[ %%.%dg %%.%dg %%.%dg %%.%dg ]"), significant_digits, significant_digits, significant_digits, significant_digits );
s.Format( f, x, y, z, w );
return s;
}

/// Parses "[ x y z w ]", "z y z w", "x,y,z,w"
bool Parse( const XString& str )
{
double a, b, c, d;
#ifdef LM_VS2005_SECURE
if ( _stscanf_s( str, _T("[ %lf %lf %lf %lf ]"), &a, &b, &c, &d ) != 4 )
{
if ( _stscanf_s( str, _T("%lf %lf %lf %lf"), &a, &b, &c, &d ) != 4 )
{
if ( _stscanf_s( str, _T("%lf, %lf, %lf, %lf"), &a, &b, &c, &d ) != 4 )
{
return false;
}
}
}
#else
if ( _stscanf( str, "[ %lf %lf %lf %lf ]", &a, &b, &c, &d ) != 4 )
{
if ( _stscanf( str, "%lf %lf %lf %lf", &a, &b, &c, &d ) != 4 )
{
if ( _stscanf( str, "%lf, %lf, %lf, %lf", &a, &b, &c, &d ) != 4 )
{
return false;
}
}
}
#endif

x = (vreal) a;
y = (vreal) b;
z = (vreal) c;
w = (vreal) d;

return true;
}

static Vec4T FromString( const XString& str )
{
Vec4T v;
v.Parse( str );
return v;
}

#endif

};


template <class vreal> INLINE
void Vec4T<vreal>::clamp( vreal vmin, vreal vmax )
{
x = CLAMP(x, vmin, vmax);
y = CLAMP(y, vmin, vmax);
z = CLAMP(z, vmin, vmax);
w = CLAMP(w, vmin, vmax);
}


template <class vreal> INLINE void Vec4T<vreal>::Homogenize( void )
{
double u = 1.0 / w;
x = (vreal)(x*u);
y = (vreal)(y*u);
z = (vreal)(z*u);
}


// =====================================
// Assignment operators
// =====================================

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator += (const Vec4T<vreal>& v)
{
x += v.x;
y += v.y;
z += v.z;
w += v.w;
return *this;
}

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator -= (const Vec4T<vreal>& v)
{
x -= v.x;
y -= v.y;
z -= v.z;
w -= v.w;
return *this;
}

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator *= (const Vec4T<vreal>& v)
{
x *= v.x;
y *= v.y;
z *= v.z;
w *= v.w;
return *this;
}

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator /= (const Vec4T<vreal>& v)
{
x /= v.x;
y /= v.y;
z /= v.z;
w /= v.w;
return *this;
}

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator *= (vreal s)
{
x *= s;
y *= s;
z *= s;
w *= s;
return *this;
}

template <class vreal> INLINE Vec4T<vreal>&
Vec4T<vreal>::operator /= (vreal d)
{
double u = 1.0 / d;
x = (vreal)(x*u);
y = (vreal)(y*u);
z = (vreal)(z*u);
w = (vreal)(w*u);
return *this;
}

template <class vreal> INLINE Vec4T<vreal>
operator + (const Vec4T<vreal>& v)
{
return v;
}

template <class vreal> INLINE Vec4T<vreal>
operator - (const Vec4T<vreal>& v)
{
return Vec4T<vreal>::Create(-v.x, -v.y, -v.z, -v.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator + (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return Vec4T<vreal>::Create(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z, v1.w+v2.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator - (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return Vec4T<vreal>::Create(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z, v1.w-v2.w);
}

template <class vreal> INLINE vreal
operator & (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + v1.w*v2.w;
}

template <class vreal> INLINE Vec4T<vreal>
operator * (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return Vec4T<vreal>::Create(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z, v1.w*v2.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator / (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return Vec4T<vreal>(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z, v1.w/v2.w);
}

template <class vreal> INLINE int
operator < (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return v1.x < v2.x && v1.y < v2.y && v1.z < v2.z && v1.w < v2.w;
}

template <class vreal> INLINE int
operator <= (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return v1.x <= v2.x && v1.y <= v2.y && v1.z <= v2.z && v1.w <= v2.w;
}

// Hardcode mixing of floats/doubles
// double *
template <class vreal> INLINE Vec4T<vreal>
operator * (const Vec4T<vreal>& v, double s)
{
return Vec4T<vreal>::Create(s*v.x, s*v.y, s*v.z, s * v.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator * (double s, const Vec4T<vreal>& v)
{
return Vec4T<vreal>::Create(s*v.x, s*v.y, s*v.z, s*v.w);
}

// float *
template <class vreal> INLINE Vec4T<vreal>
operator * (const Vec4T<vreal>& v, float s)
{
return Vec4T<vreal>::Create(s*v.x, s*v.y, s*v.z, s * v.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator * (float s, const Vec4T<vreal>& v)
{
return Vec4T<vreal>::Create(s*v.x, s*v.y, s*v.z, s*v.w);
}

template <class vreal> INLINE Vec4T<vreal>
operator / (const Vec4T<vreal>& v, vreal s)
{
return Vec4T<vreal>::Create(v.x/s, v.y/s, v.z/s, v.w/s);
}

template <class vreal> INLINE bool
operator == (const Vec4T<vreal>& v1, const Vec4T<vreal>& v2)
{
return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z && v1.w == v2.w;
}

template <class vreal> INLINE vreal
dot (const VecBase4T<vreal>& v1, const VecBase4T<vreal>& v2)
{
return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + v1.w*v2.w;
}

template <class vreal> INLINE Vec4T<vreal>
normalize( const Vec4T<vreal>& a )
{
return a.normalized();
}

template <class vreal> INLINE vreal
length( const VecBase4T<vreal>& a )
{
return a.size();
}

template <class vreal> INLINE vreal
lengthSQ( const VecBase4T<vreal>& a )
{
return a.sizeSquared();
}

typedef Vec4T<double> Vec4d;
typedef Vec4T<float> Vec4f;
typedef Vec4d Vec4;

inline Vec4		ToVec4( Vec4f v ) { return Vec4::Create( v.x, v.y, v.z, v.w ); }
inline Vec4f	ToVec4f( Vec4 v ) { return Vec4f::Create( (float) v.x, (float) v.y, (float) v.z, (float) v.w ); }

#endif // DEFINED_Vec4



#ifndef DEFINED_Mat4
#define DEFINED_Mat4

template <class FT>
class Mat4T
{
public:
VecBase4T<FT> row[4];

Mat4T(void)
{
Identity();
}

// Don't initialize to identity
Mat4T( int uninit )
{
}

Mat4T(	FT a0, FT b0, FT c0, FT d0,
FT a1, FT b1, FT c1, FT d1,
FT a2, FT b2, FT c2, FT d2,
FT a3, FT b3, FT c3, FT d3)
{
XX = a0;
XY = b0;
XZ = c0;
XW = d0;

YX = a1;
YY = b1;
YZ = c1;
YW = d1;

ZX = a2;
ZY = b2;
ZZ = c2;
ZW = d2;

WX = a3;
WY = b3;
WZ = c3;
WW = d3;
}


FT&	m(int i, int j)			{ return row[i][j]; }
FT	m(int i, int j) const	{ return row[i][j]; }

FT Determinant() const;

/// Returns the diagonal
Vec4T<FT> Diagonal() const { return Vec4T<FT>( row[0].x, row[1].y, row[2].z, row[3].w ); }

Mat4T Transposed(void) const {
Mat4T t;
t.XX = XX;
t.YX = XY;
t.ZX = XZ;
t.WX = XW;

t.XY = YX;
t.YY = YY;
t.ZY = YZ;
t.WY = YW;

t.XZ = ZX;
t.YZ = ZY;
t.ZZ = ZZ;
t.WZ = ZW;

t.XW = WX;
t.YW = WY;
t.ZW = WZ;
t.WW = WW;
return t;
}

Mat4T Inverted() const {
Mat4T mr;
mr = *this;
mr.Invert();
return mr;
}

void Zero()
{
XX = 0;
XY = 0;
XZ = 0;
XW = 0;

YX = 0;
YY = 0;
YZ = 0;
YW = 0;

ZX = 0;
ZY = 0;
ZZ = 0;
ZW = 0;

WX = 0;
WY = 0;
WZ = 0;
WW = 0;
}

void Identity()
{
XX = 1;
XY = 0;
XZ = 0;
XW = 0;

YX = 0;
YY = 1;
YZ = 0;
YW = 0;

ZX = 0;
ZY = 0;
ZZ = 1;
ZW = 0;

WX = 0;
WY = 0;
WZ = 0;
WW = 1;
}


Mat4T operator*(const FT d) const
{
Mat4T b;
b.XX = XX * d;
b.XY = XY * d;
b.XZ = XZ * d;
b.XW = XW * d;

b.YX = YX * d;
b.YY = YY * d;
b.YZ = YZ * d;
b.YW = YW * d;

b.ZX = ZX * d;
b.ZY = ZY * d;
b.ZZ = ZZ * d;
b.ZW = ZW * d;

b.WX = WX * d;
b.WY = WY * d;
b.WZ = WZ * d;
b.WW = WW * d;

return b;
}

void Translate( const Vec3T<FT>& vec, bool post = true )
{
Translate(vec.x, vec.y, vec.z, post);
}

void Translate( double x, double y, double z, bool post = true )
{
Mat4T tm;
tm.XW = x;
tm.YW = y;
tm.ZW = z;
if (post)
*this = (*this) * tm;
else
*this = tm * (*this);
}

void Scale( const Vec3T<FT>& vec, bool post = true )
{
Scale(vec.x, vec.y, vec.z, post);
}

// equivalent to a glScale3d
void Scale( FT x, FT y, FT z, bool post = true )
{
Mat4T m;
m.XX = x;
m.YY = y;
m.ZZ = z;
if (post)
*this = (*this) * m;
else
*this = m * (*this);
}

// equivalent to glRotated(), except RADIANS
void Rotate( FT angle, FT x, FT y, FT z, bool post = true )
{
Vec3 v(x,y,z);
v.normalize();
x = v.x;
y = v.y;
z = v.z;
Mat4T r;
FT c = cos(angle);
FT s = sin(angle);
FT cm1 = 1 - c;
// row 0
r.XX = x*x*cm1 + c;
r.XY = x*y*cm1 - z*s;
r.XZ = x*z*cm1 + y*s;
r.XW = 0;
// row 1
r.YX = y*x*cm1 + z*s;
r.YY = y*y*cm1 + c;
r.YZ = y*z*cm1 - x*s;
r.YW = 0;
// row 2
r.ZX = z*x*cm1 - y*s;
r.ZY = z*y*cm1 + x*s;
r.ZZ = z*z*cm1 + c;
r.ZW = 0;
// row 3
r.WX = 0;
r.WY = 0;
r.WZ = 0;
r.WW = 1;
if (post)
*this = (*this) * r;
else
*this = r * (*this);
}



void Invert()
{
/************************************************************
*
* input:
* mat - pointer to array of 16 floats (source matrix)
* output:
* dst - pointer to array of 16 floats (invert matrix)
*
*************************************************************/
//void Invert2( float *mat, float *dst)
//Streaming SIMD Extensions - Inverse of 4x4 Matrix
//7
//{
FT dst[16];
FT tmp[12]; /* temp array for pairs */
FT src[16]; /* array of transpose source matrix */
FT det; /* determinant */
/* transpose matrix */
/*for ( int i = 0; i < 4; i++) {
src[i] = row[i].x;
src[i + 4] = row[i].y;
src[i + 8] = row[i].z;
src[i + 12] = row[i].w;
}*/
// transpose
src[0] = XX;
src[1] = YX;
src[2] = ZX;
src[3] = WX;

src[4] = XY;
src[5] = YY;
src[6] = ZY;
src[7] = WY;

src[8] = XZ;
src[9] = YZ;
src[10] = ZZ;
src[11] = WZ;

src[12] = XW;
src[13] = YW;
src[14] = ZW;
src[15] = WW;

/* calculate pairs for first 8 elements (cofactors) */
tmp[0] = src[10] * src[15];
tmp[1] = src[11] * src[14];
tmp[2] = src[9] * src[15];
tmp[3] = src[11] * src[13];
tmp[4] = src[9] * src[14];
tmp[5] = src[10] * src[13];
tmp[6] = src[8] * src[15];
tmp[7] = src[11] * src[12];
tmp[8] = src[8] * src[14];
tmp[9] = src[10] * src[12];
tmp[10] = src[8] * src[13];
tmp[11] = src[9] * src[12];
/* calculate first 8 elements (cofactors) */
dst[0] = tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
dst[0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
dst[1] = tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
dst[1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
dst[2] = tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
dst[2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
dst[3] = tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
dst[3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
dst[4] = tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
dst[4] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
dst[5] = tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
dst[5] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
dst[6] = tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
dst[6] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
dst[7] = tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
dst[7] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];
/* calculate pairs for second 8 elements (cofactors) */
tmp[0] = src[2]*src[7];
tmp[1] = src[3]*src[6];
tmp[2] = src[1]*src[7];
tmp[3] = src[3]*src[5];
tmp[4] = src[1]*src[6];
tmp[5] = src[2]*src[5];
tmp[6] = src[0]*src[7];
tmp[7] = src[3]*src[4];
tmp[8] = src[0]*src[6];
tmp[9] = src[2]*src[4];
tmp[10] = src[0]*src[5];
tmp[11] = src[1]*src[4];
/* calculate second 8 elements (cofactors) */
dst[8] = tmp[0]*src[13] + tmp[3]*src[14] + tmp[4]*src[15];
dst[8] -= tmp[1]*src[13] + tmp[2]*src[14] + tmp[5]*src[15];
dst[9] = tmp[1]*src[12] + tmp[6]*src[14] + tmp[9]*src[15];
dst[9] -= tmp[0]*src[12] + tmp[7]*src[14] + tmp[8]*src[15];
dst[10] = tmp[2]*src[12] + tmp[7]*src[13] + tmp[10]*src[15];
dst[10]-= tmp[3]*src[12] + tmp[6]*src[13] + tmp[11]*src[15];
dst[11] = tmp[5]*src[12] + tmp[8]*src[13] + tmp[11]*src[14];
dst[11]-= tmp[4]*src[12] + tmp[9]*src[13] + tmp[10]*src[14];
dst[12] = tmp[2]*src[10] + tmp[5]*src[11] + tmp[1]*src[9];
dst[12]-= tmp[4]*src[11] + tmp[0]*src[9] + tmp[3]*src[10];
dst[13] = tmp[8]*src[11] + tmp[0]*src[8] + tmp[7]*src[10];
dst[13]-= tmp[6]*src[10] + tmp[9]*src[11] + tmp[1]*src[8];
dst[14] = tmp[6]*src[9] + tmp[11]*src[11] + tmp[3]*src[8];
dst[14]-= tmp[10]*src[11] + tmp[2]*src[8] + tmp[7]*src[9];
dst[15] = tmp[10]*src[10] + tmp[4]*src[8] + tmp[9]*src[9];
dst[15]-= tmp[8]*src[9] + tmp[11]*src[10] + tmp[5]*src[8];
/* calculate determinant */
det=src[0]*dst[0]+src[1]*dst[1]+src[2]*dst[2]+src[3]*dst[3];
/* calculate matrix inverse */
det = 1/det;
for ( int j = 0; j < 16; j++) {
dst[j] *= det;
}
memcpy((void*) this, dst, 16*sizeof(FT));
}

#ifndef NO_XSTRING
XString ToString() const
{
XString s;
s.Format(_T("[ %f %f %f %f;\n  %f %f %f %f;\n  %f %f %f %f;\n  %f %f %f %f ]"),
XX, XY, XZ, XW,
YX, YY, YZ, YW,
ZX, ZY, ZZ, ZW,
WX, WY, WZ, WW );
return s;
}
#endif

/*friend double Difference( const Mat4T<FT>& a, const Mat4T<FT>& b );

friend Mat4T operator - (const Mat4T& a);         // -m1
friend Mat4T operator + (const Mat4T& a, const Mat4T& b);		// m1 + m2
friend Mat4T operator - (const Mat4T& a, const Mat4T& b);		// m1 - m2
friend Mat4T operator * (const Mat4T& b, const Mat4T& a);		// m1 * m2
friend Mat4T operator * (const Mat4T& a, const FT d);			// m1 * d
friend Mat4T operator * (const FT d, const Mat4T& a);			// d * m1
friend Mat4T operator / (const Mat4T& a, const FT d);			// m1 / d
friend int operator == (const Mat4T& a, const Mat4T& b);		// m1 == m2 ?
friend int operator != (const Mat4T& a, const Mat4T& b);		// m1 != m2 ?
//friend Vec4T<FT> operator * ( const Vec4T<FT>& v, const Mat4T& a );    // v * m1
//friend Vec4T<FT> operator * ( const Mat4T& a, const Vec4T<FT>& v );    // m1 * v */

};

template <class FT>
INLINE FT Mat4T<FT>::Determinant() const
{
FT sub1 = YY * (ZZ * WW - ZW * WZ) -
YZ * (ZY * WW - ZW * WY) +
YW * (ZY * WZ - ZZ * WY);

FT sub2 = YX * (ZZ * WW - ZW * WZ) -
YZ * (ZX * WW - ZW * WX) +
YW * (ZX * WZ - ZZ * WX);

FT sub3 = YX * (ZY * WW - ZW * WY) -
YY * (ZX * WW - ZW * WX) +
YW * (ZX * WY - ZY * WX);

FT sub4 = YX * (ZY * WZ - ZZ * WY) -
YY * (ZX * WZ - ZZ * WX) +
YZ * (ZX * WY - ZY * WX);
FT det = XX * sub1 - XY * sub2 + XZ * sub3 - XW * sub4;
return det;
}

template <class FT>
INLINE Mat4T<FT> operator + (const Mat4T<FT>& a, const Mat4T<FT>& b)
{
Mat4T<FT> c;

c.XX = a.XX + b.XX;
c.XY = a.XY + b.XY;
c.XZ = a.XZ + b.XZ;
c.XW = a.XW + b.XW;

c.YX = a.YX + b.YX;
c.YY = a.YY + b.YY;
c.YZ = a.YZ + b.YZ;
c.YW = a.YW + b.YW;

c.ZX = a.ZX + b.ZX;
c.ZY = a.ZY + b.ZY;
c.ZZ = a.ZZ + b.ZZ;
c.ZW = a.ZW + b.ZW;

c.WX = a.WX + b.WX;
c.WY = a.WY + b.WY;
c.WZ = a.WZ + b.WZ;
c.WW = a.WW + b.WW;

return c;
}


template <class FT>
INLINE Mat4T<FT> operator - (const Mat4T<FT>& a, const Mat4T<FT>& b)
{
Mat4T<FT> c;

c.XX = a.XX - b.XX;
c.XY = a.XY - b.XY;
c.XZ = a.XZ - b.XZ;
c.XW = a.XW - b.XW;

c.YX = a.YX - b.YX;
c.YY = a.YY - b.YY;
c.YZ = a.YZ - b.YZ;
c.YW = a.YW - b.YW;

c.ZX = a.ZX - b.ZX;
c.ZY = a.ZY - b.ZY;
c.ZZ = a.ZZ - b.ZZ;
c.ZW = a.ZW - b.ZW;

c.WX = a.WX - b.WX;
c.WY = a.WY - b.WY;
c.WZ = a.WZ - b.WZ;
c.WW = a.WW - b.WW;

return c;
}


template <class FT>
INLINE Mat4T<FT> operator * (const Mat4T<FT>& b, const Mat4T<FT>& a)
{
Mat4T<FT> c;

c.XX = a.XX * b.XX + a.YX * b.XY + a.ZX * b.XZ + a.WX * b.XW;
c.XY = a.XY * b.XX + a.YY * b.XY + a.ZY * b.XZ + a.WY * b.XW;
c.XZ = a.XZ * b.XX + a.YZ * b.XY + a.ZZ * b.XZ + a.WZ * b.XW;
c.XW = a.XW * b.XX + a.YW * b.XY + a.ZW * b.XZ + a.WW * b.XW;

c.YX = a.XX * b.YX + a.YX * b.YY + a.ZX * b.YZ + a.WX * b.YW;
c.YY = a.XY * b.YX + a.YY * b.YY + a.ZY * b.YZ + a.WY * b.YW;
c.YZ = a.XZ * b.YX + a.YZ * b.YY + a.ZZ * b.YZ + a.WZ * b.YW;
c.YW = a.XW * b.YX + a.YW * b.YY + a.ZW * b.YZ + a.WW * b.YW;

c.ZX = a.XX * b.ZX + a.YX * b.ZY + a.ZX * b.ZZ + a.WX * b.ZW;
c.ZY = a.XY * b.ZX + a.YY * b.ZY + a.ZY * b.ZZ + a.WY * b.ZW;
c.ZZ = a.XZ * b.ZX + a.YZ * b.ZY + a.ZZ * b.ZZ + a.WZ * b.ZW;
c.ZW = a.XW * b.ZX + a.YW * b.ZY + a.ZW * b.ZZ + a.WW * b.ZW;

c.WX = a.XX * b.WX + a.YX * b.WY + a.ZX * b.WZ + a.WX * b.WW;
c.WY = a.XY * b.WX + a.YY * b.WY + a.ZY * b.WZ + a.WY * b.WW;
c.WZ = a.XZ * b.WX + a.YZ * b.WY + a.ZZ * b.WZ + a.WZ * b.WW;
c.WW = a.XW * b.WX + a.YW * b.WY + a.ZW * b.WZ + a.WW * b.WW;

return c;
}



template <class FT>
INLINE Mat4T<FT> operator * (const Mat4T<FT>& a, const FT d)
{
Mat4T<FT> b;
b.XX = a.XX * d;
b.XY = a.XY * d;
b.XZ = a.XZ * d;
b.XW = a.XW * d;

b.YX = a.YX * d;
b.YY = a.YY * d;
b.YZ = a.YZ * d;
b.YW = a.YW * d;

b.ZX = a.ZX * d;
b.ZY = a.ZY * d;
b.ZZ = a.ZZ * d;
b.ZW = a.ZW * d;

b.WX = a.WX * d;
b.WY = a.WY * d;
b.WZ = a.WZ * d;
b.WW = a.WW * d;

return b;
}

template <class FT>
INLINE Mat4T<FT> operator * (const FT d, const Mat4T<FT>& a)
{ return a*d; }


template <class FT>
INLINE Vec3T<FT> operator * (const Vec3T<FT>& v3, const Mat4T<FT>& m4)
{
// multiply v3 as though it were v4 with w = 1
Vec4T<FT> v4;
Vec3T<FT> ret;
v4.x = v3.x;
v4.y = v3.y;
v4.z = v3.z;
v4.w = 1.0f;
v4 = v4 * m4;
v4.Homogenize();

ret.x = v4.x;
ret.y = v4.y;
ret.z = v4.z;
return( ret );
}

template <class FT>
INLINE Vec3T<FT> operator * (const Mat4T<FT>& m4, const Vec3T<FT>& v3)
{
// multiply v3 as though it were v4 with w = 1
Vec4T<FT> v4;
Vec3T<FT> ret;
v4.x = v3.x;
v4.y = v3.y;
v4.z = v3.z;
v4.w = 1.0f;
v4 = m4 * v4;
v4.Homogenize();

ret.x = v4.x;
ret.y = v4.y;
ret.z = v4.z;
return( ret );
}

template <class FT>
INLINE Vec4T<FT> operator * ( const Vec4T<FT>& v, const Mat4T<FT>& a )
{
return Vec4T<FT> (
v.x * a.XX + v.y * a.YX + v.z * a.ZX + v.w * a.WX,
v.x * a.XY + v.y * a.YY + v.z * a.ZY + v.w * a.WY,
v.x * a.XZ + v.y * a.YZ + v.z * a.ZZ + v.w * a.WZ,
v.x * a.XW + v.y * a.YW + v.z * a.ZW + v.w * a.WW );
}

template <class FT>
INLINE Vec4T<FT> operator * ( const Mat4T<FT>& a, const Vec4T<FT>& v )
{
return Vec4T<FT> (
v.x * a.XX + v.y * a.XY + v.z * a.XZ + v.w * a.XW,
v.x * a.YX + v.y * a.YY + v.z * a.YZ + v.w * a.YW,
v.x * a.ZX + v.y * a.ZY + v.z * a.ZZ + v.w * a.ZW,
v.x * a.WX + v.y * a.WY + v.z * a.WZ + v.w * a.WW );
}



template <class FT>
INLINE Mat4T<FT> operator / (const Mat4T<FT>& a, const FT d)
{
Mat4T<FT> b;
FT u = 1 / d;
b.XX = a.XX * u;
b.XY = a.XY * u;
b.XZ = a.XZ * u;
b.XW = a.XW * u;

b.YX = a.YX * u;
b.YY = a.YY * u;
b.YZ = a.YZ * u;
b.YW = a.YW * u;

b.ZX = a.ZX * u;
b.ZY = a.ZY * u;
b.ZZ = a.ZZ * u;
b.ZW = a.ZW * u;

b.WX = a.WX * u;
b.WY = a.WY * u;
b.WZ = a.WZ * u;
b.WW = a.WW * u;

return b;
}

template <class FT>
INLINE bool operator == (const Mat4T<FT>& a, const Mat4T<FT>& b)
{
// I don't care about the IEEE == semantics
return memcmp( &a, &b, sizeof(a) ) == 0;
/*
return (
(b.XX == a.XX) &&
(b.XY == a.XY) &&
(b.XZ == a.XZ) &&
(b.XW == a.XW) &&

(b.YX == a.YX) &&
(b.YY == a.YY) &&
(b.YZ == a.YZ) &&
(b.YW == a.YW) &&

(b.ZX == a.ZX) &&
(b.ZY == a.ZY) &&
(b.ZZ == a.ZZ) &&
(b.ZW == a.ZW) &&

(b.WX == a.WX) &&
(b.WY == a.WY) &&
(b.WZ == a.WZ) &&
(b.WW == a.WW));
*/
}

template <class FT>
INLINE bool operator != (const Mat4T<FT>& a, const Mat4T<FT>& b)
{ return !(a == b); }

// sum of component absolute differences
template <class FT>
double Difference( const Mat4T<FT>& a, const Mat4T<FT>& b )
{
double d = 0;
FT *ap = (FT*) &a;
FT *bp = (FT*) &b;
for (int i = 0; i < 16; i++)
d += fabs(ap[i] - bp[i]);
return d;
}


typedef Mat4T<float> Mat4f;
typedef Mat4T<double> Mat4d;
typedef Mat4T<double> Mat4;

#endif // DEFINED_Mat4

#undef XX
#undef XY
#undef XZ
#undef XW

#undef YX
#undef YY
#undef YZ
#undef YW

#undef ZX
#undef ZY
#undef ZZ
#undef ZW

#undef WX
#undef WY
#undef WZ
#undef WW

#undef UL_R
#undef UL_U
#undef UL_N

#undef X
#undef Y
#undef Z
#undef W

/*
xxHash - Extremely Fast Hash algorithm
Header File
Copyright (C) 2012-2014, Yann Collet.
BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You can contact the author at :
- xxHash source repository : http://code.google.com/p/xxhash/
*/

/* Notice extracted from xxHash homepage :

xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
It also successfully passes all tests from the SMHasher suite.

Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)

Name            Speed       Q.Score   Author
xxHash          5.4 GB/s     10
CrapWow         3.2 GB/s      2       Andrew
MumurHash 3a    2.7 GB/s     10       Austin Appleby
SpookyHash      2.0 GB/s     10       Bob Jenkins
SBox            1.4 GB/s      9       Bret Mulvey
Lookup3         1.2 GB/s      9       Bob Jenkins
SuperFastHash   1.2 GB/s      1       Paul Hsieh
CityHash64      1.05 GB/s    10       Pike & Alakuijala
FNV             0.55 GB/s     5       Fowler, Noll, Vo
CRC32           0.43 GB/s     9
MD5-32          0.33 GB/s    10       Ronald L. Rivest
SHA1-32         0.28 GB/s    10

Q.Score is a measure of quality of the hash function.
It depends on successfully passing SMHasher test set.
10 is a perfect score.
*/


#if defined (__cplusplus)
extern "C" {
#endif


/*****************************
Type
*****************************/
typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;



/*****************************
Simple Hash Functions
*****************************/

unsigned int       XXH32 (const void* input, unsigned int len, unsigned int seed);
unsigned long long XXH64 (const void* input, unsigned int len, unsigned long long seed);

/*
XXH32() :
Calculate the 32-bits hash of sequence of length "len" stored at memory address "input".
The memory between input & input+len must be valid (allocated and read-accessible).
"seed" can be used to alter the result predictably.
This function successfully passes all SMHasher tests.
Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s
Note that "len" is type "int", which means it is limited to 2^31-1.
If your data is larger, use the advanced functions below.
XXH64() :
Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".
*/



/*****************************
Advanced Hash Functions
*****************************/

void*         XXH32_init   (unsigned int seed);
XXH_errorcode XXH32_update (void* state, const void* input, unsigned int len);
unsigned int  XXH32_digest (void* state);

void*         		XXH64_init   (unsigned long long seed);
XXH_errorcode 		XXH64_update (void* state, const void* input, unsigned int len);
unsigned long long  XXH64_digest (void* state);

/*
These functions calculate the xxhash of an input provided in several small packets,
as opposed to an input provided as a single block.

It must be started with :
void* XXHnn_init()
The function returns a pointer which holds the state of calculation.

This pointer must be provided as "void* state" parameter for XXHnn_update().
XXHnn_update() can be called as many times as necessary.
The user must provide a valid (allocated) input.
The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.
Note that "len" is type "int", which means it is limited to 2^31-1.
If your data is larger, it is recommended to chunk your data into blocks
of size for example 2^30 (1GB) to avoid any "int" overflow issue.

Finally, you can end the calculation anytime, by using XXHnn_digest().
This function returns the final nn-bits hash.
You must provide the same "void* state" parameter created by XXHnn_init().
Memory will be freed by XXHnn_digest().
*/


int           XXH32_sizeofState(void);
XXH_errorcode XXH32_resetState(void* state, unsigned int seed);

#define       XXH32_SIZEOFSTATE 48
typedef struct { long long ll[(XXH32_SIZEOFSTATE+(sizeof(long long)-1))/sizeof(long long)]; } XXH32_stateSpace_t;

int           XXH64_sizeofState(void);
XXH_errorcode XXH64_resetState(void* state, unsigned long long seed);

#define       XXH64_SIZEOFSTATE 88
typedef struct { long long ll[(XXH64_SIZEOFSTATE+(sizeof(long long)-1))/sizeof(long long)]; } XXH64_stateSpace_t;

/*
These functions allow user application to make its own allocation for state.

XXHnn_sizeofState() is used to know how much space must be allocated for the xxHash nn-bits state.
Note that the state must be aligned to access 'long long' fields. Memory must be allocated and referenced by a pointer.
This pointer must then be provided as 'state' into XXHnn_resetState(), which initializes the state.

For static allocation purposes (such as allocation on stack, or freestanding systems without malloc()),
use the structure XXHnn_stateSpace_t, which will ensure that memory space is large enough and correctly aligned to access 'long long' fields.
*/


unsigned int       XXH32_intermediateDigest (void* state);
unsigned long long XXH64_intermediateDigest (void* state);
/*
This function does the same as XXHnn_digest(), generating a nn-bit hash,
but preserve memory context.
This way, it becomes possible to generate intermediate hashes, and then continue feeding data with XXHnn_update().
To free memory context, use XXHnn_digest(), or free().
*/


#if defined (__cplusplus)
}
#endif


typedef VecBase2T<float> xoVecBase2f;
typedef VecBase3T<float> xoVecBase3f;
typedef VecBase4T<float> xoVecBase4f;

typedef Vec2T<float> xoVec2f;
typedef Vec3T<float> xoVec3f;
typedef Vec4T<float> xoVec4f;

#define XO_MAT4F_DEFINED
typedef Mat4T<float> xoMat4f;


#define FMT_STRING xoString
#define FMT_STRING_BUF(s)	(s.Z)
#define FMT_STRING_LEN(s)	(s.Length())


#ifdef _WIN32
#pragma warning( push )
#pragma warning( disable: 4345 )	// POD constructed with () is default-initialized
#endif

class xoPool;

// This has no constructors or destructors so that we can put it in unions, etc. We know that there is no implicit
// memory management going on here.
class XOAPI xoStringRaw
{
public:
char*	Z;

intp	Length() const;
void	CloneFastInto( xoStringRaw& b, xoPool* pool ) const;
void	Discard();
u32		GetHashCode() const;
intp	Index( const char* find ) const;
intp	RIndex( const char* find ) const;

bool	operator==( const char* b ) const;
bool	operator!=( const char* b ) const			{ return !(*this == b); }
bool	operator==( const xoStringRaw& b ) const;
bool	operator!=( const xoStringRaw& b ) const	{ return !(*this == b); }

bool	operator<( const xoStringRaw& b ) const;

protected:
static xoStringRaw Temp( char* b );

void	Alloc( uintp chars );
void	Free();
};

// This is the classic thing you'd expect from a string. The destructor will free the memory.
class XOAPI xoString : public xoStringRaw
{
public:
xoString();
xoString( const xoString& b );
xoString( const xoStringRaw& b );
xoString( const char* z, intp maxLength = -1 );	// Calls Set()
~xoString();

void				Set( const char* z, intp maxLength = -1 );	// checks maxLength against strlen(z) and clamps automatically
void				ReplaceAll( const char* find, const char* replace );
podvec<xoString>	Split( const char* splitter ) const;
xoString			SubStr( intp start, intp end ) const;	// Returns [start .. end - 1]

xoString&	operator=( const xoString& b );
xoString&	operator=( const xoStringRaw& b );
xoString&	operator=( const char* b );
xoString&	operator+=( const xoStringRaw& b );
xoString&	operator+=( const char* b );

static xoString		Join( const podvec<xoString>& parts, const char* joiner );

};

FHASH_SETUP_CLASS_GETHASHCODE( xoString, xoString );

XOAPI xoString operator+( const char* a, const xoStringRaw& b );
XOAPI xoString operator+( const xoStringRaw& a, const char* b );
XOAPI xoString operator+( const xoStringRaw& a, const xoStringRaw& b );

// Use this when you need a temporary 'xoString' object, but you don't need any heap allocs or frees
class XOAPI xoTempString : public xoString
{
public:
xoTempString( const char* z );
~xoTempString();
};

#ifdef _WIN32
#pragma warning( pop )
#endif


// If you don't want to use XStringA, then you must define FMT_STRING to be some kind of string class
// that can construct itself from const char*.

// To use std::string, do the following before including fmt.h:
// #define FMT_STRING          std::string
// #define FMT_STRING_BUF(s)   (s).c_str()
// #define FMT_STRING_LEN(s)   (s).Length()

#ifndef FMT_STRING
#define FMT_STRING			XStringA
#define FMT_STRING_BUF(s)	static_cast<const char*>(s)
#define FMT_STRING_LEN(s)	(s).Length()
#endif

/*

fmt: (Yet another) typesafe, cross-platform (Windows,linux) printf replacement.

This thing uses snprintf as a backend, so all of the regular formatting commands
that you expect from the printf family of functions works.

Usage:
fmt( "%v %v", "abc", 123 ) --> "abc 123"				<== Use %v as a generic value type
fmt( "%s %d", "abc", 123 ) --> "abc 123"				<== Specific value types are fine too, unless they conflict with the provided type, in which case they are overridden
fmt( "%v", std::string("abc") ) --> "abc"				<== std::string
fmt( "%v", std::wstring("abc") ) --> "abc"				<== std::wstring
fmt( "%v", XStringA("abc") ) --> "abc"					<== XStringA
fmt( "%v", XStringW("abc") ) --> "abc"					<== XStringW
fmt( "%.3f", 25.5 ) --> "25.500"						<== Use format strings as usual

Known unsupported features:
* Positional arguments
* %*s (integer width parameter)	-- wouldn't be hard to add. Presently ignored.

Exclusively returns FMT_STRING.

By providing a cast operator to fmtarg, you can get an arbitrary type supported as an argument (provided it fits into one of the moulds of the printf family of arguments).

*/

class PAPI fmtarg
{
public:
enum Types
{
TNull,	// Used as a sentinel to indicate that no parameter was passed
TCStr,
TWStr,
TI32,
TU32,
TI64,
TU64,
TDbl,
};
union
{
const char*		CStr;
const wchar_t*	WStr;
int32_t			I32;
uint32_t		UI32;
int64_t			I64;
uint64_t		UI64;
double			Dbl;
};
Types Type;

fmtarg()								: Type(TNull), CStr(NULL) {}
fmtarg( const char* v )					: Type(TCStr), CStr(v) {}
fmtarg( const wchar_t* v )				: Type(TWStr), WStr(v) {}
#ifdef XSTRING_DEFINED
fmtarg( const XStringT<char>& v )		: Type(TCStr), CStr((const char*) v) {}
fmtarg( const XStringT<wchar_t>& v )	: Type(TWStr), WStr((const wchar_t*) v) {}
#endif
fmtarg( const std::string& v )			: Type(TCStr), CStr(v.c_str()) {}
fmtarg( const std::wstring& v )			: Type(TWStr), WStr(v.c_str()) {}
fmtarg( int32_t v )						: Type(TI32), I32(v) {}
fmtarg( uint32_t v )					: Type(TU32), UI32(v) {}
#ifdef _MSC_VER
fmtarg( long v )						: Type(TI32), I32(v) {}
fmtarg( unsigned long v )				: Type(TU32), UI32(v) {}
#endif
fmtarg( int64_t v )						: Type(TI64), I64(v) {}
fmtarg( uint64_t v )					: Type(TU64), UI64(v) {}
fmtarg( double v )						: Type(TDbl), Dbl(v) {}
};

/* This can be used to add custom formatting tokens.
The only supported characters that you can use are "Q" and "q". These were
added for escaping SQL identifiers and strings.
*/
struct fmt_context
{
// Return the number of characters written, or -1 if outBufSize is not large enough to hold
// the number of characters that you need to write. Do not write a null terminator.
typedef intp (*WriteSpecialFunc)( char* outBuf, intp outBufSize, const fmtarg& val );

WriteSpecialFunc Escape_Q;
WriteSpecialFunc Escape_q;

fmt_context()
{
Escape_Q = NULL;
Escape_q = NULL;
}
};

PAPI FMT_STRING fmt_core( const fmt_context& context, const char* fmt, intp nargs, const fmtarg** args );

PAPI FMT_STRING fmt( const char* fs );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14, const fmtarg& a15 );
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14, const fmtarg& a15, const fmtarg& a16 );

/*
PAPI FMT_STRING fmt( const char* fs,
const fmtarg& a1 = fmtarg(),
const fmtarg& a2 = fmtarg(),
const fmtarg& a3 = fmtarg(),
const fmtarg& a4 = fmtarg(),
const fmtarg& a5 = fmtarg(),
const fmtarg& a6 = fmtarg(),
const fmtarg& a7 = fmtarg(),
const fmtarg& a8 = fmtarg(),
const fmtarg& a9 = fmtarg(),
const fmtarg& a10 = fmtarg(),
const fmtarg& a11 = fmtarg(),
const fmtarg& a12 = fmtarg(),
const fmtarg& a13 = fmtarg(),
const fmtarg& a14 = fmtarg(),
const fmtarg& a15 = fmtarg(),
const fmtarg& a16 = fmtarg());
*/

// Clang will need -Wno-variadic-macros
// I believe the use of __VA_ARGS__ is cross-platform enough for our needs
#define fmtout( fs, ... )			fmt_write(stdout, fmt(fs, __VA_ARGS__))
#define fmtoutf( file, fs, ... )	fmt_write(file, fmt(fs, __VA_ARGS__))

// We cannot do fmtout and fmtoutf with macros, because you cannot use __VA_ARGS__ inside a nested macro.
// It's hard to explain in a few short words, but this was the old version, an it's pre-processed output
// #define fmtout( fs, ... )           fputs(FMT_STRING_TO_C(fmt(fs, __VA_ARGS__)), stdout)		--> fputs(static_cast<const char*>(fmt("Hello!", )), (&__iob_func()[1]));
// Notice the trailing comma. That trailing comma is NOT present if you don't have the FMT_STRING_TO_C there.

// The approach of making this proper function has the added advantage that we can write strings with null characters in them
// Returns the number of characters written (ie the result of fwrite).
PAPI size_t fmt_write( FILE* file, const FMT_STRING& s );

/*  cross-platform "snprintf"

destination			Destination buffer
count				Number of characters available in 'destination'. This must include space for the null terminating character.
format_str			The format string
return
-1				Not enough space
0..count-1		Number of characters written, excluding the null terminator. The null terminator was written though.
*/
PAPI int fmt_snprintf( char* destination, size_t count, const char* format_str, ... );

// Identical in all respects to fmt_snprintf, except that we deal with wide character strings
PAPI int fmt_swprintf( wchar_t* destination, size_t count, const wchar_t* format_str, ... );


typedef unsigned char	byte;
typedef unsigned char	u8;
typedef unsigned char	uint8;
typedef unsigned int	u32;
typedef unsigned int	uint32;
typedef int				int32;
typedef unsigned short	uint16;

#ifndef BIT
#define BIT(x) (1 << (x))
#endif

// This executes in ALL BUILDS (not just debug).
#define XOASSERT(x)			AbcAssert(x)

#ifdef _DEBUG
#define XOVERIFY(x)			XOASSERT(x)
#define XOASSERTDEBUG(x)	XOASSERT(x)
#else
#define XOVERIFY(x)			((void)(x))
#define XOASSERTDEBUG(x)	((void)0)
#endif

void*		xoMallocOrDie( size_t bytes );
void*		xoReallocOrDie( void* buf, size_t bytes );
xoString	xoCacheDir();

#define XOCHECKALLOC(x)		XOASSERT((x) != NULL)
#define XOPANIC(msg)		AbcPanic(msg)
#define XOTODO				XOPANIC("not yet implemented")
#define XOTODO_STATIC		static_assert(false, "Implement me");

enum xoPlatform
{
xoPlatform_WinDesktop		= 1,
xoPlatform_Android			= 2,
xoPlatform_LinuxDesktop		= 4,
xoPlatform_All			= 1 | 2 | 4,
};

#if defined(_WIN32)
#define XO_PLATFORM_ANDROID			0
#define XO_PLATFORM_WIN_DESKTOP		1
#define XO_PLATFORM_LINUX_DESKTOP	0
#define XO_PLATFORM					xoPlatform_WinDesktop
#define XOTRACE_WRITE				OutputDebugStringA
#elif defined(ANDROID)
#define XO_PLATFORM_ANDROID			1
#define XO_PLATFORM_WIN_DESKTOP		0
#define XO_PLATFORM_LINUX_DESKTOP	0
#define XO_PLATFORM					xoPlatform_Android
#define XOTRACE_WRITE(msg)			__android_log_write(ANDROID_LOG_INFO, "xo", msg)
#elif defined(__linux__)
#define XO_PLATFORM_ANDROID			0
#define XO_PLATFORM_WIN_DESKTOP		0
#define XO_PLATFORM_LINUX_DESKTOP	1
#define XO_PLATFORM					xoPlatform_LinuxDesktop
#define XOTRACE_WRITE(msg)			fputs(msg, stderr)
#else
#ifdef _MSC_VER
#pragma error( "Unknown xoDom platform" )
#else
#error Unknown xoDom platform
#endif
#endif


// The default styles for tags are defined inside xoDoc::InitializeDefaultTagStyles()

#define XO_TAGS_DEFINE \
XX(NULL, 0) \
XY(Body) \
XY(Div) \
XY(Text) \
XY(Lab) \
XY(END) \

#define XX(a,b) xoTag##a = b,
#define XY(a) xoTag##a,
enum xoTag {
XO_TAGS_DEFINE
};
#undef XX
#undef XY

extern const char* xoTagNames[xoTagEND + 1];


// This is the bottom-level include file that many other xo headers include. It should
// strive to remain quite small.


class xoBox;
class xoBox16;
class xoBoxF;
class xoDomEl;
class xoDomNode;
class xoDomText;
class xoDoc;
class xoEvent;
class xoImage;
class xoImageStore;
class xoLayout;
class xoLayout2;
class xoPool;
class xoDocGroup;
class xoRenderDoc;
class xoRenderer;
class xoRenderDomEl;
class xoRenderDomNode;
class xoRenderDomText;
struct xoRenderCharEl;
class xoRenderBase;
class xoRenderGL;
class xoRenderDX;
class xoString;
class xoStringTable;
class xoStyle;
class xoSysWnd;
class xoFont;
class xoFontStore;
class xoGlyphCache;
class xoTextureAtlas;
#ifndef XO_MAT4F_DEFINED
class xoMat4f;
#endif

typedef int32 xoPos;								// fixed-point position
static xoPos xoPosNULL = INT32MAX;
static const u32 xoPosShift = 8;					// 24:8 fixed point coordinates used during layout
static const u32 xoPosMask = (1 << xoPosShift) - 1;	// 255

// An ID that is internal to xo - i.e. it is not controllable by external code.
// This ID is an integer that you can use to reference a DOM element. These IDs are recycled.
typedef int32 xoInternalID;
static const xoInternalID xoInternalIDNull = 0;		// Zero is always an invalid DOM element ID
static const xoInternalID xoInternalIDRoot = 1;		// The root of the DOM tree always has ID = 1

typedef int32 xoFontID;
static const xoFontID xoFontIDNull = 0;				// Zero is always an invalid Font ID

// Handle to a texture that is (maybe) resident in the graphics driver.
// xo supports the concept of the graphics device being "lost", so just because you have
// a non-zero xoTextureID, does not mean that the ID is valid. Prior to drawing the scene,
// the texture loading functions must check whether the ID is still valid or not.
// Note that there is a lot of unsigned arithmetic used by the texture management facilities,
// so this data type must remain unsigned.
typedef uint32 xoTextureID;
static const xoTextureID xoTextureIDNull = 0;		// Zero is always an invalid Texture ID

// Maximum number of texture units that we will try to use
static const u32 xoMaxTextureUnits = 8;

inline int32	xoIntToPos( int real )			{ return real << xoPosShift; }
inline int32	xoRealx256ToPos( int32 real )	{ return int32(real * ((1 << xoPosShift) / 256)); } // Since xoPosShift = 256, xoRealx256ToPos simplifies out to identity
inline int32	xoRealToPos( float real )		{ return int32(real * (1 << xoPosShift)); }
inline int32	xoDoubleToPos( double real )	{ return int32(real * (1 << xoPosShift)); }
inline float	xoPosToReal( int32 pos )		{ return pos * (1.0f / (1 << xoPosShift)); }
inline double	xoPosToDouble( int32 pos )		{ return pos * (1.0 / (1 << xoPosShift)); }
inline int32	xoPosRound( int32 pos )			{ return pos + (1 << (xoPosShift-1)) & ~xoPosMask; }
inline int32	xoPosRoundDown( int32 pos )		{ return pos & ~xoPosMask; }
inline int32	xoPosRoundUp( int32 pos )		{ return pos + ((1 << xoPosShift) - 1) & ~xoPosMask; }
inline float	xoRound( float real )			{ return floor(real + 0.5f); }

// These purposefully do not pass by reference, because of this: http://randomascii.wordpress.com/2013/11/24/stdmin-causing-three-times-slowdown-on-vc/
template<typename T>	T xoClamp( T v, T vmin, T vmax )	{ return (v < vmin) ? vmin : (v > vmax) ? vmax : v; }
template<typename T>	T xoMin( T a, T b )					{ return a < b ? a : b; }
template<typename T>	T xoMax( T a, T b )					{ return a < b ? b : a; }

enum xoCloneFlags
{
xoCloneFlagEvents = 1,		// Include events in clone
};

static const int XO_MAX_TOUCHES = 10;

enum xoMainEvent
{
xoMainEventInit = 1,
xoMainEventShutdown,
};

enum xoRenderResult
{
// SYNC-JAVA
xoRenderResultNeedMore,
xoRenderResultIdle
};

//struct xoVec2
//{
//	float x,y;
//};
inline xoVec2f XOVEC2(float x, float y) { return xoVec2f(x,y); }

//struct xoVec3
//{
//	float x,y,z;
//};
inline xoVec3f XOVEC3(float x, float y, float z) { return xoVec3f(x,y,z); }

//struct xoVec4
//{
//	float x,y,z,w;
//};
inline xoVec4f XOVEC4(float x, float y, float z, float w) { return xoVec4f(x,y,z,w); }

class XOAPI xoPoint
{
public:
xoPos	X, Y;

xoPoint() : X(0), Y(0) {}
xoPoint( xoPos x, xoPos y ) : X(x), Y(y) {}

void		SetInt( int32 x, int32 y )				{ X = xoRealToPos((float) x); Y = xoRealToPos((float) y); }
bool		operator==( const xoPoint& p ) const	{ return X == p.X && Y == p.Y; }
bool		operator!=( const xoPoint& p ) const	{ return !(*this == p); }
xoPoint		operator+( const xoPoint& p ) const		{ return xoPoint(X + p.X, Y + p.Y); }
xoPoint		operator-( const xoPoint& p ) const		{ return xoPoint(X - p.X, Y - p.Y); }
xoPoint&	operator+=( const xoPoint& p )			{ X += p.X; Y += p.Y; return *this; }
xoPoint&	operator-=( const xoPoint& p )			{ X -= p.X; Y -= p.Y; return *this; }
};

/*
Why does this class have a copy constructor and assignment operator?
Without those, we get data alignment exceptions (signal 7) when running on my Galaxy S3.
I tried explicitly raising the alignment of xoBox to 8 and 16 bytes, but that did not help.
Unfortunately I have not yet had the energy to open up the assembly and see what the compiler is doing wrong.
This is documented inside xo/docs/android.md

There are some magic values in here:
xoBox is used to represent the content-box of a node.
One thing that comes up frequently is that a box has a well defined Left, but no Right. Or vice versa, or any combination thereof.
So, xoPosNULL is treated like a NaN. If either Left or Right is xoPosNULL, then WidthOrNull is xoPosNULL.
Likewise for HeightOrNull.
*/
class XOAPI xoBox
{
public:
xoPos	Left, Right, Top, Bottom;

xoBox() : Left(0), Right(0), Top(0), Bottom(0) {}
xoBox( const xoBox& b ) : Left(b.Left), Right(b.Right), Top(b.Top), Bottom(b.Bottom) {}
xoBox( xoPos left, xoPos top, xoPos right, xoPos bottom ) : Left(left), Right(right), Top(top), Bottom(bottom) {}

#ifdef _WIN32
xoBox( RECT r ) : Left(r.left), Right(r.right), Top(r.top), Bottom(r.bottom) {}
operator RECT() const { RECT r = {Left, Top, Right, Bottom}; return r; }
#endif

void	SetInt( int32 left, int32 top, int32 right, int32 bottom );
void	ExpandToFit( const xoBox& expando );
void	ClampTo( const xoBox& clamp );
xoBox	ShrunkBy( const xoBox& margins );
xoBoxF	ToRealBox() const;

xoPos	Width() const							{ return Right - Left; }
xoPos	Height() const							{ return Bottom - Top; }
xoPos	WidthOrNull() const						{ return (Left == xoPosNULL || Right == xoPosNULL) ? xoPosNULL : Right - Left; }
xoPos	HeightOrNull() const					{ return (Top == xoPosNULL || Bottom == xoPosNULL) ? xoPosNULL : Bottom - Top; }
void	Offset( int32 x, int32 y )				{ Left += x; Right += x; Top += y; Bottom += y; }
void	Offset( xoPoint p )						{ Offset( p.X, p.Y ); }
xoBox	OffsetBy( int32 x, int32 y )			{ return xoBox(Left + x, Top + y, Right + x, Bottom + y); }
xoBox	OffsetBy( xoPoint p )					{ return xoBox(Left + p.X, Top + p.Y, Right + p.X, Bottom + p.Y); }
bool	IsInsideMe( xoPoint p ) const			{ return p.X >= Left && p.Y >= Top && p.X < Right && p.Y < Bottom; }
bool	IsAreaZero() const						{ return Width() == 0 || Height() == 0; }

bool operator==( const xoBox& b ) { return Left == b.Left && Right == b.Right && Top == b.Top && Bottom == b.Bottom; }
bool operator!=( const xoBox& b ) { return !(*this == b); }

// $XO_GCC_ALIGN_BUG
xoBox&	operator=( const xoBox& b ) { Left = b.Left; Right = b.Right; Top = b.Top; Bottom = b.Bottom; return *this; }
};

class XOAPI xoBox16
{
public:
uint16	Left;
uint16	Top;
uint16	Right;
uint16	Bottom;

xoBox16() : Left(0), Right(0), Top(0), Bottom(0) {}
xoBox16( const xoBox& b ) : Left(b.Left), Right(b.Right), Top(b.Top), Bottom(b.Bottom) {}
xoBox16( const xoBox16& b ) : Left(b.Left), Right(b.Right), Top(b.Top), Bottom(b.Bottom) {}
xoBox16( xoPos left, xoPos top, xoPos right, xoPos bottom ) : Left(left), Right(right), Top(top), Bottom(bottom) {}

xoBoxF	ToRealBox() const;
};

class XOAPI xoBoxF
{
public:
float	Left, Right, Top, Bottom;

xoBoxF() : Left(0), Right(0), Top(0), Bottom(0) {}
xoBoxF( float left, float top, float right, float bottom ) : Left(left), Right(right), Top(top), Bottom(bottom) {}
};

struct XOAPI xoRGBA
{
union {
struct {
#if ENDIANLITTLE
uint8 a, b, g, r;
#else
uint8 r: 8;
uint8 g: 8;
uint8 b: 8;
uint8 a: 8;
#endif
};
uint32 u;
};
static xoRGBA RGBA(uint8 r, uint8 g, uint8 b, uint8 a) { xoRGBA c; c.r = r; c.g = g; c.b = b; c.a = a; return c; }
};

// This is non-premultipled alpha
struct XOAPI xoColor
{
union {
struct {
#if ENDIANLITTLE
uint8 b, g, r, a;
#else
uint8 a: 8;
uint8 r: 8;
uint8 g: 8;
uint8 b: 8;
#endif
};
uint32 u;
};

void	Set( uint8 _r, uint8 _g, uint8 _b, uint8 _a ) { r = _r; g = _g; b = _b; a = _a; }
uint32	GetRGBA() const { xoRGBA x; x.r = r; x.g = g; x.b = b; x.a = a; return x.u; }
xoVec4f	GetVec4sRGB() const;
xoVec4f	GetVec4Linear() const;

bool	operator==( const xoColor& x ) const { return u == x.u; }
bool	operator!=( const xoColor& x ) const { return u != x.u; }

static bool		Parse( const char* s, intp len, xoColor& v );
static xoColor	RGBA( uint8 _r, uint8 _g, uint8 _b, uint8 _a )		{ xoColor c; c.Set(_r,_g,_b,_a); return c; }
static xoColor	Make( uint32 _u )									{ xoColor c; c.u = _u; return c; }
};

XOAPI float	xoSRGB2Linear( uint8 srgb );
XOAPI uint8	xoLinear2SRGB( float linear );

struct xoStyleID
{
uint32		StyleID;

xoStyleID()				: StyleID(0)	{}
explicit	xoStyleID( uint32 id )	: StyleID(id)	{}

operator	uint32 () const { return StyleID; }
};

struct xoJob
{
void*	JobData;
void (*JobFunc)( void* jobdata );
};

struct XOAPI xoRenderStats
{
uint32	Clone_NumEls;		// Number of DOM elements cloned

void Reset();
};

enum xoTexFormat
{
xoTexFormatInvalid = 0,
xoTexFormatRGBA8 = 1,
xoTexFormatGrey8 = 2
};

XOAPI size_t xoTexFormatChannelCount( xoTexFormat f );
XOAPI size_t xoTexFormatBytesPerChannel( xoTexFormat f );
XOAPI size_t xoTexFormatBytesPerPixel( xoTexFormat f );

/* Base of all textures
This structure must remain zero-initializable
Once a texture has been uploaded, you may not change width, height, or channel count.
*/
class XOAPI xoTexture
{
public:
uint32		TexWidth;
uint32		TexHeight;
xoBox		TexInvalidRect;		// Invalid rectangle, in integer texel coordinates.
xoTextureID	TexID;				// ID of texture in renderer.
xoTexFormat	TexFormat;
void*		TexData;
int			TexStride;

xoTexture()					{ TexWidth = TexHeight = 0; TexInvalidRect = xoBox(0,0,0,0); TexFormat = xoTexFormatInvalid; TexID = xoTextureIDNull; TexData = NULL; TexStride = 0; }
void	TexInvalidate()				{ TexInvalidRect = xoBox(0, 0, TexWidth, TexHeight); }
void	TexValidate()				{ TexInvalidRect = xoBox(0, 0, 0, 0); }
void*	TexDataAt( int x, int y )	{ return ((char*) TexData) + y * TexStride + x * xoTexFormatBytesPerPixel(TexFormat); }
void*	TexDataAtLine( int y )		{ return ((char*) TexData) + y * TexStride; }
size_t	TexBytesPerPixel() const	{ return xoTexFormatBytesPerPixel(TexFormat); }
void	FlipVertical();
};

// Base of GL and DX shader programs
class xoProgBase
{
public:
};

enum xoShaders
{
xoShaderInvalid,
xoShaderFill,
xoShaderFillTex,
xoShaderRect,
xoShaderTextRGB,
xoShaderTextWhole
// We may someday want to have slots down here available for application-defined custom shaders
};

// A single instance of this is accessible via xoGlobal()
struct xoGlobalStruct
{
int							TargetFPS;
int							NumWorkerThreads;		// Read-only. Set during xoInitialize().
int							MaxSubpixelGlyphSize;	// Maximum font size where we will use sub-pixel glyph textures
bool						PreferOpenGL;			// Prefer OpenGL over DirectX. If this is true, then on Windows OpenGL will be tried first.
bool						EnableVSync;			// This is only respected during device initialization, so you must set it at application start. It raises latency noticeably. This has no effect on DirectX windowed rendering.
bool						EnableSubpixelText;		// Enable sub-pixel text rendering. Assumes pixels are the standard RGB layout. Enabled by default on Windows desktop only.
bool						EnableSRGBFramebuffer;	// Enable sRGB framebuffer (implies linear blending)
bool						EnableKerning;			// Enable kerning on text
bool						RoundLineHeights;		// Round text line heights to integer amounts, so that text line separation is not subject to sub-pixel positioning differences.
bool						SnapBoxes;				// Round certain boxes up to integer pixels.
// From the perspective of having the exact same layout on multiple devices, it seems desirable to operate
// in subpixel coordinates always. However, this ends up producing ugly visuals, for example when
// you have a box with a single pixel border, and it is not aligned to a pixel boundary, then you get
// the border smudged across two pixels.
bool						SnapSubpixelHorzText;	// When rendering subpixel text, snap glyphs to whole pixels, instead of sub-pixel horizontal positioning.
// This not only determines layout behaviour, but also how our subpixel glyphs are rasterized.
//bool						EmulateGammaBlending;	// Only applicable when EnableSRGBFramebuffer = true, this tries to emulate gamma-space blending. You would turn this on to get consistent blending on all devices. FAILED EXPERIMENT - BAD IDEA.
float						SubPixelTextGamma;		// Tweak freetype's gamma when doing sub-pixel text rendering. Should be no need to use anything other than 1.0
float						WholePixelTextGamma;	// Tweak freetype's gamma when doing whole-pixel text rendering. Should be no need to use anything other than 1.0
float						EpToPixel;				// Eye Pixel to Pixel.
xoTextureID					MaxTextureID;			// Used to test texture ID wrap-around. Were it not for testing, this could be 2^32 - 1
xoColor						ClearColor;				// glClearColor

// Debugging flags. Enabling these should make debugging easier.
// Some of them may turn out to have a small enough performance hit that you can
// leave them turned on always.
// NOPE.. it's just too confusing to have this optional. It's always on.
//bool						DebugZeroClonedChildList;	// During a document clone, zero out ChildByInternalID before populating. This will ensure that gaps are NULL instead of random memory.

pvect<xoDocGroup*>			Docs;				// Only Main thread is allowed to touch this.
TAbcQueue<xoDocGroup*>		DocAddQueue;		// Documents requesting addition
TAbcQueue<xoDocGroup*>		DocRemoveQueue;		// Documents requesting removal
TAbcQueue<xoEvent>			EventQueue;			// Global event queue, consumed by the one-and-only UI thread
TAbcQueue<xoJob>			JobQueue;			// Global job queue, consumed by the worker thread pool
xoFontStore*				FontStore;			// All fonts known to the system.
xoGlyphCache*				GlyphCache;			// This might have to move into a less global domain.
};

XOAPI xoGlobalStruct*	xoGlobal();
XOAPI void				xoInitialize();
XOAPI void				xoShutdown();
XOAPI void				xoProcessDocQueue();
XOAPI void				xoParseFail( const char* msg, ... );
XOAPI void				XOTRACE( const char* msg, ... );
XOAPI void				NUTIME( const char* msg, ... );
#if XO_PLATFORM_WIN_DESKTOP
XOAPI void				xoRunWin32MessageLoop();
#elif XO_PLATFORM_LINUX_DESKTOP
XOAPI void				xoRunXMessageLoop();
#endif

// Various tracing options. Uncomment these to enable tracing of that class of events.
//#define XOTRACE_RENDER_ENABLE
#define XOTRACE_LAYOUT_WARNINGS_ENABLE
//#define XOTRACE_LAYOUT_VERBOSE_ENABLE
//#define XOTRACE_EVENTS_ENABLE
//#define XOTRACE_LATENCY_ENABLE

#ifdef XOTRACE_RENDER_ENABLE
#define XOTRACE_RENDER(msg, ...) NUTIME(msg, ##__VA_ARGS__)
#else
#define XOTRACE_RENDER(msg, ...) ((void)0)
#endif

#ifdef XOTRACE_LAYOUT_WARNINGS_ENABLE
#define XOTRACE_LAYOUT_WARNING(msg, ...) NUTIME(msg, ##__VA_ARGS__)
#else
#define XOTRACE_LAYOUT_WARNING(msg, ...) ((void)0)
#endif

#ifdef XOTRACE_LAYOUT_VERBOSE_ENABLE
#define XOTRACE_LAYOUT_VERBOSE(msg, ...) NUTIME(msg, ##__VA_ARGS__)
#else
#define XOTRACE_LAYOUT_VERBOSE(msg, ...) ((void)0)
#endif

#ifdef XOTRACE_EVENTS_ENABLE
#define XOTRACE_EVENTS(msg, ...) NUTIME(msg, ##__VA_ARGS__)
#else
#define XOTRACE_EVENTS(msg, ...) ((void)0)
#endif

#ifdef XOTRACE_LATENCY_ENABLE
#define XOTRACE_LATENCY(msg, ...) NUTIME(msg, ##__VA_ARGS__)
#else
#define XOTRACE_LATENCY(msg, ...) ((void)0)
#endif


template<typename T>
void xoClonePvectPrepare( pvect<T>& dst, const pvect<T>& src, xoPool* pool )
{
if ( src.count != 0 ) dst.data = (void**) pool->Alloc( sizeof(T) * src.count, true );
dst.count = src.count;
dst.capacity = src.capacity;
}

template<typename T>
void xoClonePodvecPrepare( podvec<T>& dst, const podvec<T>& src, xoPool* pool )
{
if ( src.count != 0 ) dst.data = (T*) pool->Alloc( sizeof(T) * src.count, true );
dst.count = src.count;
dst.capacity = src.capacity;
}

//template<typename T>
//void xoClonePodvecWithCloneFastInto( podvec<T>& dst, const podvec<T>& src, xoPool* pool )
//{
//	xoClonePodvecPrepare( dst, src, pool );
//	for ( uintp i = 0; i < src.count; i++ )
//	{
//		src[i].CloneFastInto( dst[i], pool );
//	}
//}

template<typename T>
void xoClonePodvecWithMemCopy( podvec<T>& dst, const podvec<T>& src, xoPool* pool )
{
xoClonePodvecPrepare( dst, src, pool );
memcpy( dst.data, src.data, src.size() * sizeof(T) );
}

//template<typename T, size_t N>
//void xoCloneStaticArrayWithCloneFastInto( T (&dst)[N], const T (&src)[N], xoPool* pool )
//{
//	for ( size_t i = 0; i < N; i++ )
//		src[i].CloneFastInto( dst[i], pool );
//}

template<typename T, size_t N>
void xoCloneStaticArrayWithCloneSlowInto( T (&dst)[N], const T (&src)[N] )
{
for ( size_t i = 0; i < N; i++ )
src[i].CloneSlowInto( dst[i] );
}



// It will be good if we can keep these inside 32 bits, for easy masking of handlers. If not, just use as many 32-bit words as necessary.
enum xoEvents
{
xoEventTouch		= BIT(0),
xoEventMouseMove	= BIT(1),
xoEventWindowSize	= BIT(2),
xoEventTimer		= BIT(3),
xoEventClick		= BIT(4),
};

/* User interface event (keyboard, mouse, touch, etc).
*/
class XOAPI xoEvent
{
public:
xoDocGroup*		DocGroup;
void*			Context;
xoDomEl*		Target;
xoEvents		Type;
int				PointCount;					// Mouse = 1	Touch >= 1
xoVec2f			Points[XO_MAX_TOUCHES];

xoEvent();
~xoEvent();

void MakeWindowSize( int w, int h );
};

typedef std::function<bool(const xoEvent& ev)> xoEventHandlerLambda;

typedef bool (*xoEventHandlerF)(const xoEvent& ev);

XOAPI bool xoEventHandler_LambdaStaticFunc(const xoEvent& ev);

enum xoEventHandlerFlags
{
xoEventHandlerFlag_IsLambda = 1,
};

class XOAPI xoEventHandler
{
public:
uint32				Mask;
uint32				Flags;
void*				Context;
xoEventHandlerF		Func;

xoEventHandler();
~xoEventHandler();

bool	Handles( xoEvents ev ) const	{ return !!(Mask & ev); }
bool	IsLambda() const				{ return !!(Flags & xoEventHandlerFlag_IsLambda); }
void	SetLambda()						{ Flags |= xoEventHandlerFlag_IsLambda; }
};


// A memory pool
class XOAPI xoPool
{
public:
xoPool();
~xoPool();

void	SetChunkSize( size_t size );

void*	Alloc( size_t bytes, bool zeroInit );

template<typename T>
T*		AllocT( bool zeroInit ) { return (T*) Alloc( sizeof(T), zeroInit ); }

template<typename T>
T*		AllocNT( size_t count, bool zeroInit ) { return (T*) Alloc( count * sizeof(T), zeroInit ); }

void	FreeAll();
void	FreeAllExceptOne();

protected:
size_t			ChunkSize;
size_t			TopRemain;
podvec<void*>	Chunks;
podvec<void*>	BigBlocks;
};

// A vector that allocates its storage from a xoPool object
template<typename T>
class xoPoolArray
{
public:
xoPool*		Pool;
T*			Data;
uintp		Count;
uintp		Capacity;

xoPoolArray()
{
Pool = NULL;
Data = NULL;
Count = 0;
Capacity = 0;
}

xoPoolArray& operator+=( const T& v )
{
add( &v );
return *this;
}

T& operator[]( intp _i )
{
return Data[_i];
}

const T& operator[]( intp _i ) const
{
return Data[_i];
}

T& back()
{
return Data[Count - 1];
}

const T& back() const
{
return Data[Count - 1];
}

void pop()
{
XOASSERTDEBUG(Count > 0);
Count--;
}

T& add( const T* v = NULL )
{
if ( Count == Capacity )
grow();

if ( v )
Data[Count++] = *v;
else
Data[Count++] = T();

return Data[Count - 1];
}

intp size() const { return Count; }

void resize( intp n )
{
if ( n != Count )
{
clear();
if ( n != 0 )
{
growto( n );
Count = n;
}
}
}

void reserve( intp n )
{
if ( n > (intp) Capacity )
growto( n );
}

void clear()
{
Data = NULL;
Count = 0;
Capacity = 0;
}

protected:
void grow()
{
uintp ncap = std::max(Capacity * 2, (uintp) 2);
growto( ncap );
}

void growto( uintp ncap )
{
T* ndata = (T*) Pool->Alloc( sizeof(T) * ncap, false );
XOCHECKALLOC(ndata);
memcpy( ndata, Data, sizeof(T) * Capacity );
memset( ndata + Capacity, 0, sizeof(T) * (ncap - Capacity) );
Capacity = ncap;
Data = ndata;
}
};

// Last-in-first-out buffer. This is used instead of stack storage.
// There is a hard limit here - the buffer size you request is
// allocated up front. The assumed usage is identical to that of a stack.
// This was created to lessen the burden on the actual thread stack during
// layout.
// You must free objects in the reverse order that you allocated them.
class XOAPI xoLifoBuf
{
public:
xoLifoBuf();
xoLifoBuf( size_t size );	// This simply calls Init(size)
~xoLifoBuf();

// Initialize the buffer.
// This will panic if the buffer is not empty.
void	Init( size_t size );

// Allocate a new item.
// It is legal to allocate 0 bytes. You can then us Realloc to grow. Regardless
// of the size of your initial allocation, you must always call Free() on anything
// that you have Alloc'ed.
// This will panic if the buffer size is exhausted.
void*	Alloc( size_t bytes );

// Grow the most recently allocated item to the specified size.
// This will panic if buf is not the most recently allocated item, or if the buffer size is exhausted.
void	Realloc( void* buf, size_t bytes );

// This is a less safe version of Realloc. The only check it performs is whether we will run out of space.
void	GrowLast( size_t moreBytes );

// Free the most recently allocated item
// This will panic if buf is not the most recently allocated item, and buf is not null.
void	Free( void* buf );

private:
podvec<intp>	ItemSizes;
void*			Buffer;
intp			Size;
intp			Pos;
};

// Vector that uses xoLifoBuf for storage. This is made for PODs - it does not do
// object construction or destruction.
template<typename T>
class xoLifoVector
{
public:
xoLifoVector( xoLifoBuf& lifo )
{
Lifo = &lifo;
}
~xoLifoVector()
{
Lifo->Free( Data );
}

void AddN( intp numElementsToAdd )
{
if ( Data == nullptr )
Data = (T*) Lifo->Alloc( numElementsToAdd * sizeof(T) );
else
Lifo->GrowLast( numElementsToAdd * sizeof(T) );
Count += numElementsToAdd;
}

void Push( const T& t )
{
intp c = Count;
AddN( 1 );
Data[c] = t;
}

T& Back()
{
return Data[Count - 1];
}

xoLifoVector& operator+=( const T& t )
{
Push( t );
return *this;
}

T& operator[]( intp i ) { return Data[i]; }

private:
xoLifoBuf*	Lifo;
T*			Data = nullptr;
intp		Count = 0;
};



class XOAPI xoStringTable
{
public:
xoStringTable();
~xoStringTable();

const char*			GetStr( int id ) const;			// Returns an empty string if the id is invalid or zero.
int					GetId( const char* str );

// This assumes that xoStringTable is "append-only", which it currently is.
// Knowing this allows us to make the clone from Document to Render Document trivially fast.
void				CloneFrom_Incremental( const xoStringTable& src );

protected:
xoPool						Pool;
fhashmap<xoString, int>		NameToId;			// This could be improved dramatically, by avoiding the heap alloc for every item
pvect<const char*>			IdToName;
};



// The list of styles that are inherited by child nodes lives in xoInheritedStyleCategories

// Represents a size that is zero, pixels, eye pixels, points, percent.
// TODO: em
// Zero is represented as 0 pixels
// See "layout" documentation for explanation of units.
struct XOAPI xoSize
{
enum	Types { NONE = 0, PX, PT, EP, PERCENT };
float 	Val;
Types 	Type;

static xoSize	Make( Types t, float v )	{ xoSize s = {v, t}; return s; }
static xoSize	Percent( float v )			{ xoSize s = {v, PERCENT}; return s; }
static xoSize	Points( float v )			{ xoSize s = {v, PT}; return s; }
static xoSize	Pixels( float v )			{ xoSize s = {v, PX}; return s; }
static xoSize	EyePixels( float v )		{ xoSize s = {v, EP}; return s; }
static xoSize	Zero()						{ xoSize s = {0, PX}; return s; }
static xoSize	Null()						{ xoSize s = {0, NONE}; return s; }

static bool		Parse( const char* s, intp len, xoSize& v );
};

// Convenience struct used during layout computation
struct XOAPI xoStyleBox
{
// This order (left,top,right,bottom) must be consistent with the order presented inside XO_STYLE_DEFINE
union
{
struct
{
xoSize	Left, Top, Right, Bottom;
};
xoSize All[4];
};

static bool			Parse( const char* s, intp len, xoStyleBox& v );
static xoStyleBox	Make( xoSize left, xoSize top, xoSize right, xoSize bottom )	{ xoStyleBox b; b.Left = left; b.Top = top; b.Right = right; b.Bottom = bottom; return b; }
static xoStyleBox	MakeUniform( xoSize all )										{ xoStyleBox b; b.Left = all; b.Top = all; b.Right = all; b.Bottom = all; return b; }
static xoStyleBox	MakeZero() { xoStyleBox b; b.SetZero(); return b; }
void SetZero() { Left = Top = Right = Bottom = xoSize::Pixels(0); }
};

enum xoDisplayType
{
xoDisplayBlock,
xoDisplayInline
};

enum xoFlowDirection
{
xoFlowDirectionNormal,
xoFlowDirectionReversed
};

enum xoFlowAxis
{
xoFlowAxisVertical,		// Vertical is the default
xoFlowAxisHorizontal
};

enum xoTextAlignVertical
{
xoTextAlignVerticalBaseline,	// Baseline is default
xoTextAlignVerticalTop			// This is unlikely to be useful, but having it proves that we *could* make other rules if proved useful
};

enum xoVerticalBindings
{
xoVerticalBindingNULL,
xoVerticalBindingTop,			// Top of parent's content box
xoVerticalBindingCenter,		// Center of parent's content box
xoVerticalBindingBottom,		// Bottom of parent's content box
xoVerticalBindingBaseline,		// Parent's baseline
};

enum xoHorizontalBindings
{
xoHorizontalBindingNULL,
xoHorizontalBindingLeft,		// Left of parent's content box
xoHorizontalBindingCenter,		// Center of parent's content box
xoHorizontalBindingRight,		// Right of parent's content box
};

enum xoPositionType
{
// All of these definitions are the same as HTML's
xoPositionStatic,		// Default, regular position
xoPositionAbsolute,		// Absolute, relative to previous explicitly parent that was anything other than "Static". Does not affect flow of subsequent siblings.
xoPositionRelative,		// Like Absolute, but does affect flow. Flow is the "ghost" of where we would have been, before being moved relatively.
xoPositionFixed,		// Fixed, according to root device coordinate system. In other words, completely independent of DOM hierarchy.
};

enum xoBoxSizeType
{
xoBoxSizeContent,
xoBoxSizeBorder,
xoBoxSizeMargin			// Created initially for the <body> element
};

enum xoBreakType
{
xoBreakNULL,
xoBreakBefore,			// Break flow before element
xoBreakAfter			// Break flow after element
};

// The following attributes are "bind sources". You bind a position of your own to a position on your parent node.
// The "bind targets" that you can bind to on your parent node are the same properties that can be used as bind sources.
// So if you bind left:right, then you are binding your left edge to your parent content box's right edge.
// If you bind vcenter:vcenter, then you bind your vertical center to the vertical center of your parent context box.
// * Left
// * HCenter
// * Right
// * Top
// * VCenter
// * Bottom
// * Baseline

// The order of the box components (left,top,right,bottom) must be consistent with the order in xoStyleBox
// In addition, all 'box' types must fall between Margin_Left and Border_Bottom. This is simply for sanity. It is verified
// inside xoStyle.SetBox()
#define XO_STYLE_DEFINE \
XX(NULL, 0) \
XY(Color) \
XY(Display) \
XY(Background) \
XY(BackgroundImage) \
XY(Text_Align_Vertical) \
\
XY(Break) \
XY(Dummy3_UseMe) \
\
XY(Margin_Left) \
XY(Margin_Top) \
XY(Margin_Right) \
XY(Margin_Bottom) \
\
XY(Padding_Left) \
XY(Padding_Top) \
XY(Padding_Right) \
XY(Padding_Bottom) \
\
XY(Border_Left) \
XY(Border_Top) \
XY(Border_Right) \
XY(Border_Bottom) \
\
XY(BorderColor_Left) \
XY(BorderColor_Top) \
XY(BorderColor_Right) \
XY(BorderColor_Bottom) \
\
XY(Width) \
XY(Height) \
\
XY(Top) \
XY(VCenter) \
XY(Bottom) \
XY(Baseline) \
XY(Left) \
XY(HCenter) \
XY(Right) \
\
XY(FontSize) \
XY(FontFamily) \
\
XY(BorderRadius) \
XY(Position) \
XY(Flow_Axis) \
XY(Flow_Direction_Horizontal) \
XY(Flow_Direction_Vertical) \
XY(BoxSizing) \
XY(END)

#define XX(a,b) xoCat##a = b,
#define XY(a) xoCat##a,
enum xoStyleCategories {
XO_STYLE_DEFINE
xoCatFIRST = xoCatColor,
};
#undef XX
#undef XY

static_assert( xoCatMargin_Left % 4 == 0, "Start of boxes must be multiple of 4" );

inline xoStyleCategories xoCatMakeBaseBox( xoStyleCategories c ) { return (xoStyleCategories) (c & ~3); }

// Styles that are inherited by default
// Generally it is text styles that are inherited
// Inheritance means that child nodes inherit the styles of their parents
const int						xoNumInheritedStyleCategories = 4;
extern const xoStyleCategories	xoInheritedStyleCategories[xoNumInheritedStyleCategories];

/* Single style attribute (such as Margin-Left, Width, FontSize, etc).
This must be zero-initializable (i.e. with memset(0)).
It must remain small.
Currently, sizeof(xoStyleAttrib) = 8.
*/
class XOAPI xoStyleAttrib
{
public:
enum Flag
{
// This means that the attribute takes its value from its closest ancestor in the DOM tree.
// Some styles are inherited by default (the list specified inside xoInheritedStyleCategories).
FlagInherit = 1
};

uint8				Category;		// type xoStyleCategories
uint8				SubType;
uint8				Flags;
uint8				Unused2;
union
{
uint32			ValU32;
float			ValF;
};

xoStyleAttrib();

void SetInherit( xoStyleCategories cat );

void SetColor( xoStyleCategories cat, xoColor val )				{ SetU32( cat, val.u ); }
void SetSize( xoStyleCategories cat, xoSize val )				{ SetWithSubtypeF( cat, val.Type, val.Val ); }
void SetDisplay( xoDisplayType val )							{ SetU32( xoCatDisplay, val ); }
void SetBorderRadius( xoSize val )								{ SetSize( xoCatBorderRadius, val ); }
void SetPosition( xoPositionType val )							{ SetU32( xoCatPosition, val ); }
void SetFont( xoFontID val )									{ SetU32( xoCatFontFamily, val ); }
void SetBackgroundImage( const char* image, xoDoc* doc )		{ SetString( xoCatBackgroundImage, image, doc ); }
void SetBreak( xoBreakType type )								{ SetU32( xoCatBreak, type); }
void SetFlowAxis( xoFlowAxis axis )								{ SetU32( xoCatFlow_Axis, axis ); }
void SetFlowDirectionHorizonal( xoFlowDirection dir )			{ SetU32( xoCatFlow_Direction_Horizontal, dir ); }
void SetFlowDirectionVertical( xoFlowDirection dir )			{ SetU32( xoCatFlow_Direction_Vertical, dir ); }
void SetBoxSizing( xoBoxSizeType type )							{ SetU32( xoCatBoxSizing, type ); }
void SetTextAlignVertical( xoTextAlignVertical align )			{ SetU32( xoCatText_Align_Vertical, align ); }
void SetLeft( xoHorizontalBindings bind )						{ SetU32( xoCatLeft, bind ); }
void SetHCenter( xoHorizontalBindings bind )					{ SetU32( xoCatHCenter, bind ); }
void SetRight( xoHorizontalBindings bind )						{ SetU32( xoCatRight, bind ); }
void SetTop( xoVerticalBindings bind )							{ SetU32( xoCatTop, bind ); }
void SetVCenter( xoVerticalBindings bind )						{ SetU32( xoCatVCenter, bind ); }
void SetBottom( xoVerticalBindings bind )						{ SetU32( xoCatBottom, bind ); }
void SetBaseline( xoVerticalBindings bind )						{ SetU32( xoCatBaseline, bind ); }

// Generic Set() that is used by template code
void Set( xoStyleCategories cat, xoColor val )					{ SetColor( cat, val ); }
void Set( xoStyleCategories cat, xoSize val )					{ SetSize( cat, val ); }
void Set( xoStyleCategories cat, xoDisplayType val )			{ SetDisplay( val ); }
void Set( xoStyleCategories cat, xoPositionType val )			{ SetPosition( val ); }
void Set( xoStyleCategories cat, xoBreakType val )				{ SetBreak( val ); }
void Set( xoStyleCategories cat, xoFlowAxis val )				{ SetFlowAxis( val ); }
void Set( xoStyleCategories cat, xoFlowDirection val )			{ SetU32( cat, val ); }
void Set( xoStyleCategories cat, xoBoxSizeType val )			{ SetBoxSizing( val ); }
void Set( xoStyleCategories cat, xoTextAlignVertical val )		{ SetU32( cat, val ); }
void Set( xoStyleCategories cat, xoHorizontalBindings val )		{ SetU32( cat, val ); }
void Set( xoStyleCategories cat, xoVerticalBindings val )		{ SetU32( cat, val ); }
void Set( xoStyleCategories cat, xoFontID val )					{ SetFont( val ); }
void Set( xoStyleCategories cat, const char* val, xoDoc* doc )	{ SetString( cat, val, doc ); }

bool					IsNull() const							{ return Category == xoCatNULL; }
bool					IsInherit() const						{ return Flags == FlagInherit; }

xoStyleCategories		GetCategory() const						{ return (xoStyleCategories) Category; }
xoSize					GetSize() const							{ return xoSize::Make( (xoSize::Types) SubType, ValF ); }
xoColor					GetColor() const						{ return xoColor::Make( ValU32 ); }
xoDisplayType			GetDisplayType() const					{ return (xoDisplayType) ValU32; }
xoPositionType			GetPositionType() const					{ return (xoPositionType) ValU32; }
xoBreakType				GetBreakType() const					{ return (xoBreakType) ValU32; }
int						GetStringID() const						{ return (int) ValU32; }
xoFlowAxis				GetFlowAxis() const						{ return (xoFlowAxis) ValU32; }
xoFlowDirection			GetFlowDirectionMajor() const			{ return (xoFlowDirection) ValU32; }
xoFlowDirection			GetFlowDirectionMinor() const			{ return (xoFlowDirection) ValU32; }
xoBoxSizeType			GetBoxSizing() const					{ return (xoBoxSizeType) ValU32; }
xoTextAlignVertical		GetTextAlignVertical() const			{ return (xoTextAlignVertical) ValU32; }
xoHorizontalBindings	GetHorizontalBinding() const			{ return (xoHorizontalBindings) ValU32; }
xoVerticalBindings		GetVerticalBinding() const				{ return (xoVerticalBindings) ValU32; }

const char*				GetBackgroundImage( xoStringTable* strings ) const;
xoFontID				GetFont() const;

protected:
void SetString( xoStyleCategories cat, const char* str, xoDoc* doc );
void SetU32( xoStyleCategories cat, uint32 val );
void SetWithSubtypeU32( xoStyleCategories cat, uint8 subtype, uint32 val );
void SetWithSubtypeF( xoStyleCategories cat, uint8 subtype, float val );
};

/* Collection of style attributes (border-width-left, color, etc)
This container is simple and list-based.
There is a different container called xoStyleSet that is more performant,
built for use during rendering.
*/
class XOAPI xoStyle
{
public:
podvec<xoStyleAttrib>	Attribs;

bool					Parse( const char* t, xoDoc* doc );
bool					Parse( const char* t, intp maxLen, xoDoc* doc );
const xoStyleAttrib*	Get( xoStyleCategories cat ) const;
void					SetBox( xoStyleCategories cat, xoStyleBox val );
void					GetBox( xoStyleCategories cat, xoStyleBox& box ) const;
void					SetUniformBox( xoStyleCategories cat, xoStyleAttrib val );
void					SetUniformBox( xoStyleCategories cat, xoColor color );
void					SetUniformBox( xoStyleCategories cat, xoSize size );
void					Set( xoStyleAttrib attrib );
void					Set( xoStyleCategories cat, xoStyleBox val );	// This overload is identical to SetBox, but needs to be present for templated parsing functions
//void					Compute( const xoDoc& doc, const xoDomEl& node );
void					Discard();
void					CloneSlowInto( xoStyle& c ) const;
void					CloneFastInto( xoStyle& c, xoPool* pool ) const;

// Setter functions with 2 parameters
#define NUSTYLE_SETTERS_2P \
XX(BackgroundColor,		xoColor,	SetColor,	xoCatBackground) \
XX(Width,				xoSize,		SetSize,	xoCatWidth) \
XX(Height,				xoSize,		SetSize,	xoCatHeight) \
XX(Left,				xoSize,		SetSize,	xoCatLeft) \
XX(Right,				xoSize,		SetSize,	xoCatRight) \
XX(Top,					xoSize,		SetSize,	xoCatTop) \
XX(Bottom,				xoSize,		SetSize,	xoCatBottom) \

// Setter functions with 1 parameter
#define NUSTYLE_SETTERS_1P \
XX(Position,			xoPositionType,	SetPosition) \

#define XX(name, type, setfunc, cat)	void Set##name( type value );
NUSTYLE_SETTERS_2P
#undef XX

#define XX(name, type, setfunc)			void Set##name( type value );
NUSTYLE_SETTERS_1P
#undef XX

protected:
//void					MergeInZeroCopy( int n, const xoStyle** src );
void					SetBoxInternal( xoStyleCategories catBase, xoStyleBox val );
};

FHASH_SETUP_CLASS_CTOR_DTOR(xoStyle, xoStyle);

/* A bag of styles in a performant container.

Analysis of storage (assuming xoCatEND = 128)

Number of attributes	Size of Lookup			Size of Attribs		Total marginal size
1 << 2 = 4				128 * 2 / 8 = 32		4 * 8   = 32		32 + 32    = 64
1 << 4 = 16				128 * 4 / 8 = 64		16 * 8  = 128		64 + 128   = 192
1 << 8 = 256			128 * 8 / 8 = 128		256 * 8 = 2048		128 + 2048 = 2176

One very significant optimization that remains here is to not grow Attrib[] so heavily.
Growing from 16 to 256 is an insane leap.

Idea: There are some attributes that need only a few bits. Instead of packing each of these
into 8 bytes, we can instead store groups of attributes in special 8 byte blocks.

More Idea: I think I might end up writing a very specialized container for this stuff.. where we
separate things out into really tight bags of properties. But we'll wait until it's a bottleneck.

*/
class XOAPI xoStyleSet
{
public:
static const uint32 InitialBitsPerSlot = 2;		// 1 << 2 = 4, is our lowest non-empty size
static const uint32 SlotOffset = 1;				// We need to reserve zero for the "empty" state of a slot

xoStyleSet();		// Simply calls Reset()
~xoStyleSet();		// Destructor does nothing

void			Set( int n, const xoStyleAttrib* attribs, xoPool* pool );
void			Set( const xoStyleAttrib& attrib, xoPool* pool );
xoStyleAttrib	Get( xoStyleCategories cat ) const;
bool			Contains( xoStyleCategories cat ) const;
void			Reset();

protected:
typedef void  (*SetSlotFunc) ( void* lookup, xoStyleCategories cat, int32 slot );
typedef int32 (*GetSlotFunc) ( const void* lookup, xoStyleCategories cat );

void*			Lookup;			// Variable bit-width table that indexes into Attribs. Size is always xoCatEND.
xoStyleAttrib*	Attribs;		// The Category field in here is wasted.
int32			Count;			// Size of Attribs
int32			Capacity;		// Capacity of Attribs
uint32			BitsPerSlot;	// Number of bits in each slot of Lookup. Our possible sizes are 2,4,8.
SetSlotFunc		SetSlotF;
GetSlotFunc		GetSlotF;

void			Grow( xoPool* pool );
int32			GetSlot( xoStyleCategories cat ) const;
void			SetSlot( xoStyleCategories cat, int32 slot );
void			DebugCheckSanity() const;

static void		MigrateLookup( const void* lutsrc, void* lutdst, GetSlotFunc getter, SetSlotFunc setter );

template<uint32 BITS_PER_SLOT>
static void		TSetSlot( void* lookup, xoStyleCategories cat, int32 slot );

template<uint32 BITS_PER_SLOT>
static int32	TGetSlot( const void* lookup, xoStyleCategories cat );

static int32	GetSlot2( const void* lookup, xoStyleCategories cat );
static int32	GetSlot4( const void* lookup, xoStyleCategories cat );
static int32	GetSlot8( const void* lookup, xoStyleCategories cat );
static void		SetSlot2( void* lookup, xoStyleCategories cat, int32 slot );
static void		SetSlot4( void* lookup, xoStyleCategories cat, int32 slot );
static void		SetSlot8( void* lookup, xoStyleCategories cat, int32 slot );

// The -1 here is for SlotOffset
static int32	CapacityAt( uint32 bitsPerSlot )	{ return (1 << bitsPerSlot) - 1; }

};

// The set of style information that is used by the renderer
// This is baked in by the Layout engine.
// This struct is present in every single xoRenderDomNode, so it pays to keep it tight.
class XOAPI xoStyleRender
{
public:
xoBox16 BorderSize;
xoBox16 Padding;			// This is probably not necessary. See log entry from 2014-08-02
xoColor BackgroundColor;
xoColor BorderColor;
int		BackgroundImageID;
float	BorderRadius;

xoStyleRender() { memset(this, 0, sizeof(*this)); }
};

/* Store all style classes in one table, that is owned by one document.
This allows us to reference styles by a 32-bit integer ID instead of by name.
*/
class XOAPI xoStyleTable
{
public:
xoStyleTable();
~xoStyleTable();

void			AddDummyStyleZero();
void			Discard();
xoStyle*		GetOrCreate( const char* name );
const xoStyle*	GetByID( xoStyleID id ) const;
xoStyleID		GetStyleID( const char* name );
void			CloneSlowInto( xoStyleTable& c ) const;					// Does not clone NameToIndex
void			CloneFastInto( xoStyleTable& c, xoPool* pool ) const;	// Does not clone NameToIndex

protected:
podvec<xoString>			Names;		// Names and Styles are parallels
podvec<xoStyle>				Styles;
podvec<int>					UnusedSlots;
fhashmap<xoString, int>		NameToIndex;
};


XOAPI bool xoParseDisplayType( const char* s, intp len, xoDisplayType& t );
XOAPI bool xoParsePositionType( const char* s, intp len, xoPositionType& t );
XOAPI bool xoParseBreakType( const char* s, intp len, xoBreakType& t );
XOAPI bool xoParseFlowAxis( const char* s, intp len, xoFlowAxis& t );
XOAPI bool xoParseFlowDirection( const char* s, intp len, xoFlowDirection& t );
XOAPI bool xoParseBoxSize( const char* s, intp len, xoBoxSizeType& t );
XOAPI bool xoParseTextAlignVertical( const char* s, intp len, xoTextAlignVertical& t );
XOAPI bool xoParseHorizontalBinding( const char* s, intp len, xoHorizontalBindings& t );
XOAPI bool xoParseVerticalBinding( const char* s, intp len, xoVerticalBindings& t );
XOAPI bool xoParseBorder( const char* s, intp len, xoStyle& style );




/* A system window, or view.
*/
class XOAPI xoSysWnd
{
public:
enum SetPositionFlags
{
SetPosition_Move = 1,
SetPosition_Size = 2,
};
#if XO_PLATFORM_WIN_DESKTOP
HWND					SysWnd;
#elif XO_PLATFORM_ANDROID
xoBox					RelativeClientRect;		// Set by NuLib_init
#elif XO_PLATFORM_LINUX_DESKTOP
Display*				XDisplay;
Window					XWindowRoot;
//GLint					att[] = { GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_DOUBLEBUFFER, None };
XVisualInfo*			VisualInfo;
Colormap				ColorMap;
Window					XWindow;
GLXContext				GLContext;
XEvent					Event;
#else
XOTODO_STATIC;
#endif
xoDocGroup*			DocGroup;
xoRenderBase*		Renderer;

xoSysWnd();
~xoSysWnd();

static xoSysWnd*	Create();
static xoSysWnd*	CreateWithDoc();
static void			PlatformInitialize();

void	Attach( xoDoc* doc, bool destroyDocWithProcessor );
void	Show();
xoDoc*	Doc();
bool	BeginRender();				// Basically wglMakeCurrent()
void	EndRender();				// SwapBuffers followed by wglMakeCurrent(NULL)
void	SurfaceLost();				// Surface lost, and now regained. Reinitialize GL state (textures, shaders, etc).
void	SetPosition( xoBox box, uint setPosFlags );
xoBox	GetRelativeClientRect();	// Returns the client rectangle (in screen coordinates), relative to the non-client window

protected:
bool	InitializeRenderer();

template<typename TRenderer>
bool	InitializeRenderer_Any( xoRenderBase*& renderer );
};


#ifdef _MSC_VER

#define DISABLE_CODE_ANALYSIS_WARNINGS_PUSH_USING_FAILED_CALL_VALUE \
__pragma( warning(push) ) \
__pragma( warning(disable:6102) )

#define DISABLE_CODE_ANALYSIS_WARNINGS_POP \
__pragma( warning(pop) )

#else

#define __analysis_assume(exp)

#define DISABLE_CODE_ANALYSIS_WARNINGS_PUSH_MIN_MAX_28285
#define DISABLE_CODE_ANALYSIS_WARNINGS_POP

#endif





/* DOM node in the tree.
*/
class XOAPI xoDomEl
{
public:
xoDomEl( xoDoc* doc, xoTag tag );
virtual ~xoDomEl();

virtual void			SetText( const char* txt ) = 0;		// Replace all children with a single xoTagText child, or set internal text if 'this' is xoTagText.
virtual const char*		GetText() const = 0;				// Reverse behaviour of SetText()
virtual void			CloneSlowInto( xoDomEl& c, uint cloneFlags ) const = 0;
virtual void			ForgetChildren() = 0;

xoInternalID					GetInternalID() const		{ return InternalID; }
xoTag							GetTag() const				{ return Tag; }
xoDoc*							GetDoc() const				{ return Doc; }
uint32							GetVersion() const			{ return Version; }

//void			CloneFastInto( xoDomEl& c, xoPool* pool, uint cloneFlags ) const;

void			SetInternalID( xoInternalID id )			{ InternalID = id; }	// Used by xoDoc at element creation time.
void			SetDoc( xoDoc* doc )						{ Doc = doc; }			// Used by xoDoc at element creation and destruction time.
void			SetDocRoot()								{ Tag = xoTagBody; }	// Used by xoDoc at initialization time.

protected:
xoDoc*					Doc;			// Owning document
xoInternalID			InternalID;		// Internal 32-bit ID that is used to keep track of an object (memory address is not sufficient)
xoTag					Tag;			// Tag, such <div>, etc
uint32					Version;		// Monotonic integer used to detect modified nodes

void			IncVersion();
void			CloneSlowIntoBase( xoDomEl& c, uint cloneFlags ) const;
};


/* DOM node that is not text
It is vital that this data structure does not grow much bigger than this.
Right now it's 128 bytes on Windows x64.
*/
class XOAPI xoDomNode : public xoDomEl
{
DISALLOW_COPY_AND_ASSIGN(xoDomNode);
public:
xoDomNode( xoDoc* doc, xoTag tag );
virtual ~xoDomNode();

virtual void			SetText( const char* txt ) override;
virtual const char*		GetText() const override;
virtual void			CloneSlowInto( xoDomEl& c, uint cloneFlags ) const override;
virtual void			ForgetChildren() override;

const pvect<xoDomEl*>&			GetChildren() const			{ return Children; }
podvec<xoStyleID>&				GetClassesMutable()			{ IncVersion(); return Classes; }
const podvec<xoStyleID>&		GetClasses() const			{ return Classes; }
const podvec<xoEventHandler>&	GetHandlers() const			{ return Handlers; }
const xoStyle&					GetStyle() const			{ return Style; }

xoDomEl*		AddChild( xoTag tag );
xoDomNode*		AddNode( xoTag tag );
xoDomText*		AddText( const char* txt = nullptr );
void			RemoveChild( xoDomEl* c );
void			RemoveAllChildren();
intp			ChildCount() const { return Children.size(); }
xoDomEl*		ChildByIndex( intp index );
const xoDomEl*	ChildByIndex( intp index ) const;
void			Discard();

// Replace all child elements with the given xml-like string. Returns empty string on success, or error message.
xoString		Parse( const char* src );
xoString		ParseAppend( const char* src );	// Same as Parse, but append to node
xoString		ParseAppend( const xoStringRaw& src );

bool			StyleParse( const char* t, intp maxLen = INT32MAX );
bool			StyleParsef( const char* t, ... );
// This is here for experiments. Future work needs a better performing method for setting just one attribute of the style.
void			HackSetStyle( const xoStyle& style );

// Classes
void			AddClass( const char* klass );
void			RemoveClass( const char* klass );

// Events
void			AddHandler( xoEvents ev, xoEventHandlerF func, void* context = NULL );
void			AddHandler( xoEvents ev, xoEventHandlerLambda lambda );
bool			HandlesEvent( xoEvents ev ) const { return !!(AllEventMask & ev); }

void			OnTouch( xoEventHandlerF func, void* context )				{ AddHandler( xoEventTouch, func, context ); }
void			OnMouseMove( xoEventHandlerF func, void* context )			{ AddHandler( xoEventMouseMove, func, context ); }
void			OnClick( xoEventHandlerF func, void* context )				{ AddHandler( xoEventClick, func, context ); }
void			OnTimer( xoEventHandlerF func, void* context )				{ AddHandler( xoEventTimer, func, context ); }

void			OnTouch( xoEventHandlerLambda lambda )						{ AddHandler( xoEventTouch, lambda ); }
void			OnMouseMove( xoEventHandlerLambda lambda )					{ AddHandler( xoEventMouseMove, lambda ); }
void			OnClick( xoEventHandlerLambda lambda )						{ AddHandler( xoEventClick, lambda ); }
void			OnTimer( xoEventHandlerLambda lambda )						{ AddHandler( xoEventTimer, lambda ); }

protected:
uint32					AllEventMask;
xoStyle					Style;			// Styles that override those referenced by the Tag and the Classes.
podvec<xoEventHandler>	Handlers;
pvect<xoDomEl*>			Children;
podvec<xoStyleID>		Classes;		// Classes of styles

void			RecalcAllEventMask();
void			AddHandler( xoEvents ev, xoEventHandlerF func, bool isLambda, void* context );
};


class XOAPI xoDomText : public xoDomEl
{
DISALLOW_COPY_AND_ASSIGN(xoDomText);
public:
xoDomText( xoDoc* doc, xoTag tag );
virtual ~xoDomText();

virtual void			SetText( const char* txt ) override;
virtual const char*		GetText() const override;
virtual void			CloneSlowInto( xoDomEl& c, uint cloneFlags ) const override;
virtual void			ForgetChildren() override;

protected:
xoString				Text;			// Applicable only to xoTagText elements
};



class XOAPI xoImage : public xoTexture
{
public:
xoImage();
~xoImage();

xoImage*		Clone() const;
void			Free();
void			Set( xoTexFormat format, u32 width, u32 height, const void* bytes );
void			Alloc( xoTexFormat format, u32 width, u32 height );
u32				GetWidth() const	{ return TexWidth; }
u32				GetHeight() const	{ return TexHeight; }
const void*		GetData() const		{ return TexData; }
};



class xoImage;

// TODO: Add some kind of locking mechanism, so that an imagestore can be shared by a mutating UI thread
// and a rendering thread.
class XOAPI xoImageStore
{
public:
static const char*	NullImageName;	// You may not use this name "NULL", because it is reserved for the one-and-only null image

xoImageStore();
~xoImageStore();

void			Set( const char* name, xoImage* img );
xoImage*		Get( const char* name ) const;
xoImage*		GetOrNull( const char* name ) const;
const xoImage*	GetNull() const;	// Get the 'null' image, which is a 2x2 checkerboard

// temp hack. shouldn't be here.
void			CloneFrom( const xoImageStore& src );

protected:
static const int	NullImageIndex = 0;

pvect<xoImage*>				ImageList;
fhashmap<xoString, int>		NameToIndex;

};




/* Document.

Version
-------

Every time an event handler runs, we increment the document version number. This is a conservative
way of detecting any change to the document, without requiring that all document updates go via
some kind of accessor function. Our renderer compares its last version to our current version,
and if the two differ, it knows that it needs to update.

*/
class XOAPI xoDoc
{
DISALLOW_COPY_AND_ASSIGN(xoDoc);
public:
xoDomNode					Root;							// Root element of the document tree
xoStyleTable				ClassStyles;					// All style classes defined in this document
xoStyle						TagStyles[xoTagEND];			// Styles of tags. For example, the style of <p>, or the style of <h1>.
xoStringTable				Strings;						// Generic string table.
xoImageStore				Images;							// All images. Some day we may want to be able to share these amongst different documents.

xoDoc();
~xoDoc();
void			Reset();
void			IncVersion();
uint32			GetVersion()		{ return Version; }									// Renderers use purposefully loose MT semantics on this.
void			ResetModifiedBitmap();													// Reset the 'ismodified' bitmap of all DOM elements.
void			MakeFreeIDsUsable();													// All of our dependent renderers have been updated, we can move FreeIDs over to UsableIDs.
void			CloneSlowInto( xoDoc& c, uint cloneFlags, xoRenderStats& stats ) const;	// Used to make a read-only clone for the renderer. Preserves existing.
//void			CloneFastInto( xoDoc& c, uint cloneFlags, xoRenderStats& stats ) const;	// Used to make a read-only clone for the renderer. Starts from scratch.

// Style Classes
bool			ClassParse( const char* klass, const char* style );		// Set the class, overwriting any previously set style

xoDomEl*		AllocChild( xoTag tag );
void			FreeChild( const xoDomEl* el );

xoString		Parse( const char* src ); // Set the entire document from a single xml-like string. Returns empty string on success, or error message.

void			ChildAdded( xoDomEl* el );
void			ChildAddedFromDocumentClone( xoDomEl* el );
void			ChildRemoved( xoDomEl* el );
void			SetChildModified( xoInternalID id );
intp			ChildByInternalIDListSize() const				{ return ChildByInternalID.size(); }
const xoDomEl**	ChildByInternalIDList() const					{ return (const xoDomEl**) ChildByInternalID.data; }
const xoDomEl*	GetChildByInternalID( xoInternalID id ) const	{ return ChildByInternalID[id]; }						// A NULL result means this child has been deleted
xoDomEl*		GetChildByInternalIDMutable( xoInternalID id )	{ return ChildByInternalID[id]; }

protected:
volatile uint32				Version;
xoPool						Pool;					// Used only when making a clone via CloneFast()
bool						IsReadOnly;				// Read-only clone used for rendering
pvect<xoDomEl*>				ChildByInternalID;
BitMap						ChildIsModified;		// Bit is set if child has been modified since we last synced with the renderer
podvec<xoInternalID>		UsableIDs;				// When we do a render sync, then FreeIDs are moved into UsableIDs
podvec<xoInternalID>		FreeIDs;

void	ResetInternalIDs();
void	InitializeDefaultTagStyles();
};


// The umbrella class that houses a DOM tree.
// This processes UI input.
// It schedules rendering.
// It coordinates between DOM and Render threads.
class XOAPI xoDocGroup
{
DISALLOW_COPY_AND_ASSIGN(xoDocGroup);
public:
xoDoc*				Doc;
xoSysWnd*			Wnd;
xoRenderDoc*		RenderDoc;
bool				DestroyDocWithGroup;

xoRenderStats		RenderStats;

xoDocGroup();
~xoDocGroup();

#if XO_PLATFORM_WIN_DESKTOP
static LRESULT CALLBACK StaticWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
LRESULT WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );
#endif

// These are the only 3 entry points into our content
xoRenderResult	Render();							// This is always called from the Render thread
xoRenderResult	RenderToImage( xoImage& image );	// This is always called from the Render thread
void			ProcessEvent( xoEvent& ev );		// This is always called from the UI thread

bool			IsDocVersionDifferentToRenderer() const;

protected:
AbcCriticalSection	DocLock;		// Mutation of 'Doc', or cloning of 'Doc' for the renderer

xoRenderResult	RenderInternal( xoImage* targetImage );
//void			FindTarget( const xoVec2f& p, pvect<xoRenderDomEl*>& chain );
bool			BubbleEvent( xoEvent& ev );
};



#ifndef FT_FREETYPE_H
typedef void* FT_Face;
typedef void* FT_Library;
#endif

// Once initialized, all members are immutable
class XOAPI xoFont
{
public:
xoFontID	ID;
xoString	Facename;
FT_Face		FTFace;
int32		LinearHoriAdvance_Space_x256;	// How much does character 32 advance?
int32		LineHeight_x256;				// Recommended spacing between consecutive lines
int32		Ascender_x256;					// Ascender
int32		Descender_x256;					// Descender
uint32		MaxAutoHinterSize;				// Maximum font size at which we force use of the auto hinter. Heuristic thumb-suck observations. Only applies to sub-pixel rendering.

xoFont();
~xoFont();
};



class xoTextureAtlas;
class xoFont;

enum xoGlyphFlags
{
xoGlyphFlag_SubPixel_RGB = 1
};

inline bool xoGlyphFlag_IsSubPixel( uint32 flags ) { return !!(flags & xoGlyphFlag_SubPixel_RGB); }

struct xoGlyph
{
uint		AtlasID;
uint		FTGlyphIndex;
uint16		X;
uint16		Y;
uint16		Width;
uint16		Height;
int16		MetricLeft;			// intended for use by SnapSubpixelHorzText
int16		MetricLeftx256;
int16		MetricTop;
int32		MetricHoriAdvance;	// intended for use by SnapSubpixelHorzText
float		MetricLinearHoriAdvance;

// A Null glyph is one that could not be found in the font
bool IsNull() const { return Width == 0 && MetricLinearHoriAdvance == 0; }
void SetNull()		{ memset(this, 0, sizeof(*this)); }
};

struct xoGlyphCacheKey
{
xoFontID	FontID;
uint32		Char;
uint8		Size;
uint8		Flags;

xoGlyphCacheKey() : FontID(0), Char(0), Size(0), Flags(0) {}
xoGlyphCacheKey( xoFontID fid, uint32 ch, uint8 size, uint32 flags ) : FontID(fid), Char(ch), Size(size), Flags(flags) {}

int	GetHashCode() const
{
// Assume we'll have less than 1024 fonts
return (FontID << 22) ^ (Flags << 20) ^ (Size << 10) ^ Char;
}
bool operator==( const xoGlyphCacheKey& b ) const { return FontID == b.FontID && Char == b.Char && Size == b.Size && Flags == b.Flags; }
};
FHASH_SETUP_POD_GETHASHCODE(xoGlyphCacheKey);

static const int xoGlyphAtlasSize = 512; // 512 x 512 x 8bit = 256k per atlas

/* Maintains a cache of all information (including textures) that is needed to render text.
During a render, the cache is read-only. After rendering, we go in and resolve all the cache
misses. On the next render, those glyphs will get rendered.

If a glyph render fails, then the resulting xoGlyph will have .IsNull() == true.
*/
class XOAPI xoGlyphCache
{
public:
xoGlyphCache();
~xoGlyphCache();

void			Clear();
//bool			GetGlyphFromChar( const xoString& facename, int ch, uint8 size, uint8 flags, xoGlyph& glyph );
//bool			GetGlyphFromChar( xoFontID fontID, int ch, uint8 size, uint8 flags, xoGlyph& glyph );

// Returns NULL if the glyph is not in the cache. Even if the glyph pointer is not NULL, you must still check
// whether it is the logical "null glyph", which is empty. You can detect that with xoGlyph.IsNull().
const xoGlyph*		GetGlyph( const xoGlyphCacheKey& key ) const;

uint				RenderGlyph( const xoGlyphCacheKey& key );

const xoTextureAtlas*	GetAtlas( uint i ) const		{ return Atlasses[i]; }
xoTextureAtlas*			GetAtlasMutable( uint i )		{ return Atlasses[i]; }

static const uint					NullGlyphIndex;	// = 0. Our first element in 'Glyphs' is always the null glyph (GCC 4.6 won't allow us to write =0 here)

protected:
pvect<xoTextureAtlas*>				Atlasses;
podvec<xoGlyph>						Glyphs;
fhashmap<xoGlyphCacheKey, uint>		Table;
xoGlyph								NullGlyph;

void	Initialize();
void	FilterAndCopyBitmap( const xoFont* font, void* target, int target_stride );
void	CopyBitmap( const xoFont* font, void* target, int target_stride );
};



// This is used during layout to get an immutable set of fonts that we can access
// without having to take any locks. Once a xoFont object has been created, it is
// never mutated. the Freetype internals are most definitely mutated as we generate
// more glyphs, but the info directly stored inside xoFont is immutable.
// Of particular importance is LinearHoriAdvance_Space_x256, which is used a lot
// during layout.
class XOAPI xoFontTableImmutable
{
public:
xoFontTableImmutable();
~xoFontTableImmutable();

void			Initialize( const pvect<xoFont*>& fonts );
const xoFont*	GetByFontID( xoFontID fontID ) const;

protected:
pvect<xoFont*>	Fonts;
};

/* This stores only font metadata such as filename.

If you're looking for glyphs, they are stored inside xoGlyphCache.

All public members are thread safe.

Members suffixed by "_Internal" assume that the appropriate locks have been acquired.

Once a xoFont* object has been created, it will never be destroyed.
Also, since a xoFont object is immutable once created, we can return
a xoFontStoreTable object and know that the objects inside it are
safe to access from many threads, while we still go ahead on the main
thread and create more fonts.

Although the public API of this class is thread safe, the xoFont* objects returned are
most definitely not thread safe. Freetype stores a lot of glyph rendering state inside
the FT_Face object, so only one thread can use a Freetype face at a time.

*/
class XOAPI xoFontStore
{
public:
xoFontStore();
~xoFontStore();

void					Clear();
void					InitializeFreetype();
void					ShutdownFreetype();
const xoFont*			GetByFontID( xoFontID fontID );
const xoFont*			GetByFacename( const char* facename );
xoFontID				Insert( const xoFont& font );
xoFontID				InsertByFacename( const char* facename );		// This is safe to call if the font is already loaded
xoFontID				GetFallbackFontID();							// This is a font that is always available on this platform. Panics if the font is not available.
xoFontTableImmutable	GetImmutableTable();

void					AddFontDirectory( const char* dir );

private:
AbcCriticalSection				Lock;
pvect<xoFont*>					Fonts;
podvec<xoString>				Directories;
fhashmap<xoString, xoFontID>	FacenameToFontID;
fhashmap<xoString, xoString>	FacenameToFilename;
FT_Library						FTLibrary;
bool							IsFontTableLoaded;

const xoFont*	GetByFacename_Internal( const char* facename ) const;
xoFontID		Insert_Internal( const xoFont& font );
void			LoadFontConstants( xoFont& font );
void			LoadFontTweaks( xoFont& font );
const char*		GetFilenameFromFacename( const char* facename );
void			BuildAndSaveFontTable();
bool			LoadFontTable();
uint64			ComputeFontDirHash();

static bool		IsFontFilename( const char* filename );

};


// Position, UV, Color
struct XOAPI xoVx_PTC
{
// Note that xoRenderGL::DrawQuad assumes that we share our base layout with xoVx_PTCV4
xoVec3f		Pos;
xoVec2f		UV;
uint32		Color;
};

// Position, UV, Color, Vec4
struct XOAPI xoVx_PTCV4
{
// Note that xoRenderGL::DrawQuad assumes that we share our base layout with xoVx_PTC
xoVec3f		Pos;
xoVec2f		UV;
uint32		Color;
xoVec4f		V4;
};

enum xoVertexType
{
xoVertexType_NULL,
xoVertexType_PTC,
xoVertexType_PTCV4,
xoVertexType_END,
};

XOAPI size_t xoVertexSize( xoVertexType t );

#if XO_BUILD_OPENGL


class XOAPI xoGLProg : public xoProgBase
{
public:
GLuint Vert;
GLuint Frag;
GLuint Prog;

xoGLProg();
virtual					~xoGLProg();

// All of these virtual functions are overridden by auto-generated shader objects
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();
virtual uint32			PlatformMask(); 			// Combination of xoPlatformMask bits.
virtual xoVertexType	VertexType();				// Not used on GL

bool					UseOnThisPlatform() { return !!(PlatformMask() & XO_PLATFORM); }

protected:
void					ResetBase();
};

#endif



#if XO_BUILD_DIRECTX

class XOAPI xoDXProg : public xoProgBase
{
public:
ID3D11VertexShader*		Vert;
ID3D11PixelShader*		Frag;
ID3D11InputLayout*      VertLayout;

xoDXProg();
virtual					~xoDXProg();

// All of these virtual functions are overridden by auto-generated shader objects
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();
virtual uint32			PlatformMask(); 			// Combination of xoPlatformMask bits.
virtual xoVertexType	VertexType();

bool					UseOnThisPlatform() { return !!(PlatformMask() & XO_PLATFORM); }

protected:
void					ResetBase();
};

#endif

#if XO_BUILD_OPENGL


class xoGLProg_Curve : public xoGLProg
{
public:
xoGLProg_Curve();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL


class xoGLProg_Fill : public xoGLProg
{
public:
xoGLProg_Fill();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

GLint v_mvproj;           // uniform mat4
GLint v_vpos;             // attribute vec4
GLint v_vcolor;           // attribute vec4
};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL


class xoGLProg_FillTex : public xoGLProg
{
public:
xoGLProg_FillTex();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

GLint v_mvproj;           // uniform mat4
GLint v_vpos;             // attribute vec4
GLint v_vcolor;           // attribute vec4
GLint v_vtexuv0;          // attribute vec2
GLint v_tex0;             // uniform sampler2D
};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL


class xoGLProg_Rect : public xoGLProg
{
public:
xoGLProg_Rect();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

GLint v_mvproj;           // uniform mat4
GLint v_vpos;             // attribute vec4
GLint v_vcolor;           // attribute vec4
GLint v_radius;           // uniform float
GLint v_box;              // uniform vec4
GLint v_border;           // uniform vec4
GLint v_border_color;     // uniform vec4
GLint v_vport_hsize;      // uniform vec2
};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL


class xoGLProg_TextRGB : public xoGLProg
{
public:
xoGLProg_TextRGB();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

GLint v_mvproj;           // uniform mat4
GLint v_vpos;             // attribute vec4
GLint v_vcolor;           // attribute vec4
GLint v_vtexuv0;          // attribute vec2
GLint v_vtexClamp;        // attribute vec4
GLint v_tex0;             // uniform sampler2D
};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL


class xoGLProg_TextWhole : public xoGLProg
{
public:
xoGLProg_TextWhole();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

GLint v_mvproj;           // uniform mat4
GLint v_vpos;             // attribute vec4
GLint v_vcolor;           // attribute vec4
GLint v_vtexuv0;          // attribute vec2
GLint v_tex0;             // uniform sampler2D
};

#endif // XO_BUILD_OPENGL


#if XO_BUILD_DIRECTX


class xoDXProg_Fill : public xoDXProg
{
public:
xoDXProg_Fill();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

};

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX


class xoDXProg_Rect : public xoDXProg
{
public:
xoDXProg_Rect();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

};

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX


class xoDXProg_TextRGB : public xoDXProg
{
public:
xoDXProg_TextRGB();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

};

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX


class xoDXProg_TextWhole : public xoDXProg
{
public:
xoDXProg_TextWhole();
virtual void			Reset();
virtual const char*		VertSrc();
virtual const char*		FragSrc();
virtual const char*		Name();
virtual bool			LoadVariablePositions();	// Performs glGet[Uniform|Attrib]Location for all variables. Returns true if all variables are found.
virtual uint32			PlatformMask();				// Combination of xoPlatform bits.
virtual xoVertexType	VertexType();				// Only meaningful on DirectX

};

#endif // XO_BUILD_DIRECTX




struct xoShaderPerFrame
{
xoMat4f		MVProj;
xoVec2f		VPort_HSize;
float		Padding[2];
};
static_assert( (sizeof(xoShaderPerFrame) & 15) == 0, "xoShaderPerFrame size must be a multiple of 16 bytes (This is a DirectX constant buffer requirement)" );

struct xoShaderPerObject
{
xoVec4f		Box;
xoVec4f		Border;
xoVec4f		BorderColor;
float		Radius;
float		Padding[3];
};
static_assert( (sizeof(xoShaderPerObject) & 15) == 0, "xoShaderPerFrame size must be a multiple of 16 bytes (This is a DirectX constant buffer requirement)" );

/* Base class of device-specific renderer (such as GL or DX).

Texture IDs
-----------
Texture IDs are unsigned 32-bit integers that start at 1 and go up to 2^32-1.
When we "lose" a graphics surface, then we continue to issue texture IDs in the same
sequence that we previously were issuing them. However, during a graphics device
lost event, we record the first ID that is valid. Any IDs lower than that are not
valid. This is not bullet-proof, because you could have some very very old ID
that is not detected as invalid.

For example, say the very first texture you allocate gets assigned ID 1. Then,
a long time goes on, and very many "lost" surface events occur, and eventually
you wrap back around to the start, and you issue texture ID 1 again to a new
caller. The original caller would now believe his old ID 1 is a real texture.
I am hoping that the probability of this occurring is next to zero. Perhaps
a wise thing to do is to force all resource holders to clean up their garbage
at the start of every frame - that would guarantee that such an unlikely
calamity becomes impossible.

*/
class XOAPI xoRenderBase
{
public:
friend struct xoRenderBase_OnceOff;

xoShaderPerFrame		ShaderPerFrame;
xoShaderPerObject		ShaderPerObject;

xoRenderBase();
virtual				~xoRenderBase();

// Setup a matrix equivalent to glOrtho. The matrix 'imat' is multiplied by the ortho matrix.
void				Ortho( xoMat4f &imat, double left, double right, double bottom, double top, double znear, double zfar );

void				SurfaceLost_ForgetTextures();
bool				IsTextureValid( xoTextureID texID ) const;
xoTextureID			FirstTextureID() const								{ return TexIDOffset + TEX_OFFSET_ONE; }

// Register a new texture. There is no "unregister".
xoTextureID			RegisterTexture( void* deviceTexID );
xoTextureID			RegisterTextureInt( uint deviceTexID )				{ return RegisterTexture( reinterpret_cast<void*>(deviceTexID) );  }
void*				GetTextureDeviceHandle( xoTextureID texID ) const;
uint				GetTextureDeviceHandleInt( xoTextureID texID ) const	{ return (uint) reinterpret_cast<uintptr_t>(GetTextureDeviceHandle( texID )); }

virtual const char*	RendererName() = 0;

virtual bool		InitializeDevice( xoSysWnd& wnd ) = 0;	// Initialize this device
virtual void		DestroyDevice( xoSysWnd& wnd ) = 0;		// Destroy this device and all associated textures, etc
virtual void		SurfaceLost() = 0;

virtual bool		BeginRender( xoSysWnd& wnd ) = 0;		// Start of a frame
virtual void		EndRender( xoSysWnd& wnd ) = 0;			// Frame is finished. Present it.

virtual void		PreRender() = 0;
virtual void		PostRenderCleanup() = 0;

virtual xoProgBase* GetShader( xoShaders shader ) = 0;
virtual void		ActivateShader( xoShaders shader ) = 0;

virtual void		DrawQuad( const void* v ) = 0;

virtual bool		LoadTexture( xoTexture* tex, int texUnit ) = 0;
virtual bool		ReadBackbuffer( xoImage& image ) = 0;

protected:
static const xoTextureID	TEX_OFFSET_ONE = 1;	// This constant causes the xoTextureID that we expose to never be zero.
xoTextureID					TexIDOffset;
podvec<void*>				TexIDToNative;		// Maps from xoTextureID to native device texture (eg. GLuint or ID3D11Texture2D*). We're wasting 4 bytes here on OpenGL.

void				EnsureTextureProperlyDefined( xoTexture* tex, int texUnit );
std::string			CommonShaderDefines();
};

// This reduces the amount of #ifdef-ing needed, so that on non-Windows platforms
// we can still have a xoRenderDX class defined.
class XOAPI xoRenderDummy
{
public:
virtual bool		InitializeDevice( xoSysWnd& wnd );
virtual void		DestroyDevice( xoSysWnd& wnd );
virtual void		SurfaceLost();

virtual bool		BeginRender( xoSysWnd& wnd );
virtual void		EndRender( xoSysWnd& wnd );

virtual void		PreRender();
virtual void		PostRenderCleanup();

virtual xoProgBase* GetShader( xoShaders shader );
virtual void		ActivateShader( xoShaders shader );

virtual void		DrawQuad( const void* v );

virtual bool		LoadTexture( xoTexture* tex, int texUnit );
virtual bool		ReadBackbuffer( xoImage& image );
};



class xoRenderStack;

struct XOAPI xoRenderCharEl
{
int		Char;
xoPos	X;
xoPos	Y;
};

// Element that is ready for rendering
class XOAPI xoRenderDomEl
{
public:
xoRenderDomEl( xoInternalID id, xoTag tag );

xoInternalID					InternalID;			// Reference to our original xoDomEl
xoBox							Pos;				// For rectangles, this is the ContentBox. See log entry from 2014-08-02
xoTag							Tag;
};

class XOAPI xoRenderDomNode : public xoRenderDomEl
{
public:
xoRenderDomNode( xoInternalID id = xoInternalIDNull, xoTag tag = xoTagBody, xoPool* pool = NULL );

void		Discard();
void		SetStyle( xoRenderStack& stack );
void		SetPool( xoPool* pool );
xoBox		BorderBox() const;
xoPos		BorderBoxRight() const		{ return Pos.Right + Style.BorderSize.Right; }
xoPos		BorderBoxBottom() const		{ return Pos.Bottom + Style.BorderSize.Bottom; }

xoStyleRender					Style;
xoPoolArray<xoRenderDomEl*>		Children;
};

class XOAPI xoRenderDomText : public xoRenderDomEl
{
public:
enum Flag
{
FlagSubPixelGlyphs = 1,
};
xoRenderDomText( xoInternalID id, xoPool* pool );

void		SetStyle( xoRenderStack& stack );

bool		IsSubPixel() const { return !!(Flags & FlagSubPixelGlyphs); }

xoFontID						FontID;
xoPoolArray<xoRenderCharEl>		Text;
int								Char;
xoColor							Color;
uint8							FontSizePx;
uint8							Flags;
};




/* Document used by renderer.
The 'Doc' member is a complete clone of the original document.
*/
class XOAPI xoRenderDoc
{
public:
// Defining state
xoDoc						Doc;
uint32						WindowWidth, WindowHeight;		// Device pixels

// Rendered state
xoRenderDomNode				RenderRoot;
xoPool						RenderPool;
//podvec<xoInternalID>		ModifiedNodeIDs;

xoRenderDoc();
~xoRenderDoc();

xoRenderResult	Render( xoRenderBase* driver );
void			CopyFromCanonical( const xoDoc& canonical, xoRenderStats& stats );
//xoInternalID	FindElement( xoPoint pos );

protected:
// Cloned data. temp hack for webcam demo
//xoStringTable	ClonedStrings;
xoImageStore	ClonedImages;

void			ResetRenderData();
//xoInternalID	FindElement( const xoRenderDomEl& el, xoPoint pos );
//static void		FindAlteredNodes( const xoDoc* original, const xoDoc* modified, podvec<xoInternalID>& alteredNodeIDs );

};



#if XO_BUILD_DIRECTX


class XOAPI xoRenderDX : public xoRenderBase
{
private:
static const int ConstantSlotPerFrame = 0;
static const int ConstantSlotPerObject = 1;

struct D3DState
{
ID3D11Device*			Device;
ID3D11DeviceContext*	Context;
IDXGISwapChain*			SwapChain;

ID3D11RasterizerState*	Rasterizer;
ID3D11RenderTargetView*	RenderTargetView;
ID3D11BlendState*		BlendNormal;
ID3D11BlendState*		BlendDual;
ID3D11SamplerState*		SamplerLinear;
ID3D11SamplerState*		SamplerPoint;
ID3D11Buffer*           VertBuffer;
ID3D11Buffer*           QuadIndexBuffer;
ID3D11Buffer*           ShaderPerFrameConstants;
ID3D11Buffer*           ShaderPerObjectConstants;

D3D_FEATURE_LEVEL		FeatureLevel;

// our own state that
xoDXProg*				ActiveProgram;
};

public:
xoRenderDX();
virtual				~xoRenderDX();

virtual const char*	RendererName();

virtual bool		InitializeDevice( xoSysWnd& wnd );
virtual void		DestroyDevice( xoSysWnd& wnd );
virtual void		SurfaceLost();

virtual bool		BeginRender( xoSysWnd& wnd );
virtual void		EndRender( xoSysWnd& wnd );

virtual void		PreRender();
virtual void		PostRenderCleanup();

virtual xoProgBase* GetShader( xoShaders shader );
virtual void		ActivateShader( xoShaders shader );

virtual void		DrawQuad( const void* v );

virtual bool		LoadTexture( xoTexture* tex, int texUnit );
virtual bool		ReadBackbuffer( xoImage& image );

private:
struct Texture2D
{
ID3D11Texture2D*			Tex;
ID3D11ShaderResourceView*	View;
};

D3DState				D3D;
int						FBWidth, FBHeight;

xoDXProg_Fill			PFill;
xoDXProg_Rect			PRect;
xoDXProg_TextRGB		PTextRGB;
xoDXProg_TextWhole		PTextWhole;
static const int		NumProgs = 4;
xoDXProg*				AllProgs[NumProgs];

bool				InitializeDXDevice( xoSysWnd& wnd );
bool				InitializeDXSurface( xoSysWnd& wnd );
bool				WindowResized();
bool				CreateShaders();
bool				CreateShader( xoDXProg* prog );
bool				CreateVertexLayout( xoDXProg* prog, ID3DBlob* vsBlob );
bool				CompileShader( const char* name, const char* source, const char* shaderTarget, ID3DBlob** blob );
bool				SetupBuffers();
bool				SetShaderFrameUniforms();
bool				SetShaderObjectUniforms();
ID3D11Buffer*		CreateBuffer( size_t sizeBytes, D3D11_USAGE usage, D3D11_BIND_FLAG bind, uint cpuAccess, const void* initialContent );
bool				CreateTexture2D( xoTexture* tex );
void				UpdateTexture2D( ID3D11Texture2D* dxTex, xoTexture* tex );

xoTextureID			RegisterTextureDX( Texture2D* tex )			{ return RegisterTexture(tex); }
Texture2D*			GetTextureDX( xoTextureID texID ) const		{ return (Texture2D*) GetTextureDeviceHandle(texID); }

};

#else

class XOAPI xoRenderDX : public xoRenderDummy
{
};

#endif



/* An instance of this is created for each render.
Any state that is persisted between renderings is stored in xoRenderGL.
*/
class XOAPI xoRenderer
{
public:
xoRenderResult	Render( xoImageStore* images, xoStringTable* strings, xoRenderBase* driver, xoRenderDomNode* root, int width, int height );

protected:
xoRenderBase*				Driver;
xoImageStore*				Images;
xoStringTable*				Strings;
fhashset<xoGlyphCacheKey>	GlyphsNeeded;

void			RenderEl( xoPoint base, xoRenderDomEl* node );
void			RenderNode( xoPoint base, xoRenderDomNode* node );
void			RenderText( xoPoint base, xoRenderDomText* node );
void			RenderTextChar_WholePixel( xoPoint base, xoRenderDomText* node, const xoRenderCharEl& txtEl );
void			RenderTextChar_SubPixel( xoPoint base, xoRenderDomText* node, const xoRenderCharEl& txtEl );
void			RenderGlyphsNeeded();

bool			LoadTexture( xoTexture* tex, int texUnit );		// Load a texture and reset invalid rectangle

};



class XOAPI xoRenderGL : public xoRenderBase
{
public:
#if XO_PLATFORM_WIN_DESKTOP
HGLRC				GLRC;
HDC					DC;			// Valid between BeginFrame() and EndFrame()
#endif

xoGLProg_Rect		PRect;
xoGLProg_Fill		PFill;
xoGLProg_FillTex	PFillTex;
xoGLProg_TextRGB	PTextRGB;
xoGLProg_TextWhole	PTextWhole;
//xoGLProg_Curve		PCurve;
static const int	NumProgs = 5;
xoGLProg*			AllProgs[NumProgs];	// All of the above programs

xoRenderGL();
~xoRenderGL();

bool			CreateShaders();
void			DeleteShadersAndTextures();
//void			DrawTriangles( int nvert, const void* v, const uint16* indices );

// Implementation of xoRenderBase

virtual const char*	RendererName();

virtual bool		InitializeDevice( xoSysWnd& wnd );
virtual void		DestroyDevice( xoSysWnd& wnd );
virtual void		SurfaceLost();

virtual bool		BeginRender( xoSysWnd& wnd );		// Gets DC and does a MakeCurrent
virtual void		EndRender( xoSysWnd& wnd );			// Releases DC and does a SwapBuffers

virtual void		PreRender();
virtual void		PostRenderCleanup();

virtual void		DrawQuad( const void* v );

virtual xoProgBase* GetShader( xoShaders shader );
virtual void		ActivateShader( xoShaders shader );

virtual bool		LoadTexture( xoTexture* tex, int texUnit );
virtual bool		ReadBackbuffer( xoImage& image );

protected:
xoShaders		ActiveShader;
int				FBWidth, FBHeight;
GLuint			BoundTextures[xoMaxTextureUnits];
//xoPreprocessor	Preprocessor;
std::string		BaseShader;
bool			Have_Unpack_RowLength;
bool			Have_sRGB_Framebuffer;
bool			Have_BlendFuncExtended;

void			PreparePreprocessor();
void			DeleteProgram( xoGLProg& prog );
bool			LoadProgram( xoGLProg& prog );
bool			LoadProgram( xoGLProg& prog, const char* name, const char* vsrc, const char* fsrc );
bool			LoadProgram( GLuint& vshade, GLuint& fshade, GLuint& prog, const char* name, const char* vsrc, const char* fsrc );
bool			LoadShader( GLenum shaderType, GLuint& shader, const char* name, const char* raw_src );
void			SetShaderFrameUniforms();
void			SetShaderObjectUniforms();
void			Check();
void			Reset();
void			CheckExtensions();

template<typename TProg>
bool			SetMVProj( xoShaders shader, TProg& prog, const Mat4f& mvprojTransposed );

};




// A single item on the render stack
class XOAPI xoRenderStackEl
{
public:
xoStyleSet	Styles;
xoPool*		Pool;		// This *could* be stored only inside xoRenderStack.Stack_Pools, but it is convenient to duplicate it here.

void Reset();

// $XO_GCC_ALIGN_BUG.
// WARNING. This is a straight memcpy
xoRenderStackEl& operator=( const xoRenderStackEl& b );
};

/* This is used during layout and rendering.
It is a stack, where the bottom of the stack is the root node, and the
stack follows nodes through the hierarchy up to the current node that
we are processing.

RenderStack has its own pool, which is used for various minor allocations. The bulk of
allocations happen inside the 'Stack_Pools'. Stack_Pools is a list of pools that
is parallel to the stack of RenderStackEl objects. Every object on the stack gets
its own pool, and when that object is popped off the stack, then its pool is
rewound to zero (but its memory is left intact).

The pools inside Stack_Pools have a chunk size of 8 KB. I don't expect resolved
styles to blow that limit often. If they do, then it's simply a performance hit.
*/
class XOAPI xoRenderStack
{
public:
const xoDoc*					Doc;
xoPool*							Pool;
xoStyleAttrib					Defaults[xoCatEND];

xoRenderStack();
~xoRenderStack();

void				Initialize( const xoDoc* doc, xoPool* pool );
void				Reset();
xoStyleAttrib		Get( xoStyleCategories cat ) const;
void				GetBox( xoStyleCategories cat, xoStyleBox& box ) const;

xoStyleBox			GetBox( xoStyleCategories cat ) const { xoStyleBox b; GetBox(cat, b); return b; }

void				StackPop();
xoRenderStackEl&	StackPush();
xoRenderStackEl&	StackBack()			{ return Stack.back(); }
xoRenderStackEl&	StackAt( intp pos )	{ return Stack[pos]; }
intp				StackSize() const	{ return Stack.size(); }

protected:
xoPoolArray<xoRenderStackEl>	Stack;
pvect<xoPool*>					Stack_Pools;	// Every position on the stack gets its own pool
};



class xoRenderStack;

/* This is responsible for producing an exact list of style attributes for every DOM element.

[This whole rambling on parallelizing this was from before the time that I
created the xoRenderStack. The parallelization discussion now belongs at a higher
level than just here]

I'm not sure how best to parallelize this. I suspect there is some well known algorithm
for parallelizing a tree/DAG computation such as this.

A very naive approach would be to simply process a node until you've finished X number
of its children, where X is some arbitrary constant such as 1000. Initially your queue
consists only of the root node. You would in this case limit the depth of each evaluation
to some other arbitrary constant such as 5. Whenever you hit a node that was at a depth
greater than your limit (our hypothetical 5), then you don't process that node, but
instead add it to the queue.

However, it would probably be fast enough to do a first initial pass over the entire tree,
storing the accumulated number of children beneath each node. That would help you decide
which nodes to process in your queue. I'm pretty sure that the ideal queue would consist
initially of the root node, and then a further N nodes only, where N is your number of
threads.

NOTE: All of the protected functions assume that the style busy being resolved is on the top
of the stack. Our only public function "Resolve" adds this blank style to the top of the stack
before passing control to the other functions.
*/
class XOAPI xoStyleResolver
{
public:
// Resolves the given node, and places its style on the top of the stack
static void		ResolveAndPush( xoRenderStack& stack, const xoDomNode* node );

protected:
static void		Set( xoRenderStack& stack, const xoDomEl* node, intp n, const xoStyleAttrib* vals );
static void		Set( xoRenderStack& stack, const xoDomEl* node, const xoStyle& style );
static void		SetInherited( xoRenderStack& stack, const xoDomEl* node, xoStyleCategories cat );
};



// This is brain dead naive. We obviously need a better box packer. The one from freetype-gl looks decent.
class XOAPI xoTextureAtlas : public xoTexture
{
public:
xoTextureAtlas();
~xoTextureAtlas();
void		Initialize( uint width, uint height, xoTexFormat format, uint padding );
void		Zero();
void		Free();
bool		Alloc( uint16 width, uint16 height, uint16& x, uint16& y );

int			GetStride() const					{ return TexStride; }
uint		GetWidth() const					{ return TexWidth; }
uint		GetHeight() const					{ return TexHeight; }

protected:
uint	Padding;

uint	PosTop;
uint	PosBottom;
uint	PosRight;
};



/* A box that has been laid out.
*/
class XOAPI xoLayoutEl
{
public:
xoBox Box;
};

/* This performs box layout.

Inside the class we make some separation between text and non-text layout,
because we will probably end up splitting the text stuff out into a separate
class, due to the fact that it gets complex if you're doing it properly
(ie non-latin fonts, bidirectional, asian, etc).

Hidden things that would bite you if you tried to multithread this:
* We get kerning data from Freetype for each glyph pair, and I'm not sure
that is thread safe.

*/
class XOAPI xoLayout
{
public:

void Layout( const xoDoc& doc, u32 docWidth, u32 docHeight, xoRenderDomNode& root, xoPool* pool );

protected:

struct NodeState
{
// Immutable
xoBox	ParentContentBox;
bool	ParentContentBoxHasWidth;
bool	ParentContentBoxHasHeight;

// Mutable
xoPos	PosMaxX;			// Right-most edge of the current line
xoPos	PosMaxY;			// Bottom of the current line
xoPos	PosX;
xoPos	PosY;
xoPos	PosBaselineY;		// First text element sets this, and it is thereafter fixed until the next line
};

struct Word
{
xoPos	Width;
int32	Start;
int32	End;
int32	Length() const { return End - Start; }
};

struct TextRunState
{
const xoDomText*	Node;
xoRenderDomText*	RNode;
podvec<Word>		Words;
int					GlyphCount;		// Number of non-empty glyphs
bool				GlyphsNeeded;
};

const xoDoc*				Doc;
u32							DocWidth, DocHeight;
xoPool*						Pool;
xoRenderStack				Stack;
float						PtToPixel;
float						EpToPixel;
xoFontTableImmutable		Fonts;
fhashset<xoGlyphCacheKey>	GlyphsNeeded;

TextRunState				TempText;

xoPos	ComputeDimension( xoPos container, bool isContainerDefined, xoStyleCategories cat );
xoPos	ComputeDimension( xoPos container, bool isContainerDefined, xoSize size );
xoBox	ComputeBox( xoBox container, bool widthDefined, bool heightDefined, xoStyleCategories cat );
xoBox	ComputeBox( xoBox container, bool widthDefined, bool heightDefined, xoStyleBox box );
xoBox	ComputeSpecifiedPosition( const NodeState& s );
void	ComputeRelativeOffset( const NodeState& s, xoBox& box );

void	LayoutInternal( xoRenderDomNode& root );
void	RenderGlyphsNeeded();
void	RunNode( NodeState& s, const xoDomNode& node, xoRenderDomNode* rnode );
void	RunText( NodeState& s, const xoDomText& node, xoRenderDomText* rnode );
void	GenerateTextWords( NodeState& s, TextRunState& ts );
void	GenerateTextOutput( NodeState& s, TextRunState& ts );
void	NextLine( NodeState& s );
xoPoint	PositionBlock( NodeState& s, xoBox& marginBox );
void	OffsetRecursive( xoRenderDomNode* rnode, xoPoint offset );

static bool				IsSpace( int ch );
static bool				IsLinebreak( int ch );
static xoGlyphCacheKey	MakeGlyphCacheKey( xoRenderDomText* rnode );

};







/* This performs box layout.

Inside the class we make some separation between text and non-text layout,
because we will probably end up splitting the text stuff out into a separate
class, due to the fact that it gets complex if you're doing it properly
(ie non-latin fonts, bidirectional, asian, etc).

Hidden things that would bite you if you tried to multithread this:
* We get kerning data from Freetype for each glyph pair, and I'm not sure
that is thread safe.

*/
class XOAPI xoLayout2
{
public:
void Layout( const xoDoc& doc, u32 docWidth, u32 docHeight, xoRenderDomNode& root, xoPool* pool );

protected:

// Packed set of bindings between child and parent node
struct BindingSet
{
xoHorizontalBindings	HChild:		8;
xoHorizontalBindings	HParent:	8;
xoVerticalBindings		VChild:		8;
xoVerticalBindings		VParent:	8;
};

struct LayoutInput
{
xoPos	ParentWidth;
xoPos	ParentHeight;
xoPos	OuterBaseline;
};

struct LayoutOutput
{
BindingSet		Binds;
xoPos			NodeWidth;
xoPos			NodeHeight;
xoPos			NodeBaseline;
xoBreakType		Break: 2;		// Keep in mind that you need to mask this off against 3 (ie if (x.Break & 3 == xoBreakAfter)), because of sign extension. ie enums are signed.
//xoPositionType	Position: 3;
xoBreakType		GetBreak() const		{ return xoBreakType(Break & 3); }
//xoPositionType	GetPosition() const		{ return xoPositionType(Position & 7); }
};

// Every time we start a new line, another one of these is created
struct LineBox
{
xoPos		InnerBaseline;
int			InnerBaselineDefinedBy;
int			LastChild;
static LineBox Make( xoPos innerBaseline, int innerBaselineDefinedBy, int lastChild ) { return {innerBaseline, innerBaselineDefinedBy, lastChild}; }
};

struct Word
{
xoPos	Width;
int32	Start;
int32	End;
int32	Length() const { return End - Start; }
};

struct TextRunState
{
const xoDomText*	Node;
xoRenderDomText*	RNode;
podvec<Word>		Words;
int					GlyphCount;		// Number of non-empty glyphs
bool				GlyphsNeeded;
float				FontWidthScale;
};

struct FlowState
{
xoPos	PosMinor;		// In default flow, this is the horizontal (X) position
xoPos	PosMajor;		// In default flow, this is the vertical (Y) position
xoPos	MajorMax;		// In default flow, this is the bottom of the current line
int		NumLines;
// Meh -- implement these when the need arises
// bool	IsVertical;		// default true, normal flow
// bool	ReverseMajor;	// Major goes from high to low numbers (right to left, or bottom to top)
// bool	ReverseMinor;	// Minor goes from high to low numbers (right to left, or bottom to top)
};

const xoDoc*				Doc;
u32							DocWidth, DocHeight;
xoPool*						Pool;
xoRenderStack				Stack;
xoLifoBuf					ChildOutStack;
xoLifoBuf					LineBoxStack;
float						PtToPixel;
float						EpToPixel;
xoFontTableImmutable		Fonts;
fhashset<xoGlyphCacheKey>	GlyphsNeeded;
TextRunState				TempText;
bool						SnapBoxes;
bool						SnapSubpixelHorzText;

void		RenderGlyphsNeeded();
void		LayoutInternal( xoRenderDomNode& root );
void		RunNode( const xoDomNode& node, const LayoutInput& in, LayoutOutput& out, xoRenderDomNode* rnode );
void		RunText( const xoDomText& node, const LayoutInput& in, LayoutOutput& out, xoRenderDomText* rnode );
void		GenerateTextOutput( const LayoutInput& in, LayoutOutput& out, TextRunState& ts );
xoPoint		PositionChildFromBindings( const LayoutInput& cin, const LayoutOutput& cout, xoRenderDomEl* rchild );
void		GenerateTextWords( TextRunState& ts );

xoPos		ComputeDimension( xoPos container, xoStyleCategories cat );
xoPos		ComputeDimension( xoPos container, xoSize size );
xoBox		ComputeBox( xoPos containerWidth, xoPos containerHeight, xoStyleCategories cat );
xoBox		ComputeBox( xoPos containerWidth, xoPos containerHeight, xoStyleBox box );
BindingSet	ComputeBinds();

xoPos		HoriAdvance( const xoGlyph* glyph, const TextRunState& ts );

static xoPos			HBindOffset( xoHorizontalBindings bind, xoPos width );
static xoPos			VBindOffset( xoVerticalBindings bind, xoPos baseline, xoPos height );
static bool				IsSpace( int ch );
static bool				IsLinebreak( int ch );
static xoGlyphCacheKey	MakeGlyphCacheKey( xoRenderDomText* rnode );
static void				FlowNewline( FlowState& flow );
static bool				FlowBreakBefore( const LayoutOutput& cout, FlowState& flow );
static xoPoint			FlowRun( const LayoutInput& cin, const LayoutOutput& cout, FlowState& flow, xoRenderDomEl* rendEl );
static xoPoint			ApplyPosition( const LayoutInput& cin, const LayoutOutput& cout, FlowState& flow, xoRenderDomEl* rendEl );

static bool				IsDefined( xoPos p )	{ return p != xoPosNULL; }
static bool				IsNull( xoPos p )		{ return p == xoPosNULL; }

};







/*
// This does stuff like splitting a text string into words,
// and then words into boxes of an exact length
class xoTextLayout
{
public:
podvec<xoPos>	Boxes;

xoTextLayout();
~xoTextLayout();

void	GenerateBoxes( const xoDomText& node, xoRenderDomText* rnode );	// Output is "Boxes" member variable
};
*/



class xoDomNode;

/* Parse xml-like document format into a DOM node.
This doesn't make any special attempts to be fast.

Example:

<div class='class1 class2' style='font-size: 12px'>
Hello &lt; World!
</div>

The class and style strings can be quoted with single or double quotes.
If you're embedding these strings inside C++ code, it's obviously nicer using single quotes.

The only escaped character sequences are these:
&gt;   >
&lt;   <
&amp;  &

Whitespace:
On either side of a text element, all whitespace, including newlines and carriage returns, is ignored.
In the example above, the text element will be "Hello < World!"
Within a text element, whitespace is not condensed.
Carriage return is always discarded.
Examples:
<div>  some\ntext\n </div>			"some\ntext"
<div>some\ntext</div>				"some\ntext"
<div>some\r\ntext</div>				"some\ntext"
<div>some\n\rtext</div>				"some\ntext"
<div>some   text</div>				"some   text"

*/
class XOAPI xoDocParser
{
public:
xoString Parse( const char* src, xoDomNode* target );

protected:
static bool IsWhite( int c );
static bool IsAlpha( int c );
static bool EqNoCase( const char* a, const char* b, intp bLen );
};


static const int					MAX_WORKER_THREADS = 32;
static volatile uint32				ExitSignalled = 0;
static int							InitializeCount = 0;
static xoStyle*						DefaultTagStyles[xoTagEND];
static AbcThreadHandle				WorkerThreads[MAX_WORKER_THREADS];

#if XO_PLATFORM_WIN_DESKTOP
static AbcThreadHandle				UIThread = NULL;
#endif

// Single globally accessible data
static xoGlobalStruct*				xoGlobals = NULL;

XOAPI size_t xoTexFormatChannelCount( xoTexFormat f )
{
switch ( f )
{
case xoTexFormatInvalid:	return 0;
case xoTexFormatRGBA8:		return 4;
case xoTexFormatGrey8:		return 1;
default:
XOTODO;
return 0;
}
}

XOAPI size_t xoTexFormatBytesPerChannel( xoTexFormat f )
{
switch ( f )
{
case xoTexFormatInvalid:	return 0;
case xoTexFormatRGBA8:		return 1;
case xoTexFormatGrey8:		return 1;
default:
XOTODO;
return 0;
}
}

XOAPI size_t xoTexFormatBytesPerPixel( xoTexFormat f )
{
return xoTexFormatBytesPerChannel( f ) * xoTexFormatChannelCount( f );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void xoTexture::FlipVertical()
{
byte sline[4096];
byte* line = sline;
size_t astride = std::abs(TexStride);
if ( astride > sizeof(sline) )
line = (byte*) AbcMallocOrDie( astride );
for ( uint32 i = 0; i < TexHeight / 2; i++ )
{
memcpy( line, TexDataAtLine(TexHeight - i - 1), astride );
memcpy( TexDataAtLine(TexHeight - i - 1), TexDataAtLine(i), astride );
memcpy( TexDataAtLine(i), line, astride );
}
if ( line != sline )
free( line );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void xoBox::SetInt( int32 left, int32 top, int32 right, int32 bottom )
{
Left = xoRealToPos((float) left);
Top = xoRealToPos((float) top);
Right = xoRealToPos((float) right);
Bottom = xoRealToPos((float) bottom);
}

void xoBox::ExpandToFit( const xoBox& expando )
{
Left = std::min(Left, expando.Left);
Top = std::min(Top, expando.Top);
Right = std::max(Right, expando.Right);
Bottom = std::max(Bottom, expando.Bottom);
}

void xoBox::ClampTo( const xoBox& clamp )
{
Left = std::max(Left, clamp.Left);
Top = std::max(Top, clamp.Top);
Right = std::min(Right, clamp.Right);
Bottom = std::min(Bottom, clamp.Bottom);
}

xoBox xoBox::ShrunkBy( const xoBox& margins )
{
xoBox c = *this;
c.Left += margins.Left;
c.Right -= margins.Right;
c.Top += margins.Top;
c.Bottom -= margins.Bottom;
return c;
}

xoBoxF xoBox::ToRealBox() const
{
xoBoxF f;
f.Left = xoPosToReal( Left );
f.Right = xoPosToReal( Right );
f.Top = xoPosToReal( Top );
f.Bottom = xoPosToReal( Bottom );
return f;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoBoxF xoBox16::ToRealBox() const
{
xoBoxF f;
f.Left = xoPosToReal( Left );
f.Right = xoPosToReal( Right );
f.Top = xoPosToReal( Top );
f.Bottom = xoPosToReal( Bottom );
return f;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoVec4f	xoColor::GetVec4sRGB() const
{
float s = 1.0f / 255.0f;
return xoVec4f( r * s, g * s, b * s, a * s );
}

xoVec4f	xoColor::GetVec4Linear() const
{
float s = 1.0f / 255.0f;
return xoVec4f( xoSRGB2Linear(r),
xoSRGB2Linear(g),
xoSRGB2Linear(b),
a * s );
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static const float sRGB_Low	= 0.0031308f;
static const float sRGB_a	= 0.055f;

XOAPI float	xoSRGB2Linear( uint8 srgb )
{
float g = srgb * (1.0f / 255.0f);
if ( g <= 0.04045 )
return g / 12.92f;
else
return pow( (g + sRGB_a) / (1.0f + sRGB_a), 2.4f );
}

XOAPI uint8	xoLinear2SRGB( float linear )
{
float g;
if ( linear <= sRGB_Low )
g = 12.92f * linear;
else
g = (1.0f + sRGB_a) * pow(linear, 1.0f / 2.4f) - sRGB_a;
return (uint8) xoRound( 255.0f * g );
}

void xoRenderStats::Reset()
{
memset( this, 0, sizeof(*this) );
}

// add or remove documents that are queued for addition or removal
XOAPI void xoProcessDocQueue()
{
xoDocGroup* p = NULL;

while ( p = xoGlobal()->DocRemoveQueue.PopTailR() )
erase_delete( xoGlobal()->Docs, xoGlobal()->Docs.find(p) );

while ( p = xoGlobal()->DocAddQueue.PopTailR() )
xoGlobal()->Docs += p;
}

AbcThreadReturnType AbcKernelCallbackDecl xoWorkerThreadFunc( void* threadContext )
{
while ( true )
{
AbcSemaphoreWait( xoGlobal()->JobQueue.SemaphoreObj(), AbcINFINITE );
if ( ExitSignalled )
break;
xoJob job;
XOVERIFY( xoGlobal()->JobQueue.PopTail( job ) );
job.JobFunc( job.JobData );
}

return 0;
}

#if XO_PLATFORM_WIN_DESKTOP

AbcThreadReturnType AbcKernelCallbackDecl xoUIThread( void* threadContext )
{
while ( true )
{
AbcSemaphoreWait( xoGlobal()->EventQueue.SemaphoreObj(), INFINITE );
if ( ExitSignalled )
break;
xoEvent ev;
XOVERIFY( xoGlobal()->EventQueue.PopTail( ev ) );
ev.DocGroup->ProcessEvent( ev );
}
return 0;
}

static void xoInitialize_Win32()
{
XOVERIFY( AbcThreadCreate( &xoUIThread, NULL, UIThread ) );
}

static void xoShutdown_Win32()
{
if ( UIThread != NULL )
{
xoGlobal()->EventQueue.Add( xoEvent() );
for ( uint waitNum = 0; true; waitNum++ )
{
if ( WaitForSingleObject( UIThread, waitNum ) == WAIT_OBJECT_0 )
break;
}
UIThread = NULL;
}
}


#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XOAPI xoGlobalStruct* xoGlobal()
{
return xoGlobals;
}

static float ComputeEpToPixel()
{
#if XO_PLATFORM_WIN_DESKTOP
float scale = 1;
HDC dc = GetDC( NULL );
if ( dc != NULL )
{
int dpi = GetDeviceCaps( dc, LOGPIXELSX );
scale = (float) dpi / 96.0f;
ReleaseDC( NULL, dc );
}
return scale;
#elif XO_PLATFORM_ANDROID
// xoGlobals->EpToPixel is injected by Java_com_android_xo_NuLib_init after it calls xoInitialize()
return 1;
#elif XO_PLATFORM_LINUX_DESKTOP
// TODO
return 1;
#else
XOTODO_STATIC
#endif
}

static void InitializePlatform()
{
#if XO_PLATFORM_WIN_DESKTOP
SetProcessDPIAware();
#elif XO_PLATFORM_ANDROID
#elif XO_PLATFORM_LINUX_DESKTOP
#else
XOTODO_STATIC;
#endif
}

XOAPI void xoInitialize()
{
InitializeCount++;
if ( InitializeCount != 1 )
return;

InitializePlatform();

AbcMachineInformation minf;
AbcMachineInformationGet( minf );

xoGlobals = new xoGlobalStruct();
xoGlobals->TargetFPS = 60;
xoGlobals->NumWorkerThreads = std::min( minf.LogicalCoreCount, MAX_WORKER_THREADS );
xoGlobals->MaxSubpixelGlyphSize = 60;
xoGlobals->PreferOpenGL = false;
xoGlobals->EnableVSync = false;
// Freetype's output is linear coverage percentage, so if we treat our freetype texture as GL_LUMINANCE
// (and not GL_SLUMINANCE), and we use an sRGB framebuffer, then we get perfect results without
// doing any tweaking to the freetype glyphs.
// Setting SubPixelTextGamma = 2.2 will get results very close to default cleartype on Windows 8.1
// As far as I know, leaving the gamma at 1.0 is "true to the font designer", but this does leave the fonts
// quite a bit heavier than the default on Windows. For this reason, we set the gamma to 1.5. It seems like
// a reasonable blend between the "correct weight" and "prior art".
// CORRECTION. A gamma of anything other than 1.0 looks bad at small font sizes (like 12 or 13 pixels)
// We might want to have a "gamma curve" of pixel size vs gamma.
xoGlobals->SubPixelTextGamma = 1.0f;
xoGlobals->WholePixelTextGamma = 1.0f;
#if XO_PLATFORM_WIN_DESKTOP || XO_PLATFORM_LINUX_DESKTOP
xoGlobals->EnableSubpixelText = true;
xoGlobals->EnableSRGBFramebuffer = true;
//xoGlobals->EmulateGammaBlending = true;
#else
xoGlobals->EnableSubpixelText = false;
xoGlobals->EnableSRGBFramebuffer = false;
//xoGlobals->EmulateGammaBlending = false;
#endif
xoGlobals->EnableKerning = true;
xoGlobals->RoundLineHeights = xoGlobals->EnableSubpixelText;	// happens to be correlated with sub-pixel text, because with sub-pixel, we snap to vertical pixels (but not horz)
xoGlobals->SnapBoxes = true;
xoGlobals->SnapSubpixelHorzText = true;
xoGlobals->EpToPixel = ComputeEpToPixel();
//xoGlobals->DebugZeroClonedChildList = true;
xoGlobals->MaxTextureID = ~((xoTextureID) 0);
//xoGlobals->ClearColor.Set( 200, 0, 200, 255 );  // Make our clear color a very noticeable purple, so you know when you've screwed up the root node
xoGlobals->ClearColor.Set( 255, 150, 255, 255 );  // Make our clear color a very noticeable purple, so you know when you've screwed up the root node
xoGlobals->DocAddQueue.Initialize( false );
xoGlobals->DocRemoveQueue.Initialize( false );
xoGlobals->EventQueue.Initialize( true );
xoGlobals->JobQueue.Initialize( true );
xoGlobals->FontStore = new xoFontStore();
xoGlobals->FontStore->InitializeFreetype();
xoGlobals->GlyphCache = new xoGlyphCache();
xoSysWnd::PlatformInitialize();
#if XO_PLATFORM_WIN_DESKTOP
xoInitialize_Win32();
#endif
XOTRACE( "Using %d/%d processors.\n", (int) xoGlobals->NumWorkerThreads, (int) minf.LogicalCoreCount );
for ( int i = 0; i < xoGlobals->NumWorkerThreads; i++ )
{
XOVERIFY( AbcThreadCreate( xoWorkerThreadFunc, NULL, WorkerThreads[i] ) );
}
}

XOAPI void xoSurfaceLost()
{

}

XOAPI void xoShutdown()
{
XOASSERT(InitializeCount > 0);
InitializeCount--;
if ( InitializeCount != 0 ) return;

AbcInterlockedSet( &ExitSignalled, 1 );

for ( int i = 0; i < xoTagEND; i++ )
delete DefaultTagStyles[i];

// allow documents scheduled for deletion to be deleted
xoProcessDocQueue();

#if XO_PLATFORM_WIN_DESKTOP
xoShutdown_Win32();
#endif

// signal all threads to exit
xoJob nullJob = xoJob();
for ( int i = 0; i < xoGlobal()->NumWorkerThreads; i++ )
xoGlobal()->JobQueue.Add( nullJob );

// wait for each thread in turn
for ( int i = 0; i < xoGlobal()->NumWorkerThreads; i++ )
XOVERIFY( AbcThreadJoin( WorkerThreads[i] ) );

xoGlobals->GlyphCache->Clear();
delete xoGlobals->GlyphCache;
xoGlobals->GlyphCache = NULL;

xoGlobals->FontStore->Clear();
xoGlobals->FontStore->ShutdownFreetype();
delete xoGlobals->FontStore;
xoGlobals->FontStore = NULL;

delete xoGlobals;
}

XOAPI xoStyle** xoDefaultTagStyles()
{
return DefaultTagStyles;
}

XOAPI void xoParseFail( const char* msg, ... )
{
char buff[4096] = "";
va_list va;
va_start( va, msg );
uint r = vsnprintf( buff, arraysize(buff), msg, va );
va_end( va );
if ( r < arraysize(buff) )
XOTRACE_WRITE(buff);
}

XOAPI void XOTRACE( const char* msg, ... )
{
char buff[4096] = "";
va_list va;
va_start( va, msg );
uint r = vsnprintf( buff, arraysize(buff), msg, va );
va_end( va );
if ( r < arraysize(buff) )
XOTRACE_WRITE(buff);
}

XOAPI void NUTIME( const char* msg, ... )
{
const int timeChars = 16;
char buff[4096] = "";
sprintf( buff, "%-15.3f  ", AbcTimeAccurateRTSeconds() * 1000 );
va_list va;
va_start( va, msg );
uint r = vsnprintf( buff + timeChars, arraysize(buff) - timeChars, msg, va );
va_end( va );
if ( r < arraysize(buff) )
XOTRACE_WRITE(buff);
}


XOAPI bool xoEventHandler_LambdaStaticFunc(const xoEvent& ev)
{
xoEventHandlerLambda* lambda = reinterpret_cast<xoEventHandlerLambda*>(ev.Context);
return (*lambda)(ev);
}

xoEvent::xoEvent()
{
DocGroup = NULL;
Context = NULL;
Target = NULL;
Type = xoEventMouseMove;
PointCount = 0;
memset( Points, 0, sizeof(Points) );
}

xoEvent::~xoEvent()
{
}

void xoEvent::MakeWindowSize( int w, int h )
{
Type = xoEventWindowSize;
Points[0].x = (float) w;
Points[0].y = (float) h;
}

xoEventHandler::xoEventHandler()
{
Mask = 0;
Flags = 0;
Context = NULL;
Func = NULL;
}

xoEventHandler::~xoEventHandler()
{
if ( IsLambda() )
delete reinterpret_cast<xoEventHandlerLambda*>(Context);
}


#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 6001)		// using uninitialized memory. False static analysis warning
#endif

xoPool::xoPool()
{
ChunkSize = 64 * 1024;
TopRemain = 0;
}

xoPool::~xoPool()
{
FreeAll();
}

void xoPool::SetChunkSize( size_t size )
{
// If this were not true, then FreeAllExceptOne would be wrong.
// Also, this just seems like sane behaviour (i.e. initializing chunk size a priori).
XOASSERT( Chunks.size() == 0 );
ChunkSize = size;
}

void xoPool::FreeAll()
{
for ( intp i = 0; i < Chunks.size(); i++ )
free(Chunks[i]);
for ( intp i = 0; i < BigBlocks.size(); i++ )
free(BigBlocks[i]);
Chunks.clear();
BigBlocks.clear();
TopRemain = 0;
}

/* This is an optimization for a pool that is frequently re-used.
The pool must have quite a predictable size for this to be effective.
*/
void xoPool::FreeAllExceptOne()
{
if ( Chunks.size() == 1 && BigBlocks.size() == 0 )
TopRemain = ChunkSize;
else
FreeAll();
}

void* xoPool::Alloc( size_t bytes, bool zeroInit )
{
XOASSERT(bytes != 0);
if ( bytes > ChunkSize )
{
BigBlocks += xoMallocOrDie( bytes );
if ( zeroInit ) memset( BigBlocks.back(), 0, bytes );
return BigBlocks.back();
}
else
{
if ( (intp) (TopRemain - bytes) < 0 )
{
Chunks += xoMallocOrDie( ChunkSize );
TopRemain = ChunkSize;
}
byte* p = ((byte*) Chunks.back()) + ChunkSize - TopRemain;
if ( zeroInit ) memset( p, 0, bytes );
TopRemain -= bytes;
return p;
}
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoLifoBuf::xoLifoBuf()
{
Buffer = nullptr;
Size = 0;
Pos = 0;
}

xoLifoBuf::xoLifoBuf( size_t size ) : xoLifoBuf()
{
Init( size );
}

xoLifoBuf::~xoLifoBuf()
{
XOASSERT( Pos == 0 ); // This assertion might be a nuisance. If so, just remove it.
free( Buffer );
}

void xoLifoBuf::Init( size_t size )
{
XOASSERT( Pos == 0 );
Size = size;
free( Buffer );
Buffer = xoMallocOrDie( size );
}

void* xoLifoBuf::Alloc( size_t _bytes )
{
XOASSERT( (size_t) Pos + _bytes <= (size_t) Size );
XOASSERT( (intp) _bytes >= 0 );
intp bytes = _bytes;

void* pos = (byte*) Buffer + Pos;
ItemSizes += bytes;
Pos += bytes;

return pos;
}

void xoLifoBuf::Realloc( void* buf, size_t bytes )
{
XOASSERT( ItemSizes.size() > 0 && buf == (byte*) Buffer + (Pos - ItemSizes.back()) );
XOASSERT( (size_t) Pos - (size_t) ItemSizes.back() + bytes <= (size_t) Size );
XOASSERT( (intp) bytes >= 0 );
intp delta = (intp) bytes - ItemSizes.back();
ItemSizes.back() += delta;
Pos += delta;
}

void xoLifoBuf::GrowLast( size_t moreBytes )
{
XOASSERT( (size_t) Pos + moreBytes <= (size_t) Size );
ItemSizes.back() += (intp) moreBytes;
Pos += (intp) moreBytes;
}

void xoLifoBuf::Free( void* buf )
{
if ( buf == nullptr )
return;
XOASSERT( ItemSizes.size() > 0 && buf == (byte*) Buffer + (Pos - ItemSizes.back()) );
Pos -= ItemSizes.back();
ItemSizes.pop();
}


#if XO_PLATFORM_WIN_DESKTOP

//#define MSGTRACE XOTRACE
#define MSGTRACE(...)

static bool AnyDocsDirty()
{
for ( int i = 0; i < xoGlobal()->Docs.size(); i++ )
{
if ( xoGlobal()->Docs[i]->IsDocVersionDifferentToRenderer() )
return true;
}
return false;
}

XOAPI void xoRunWin32MessageLoop()
{
const double HEAT_TIME = 0.3;
double lastFrameStart = AbcTimeAccurateRTSeconds();
double lastHeatAt = AbcTimeAccurateRTSeconds();

// Toggled when all renderers report that they have no further work to do (ie no animations playing, now or any time in the future)
// In that case, the only way we can have something happen is if we have an incoming message.
// Of course, this is NOT true for IO that is busy occurring on the UI thread.
// We'll have to devise a way (probably just a process-global custom window message) of causing the main loop to wake up.
bool renderIdle = false;

// Trying various things to get latency down to the same level as GDI, but I just can't do it.
//timeBeginPeriod( 5 );

while ( true )
{
// When idle, use GetMessage so that the OS can put us into a good sleep
MSG msg;
bool haveMsg = true;
if ( renderIdle && !AnyDocsDirty() && AbcTimeAccurateRTSeconds() - lastHeatAt > HEAT_TIME )
{
NUTIME("Render cold\n");
MSGTRACE( "Render cold\n" );
if ( !GetMessage( &msg, NULL, 0, 0 ) )
break;
MSGTRACE( "GetMessage returned\n" );
}
else
{
//NUTIME("Render hot\n");
MSGTRACE( "Render hot\n" );
haveMsg = !!PeekMessage( &msg, NULL, 0, 0, PM_REMOVE );
}

if ( haveMsg )
{
MSGTRACE( "msg start: %x\n", msg.message );
if ( msg.message == WM_QUIT )
break;
TranslateMessage( &msg );
DispatchMessage( &msg );
MSGTRACE( "msg end: %x\n", msg.message );
if ( msg.message != WM_TIMER )
lastHeatAt = AbcTimeAccurateRTSeconds();
}

double now = AbcTimeAccurateRTSeconds();
double nextFrameStart = lastFrameStart + 1.0 / xoGlobal()->TargetFPS;
if ( now >= nextFrameStart || AnyDocsDirty() )
{
MSGTRACE( "Render enter\n" );
renderIdle = true;
lastFrameStart = now;
for ( int i = 0; i < xoGlobal()->Docs.size(); i++ )
{
xoRenderResult rr = xoGlobal()->Docs[i]->Render();
if ( rr != xoRenderResultIdle )
renderIdle = false;
}
}
else
{
if ( AbcTimeAccurateRTSeconds() - lastHeatAt > 0.050 )
AbcSleep(5);
else
AbcSleep(0);
}

xoProcessDocQueue();
}

//timeEndPeriod( 5 );
}

#elif XO_PLATFORM_LINUX_DESKTOP

extern xoSysWnd* SingleMainWnd;

XOAPI void xoRunXMessageLoop()
{
xoProcessDocQueue();

while(1)
{
XEvent xev;
XNextEvent( SingleMainWnd->XDisplay, &xev );

if ( xev.type == Expose )
{
XWindowAttributes wa;
XGetWindowAttributes( SingleMainWnd->XDisplay, SingleMainWnd->XWindow, &wa );
/*
glXMakeCurrent( SingleMainWnd->XDisplay, SingleMainWnd->Window, SingleMainWnd->GLContext );
glViewport( 0, 0, gwa.width, gwa.height );
//DrawAQuad();
//glXSwapBuffers(dpy, win);
glXMakeCurrent( SingleMainWnd->XDisplay, None, Null );
*/
xoEvent nev;
nev.Type = xoEventWindowSize;
nev.Points[0].x = wa.width;
nev.Points[0].y = wa.height;
for ( int i = 0; i < xoGlobal()->Docs.size(); i++ )
xoGlobal()->Docs[i]->ProcessEvent( nev );

}
else if ( xev.type == KeyPress )
{
XOTRACE( "key = %d\n", xev.xkey.keycode );
if ( xev.xkey.keycode == 24 ) // 'q'
break;
}
else if ( xev.type == MotionNotify )
{
//XOTRACE( "x,y = %d,%d\n", xev.xmotion.x, xev.xmotion.y );
xoEvent nev;
nev.Type = xoEventMouseMove;
nev.Points[0].x = xev.xmotion.x;
nev.Points[0].y = xev.xmotion.y;
for ( int i = 0; i < xoGlobal()->Docs.size(); i++ )
xoGlobal()->Docs[i]->ProcessEvent( nev );
}

for ( int i = 0; i < xoGlobal()->Docs.size(); i++ )
{
xoRenderResult rr = xoGlobal()->Docs[i]->Render();
//XOTRACE( "rr = %d\n", rr );
//if ( rr != xoRenderResultIdle )
//	renderIdle = false;
}

xoProcessDocQueue();
}
}

#endif


void* xoMallocOrDie( size_t bytes )
{
void* b = malloc( bytes );
XOASSERT(b);
return b;
}

void* xoReallocOrDie( void* buf, size_t bytes )
{
void* b = realloc( buf, bytes );
XOASSERT(b);
return b;
}

xoString xoCacheDir()
{
#if XO_PLATFORM_WIN_DESKTOP
wchar_t* wpath;
std::wstring path;
if ( SUCCEEDED(SHGetKnownFolderPath( FOLDERID_LocalAppData, 0, NULL, &wpath )) )
path = wpath;
path.append( ABC_DIR_SEP_STR_W );
path.append( L"xo" );
CreateDirectoryW( path.c_str(), NULL );
path.append( ABC_DIR_SEP_STR_W );
path.append( L"cache" );
CreateDirectoryW( path.c_str(), NULL );
return ConvertWideToUTF8( path ).c_str();
#elif XO_PLATFORM_LINUX_DESKTOP
struct stat st = {0};
struct passwd *pw = getpwuid(getuid());
xoString path = pw->pw_dir;
path += "/.xo";
if ( stat(path.Z, &st) == -1 )
mkdir(path.Z, 0700);
return path;
#elif XO_PLATFORM_ANDROID
XOTODO_STATIC
#else
XOTODO_STATIC
#endif
}


#define XX(a,b) #a,
#define XY(a) #a,

const char* xoTagNames[xoTagEND + 1] =
{
XO_TAGS_DEFINE
};

#undef XX
#undef XY


intp xoStringRaw::Length() const
{
return Z == nullptr ? 0 : strlen(Z);
}

void xoStringRaw::CloneFastInto( xoStringRaw& b, xoPool* pool ) const
{
auto len = Length();
if ( len != 0 )
{
b.Z = (char*) pool->Alloc( len, false );
memcpy( b.Z, Z, len + 1 );
}
else
{
b.Z = nullptr;
}
}

void xoStringRaw::Discard()
{
Z = nullptr;
}

void xoStringRaw::Alloc( uintp chars )
{
Z = (char*) malloc( chars );
XOASSERT(Z);
}

void xoStringRaw::Free()
{
free(Z);
Z = nullptr;
}

u32 xoStringRaw::GetHashCode() const
{
if ( Z == nullptr )
return 0;
// sdbm.
u32 hash = 0;
for ( uintp i = 0; Z[i] != 0; i++ )
{
// hash(i) = hash(i - 1) * 65539 + str[i]
hash = (u32) Z[i] + (hash << 6) + (hash << 16) - hash;
}
return hash;
}

intp xoStringRaw::Index( const char* find ) const
{
const char* p = strstr( Z, find );
if ( p == nullptr )
return -1;
return p - Z;
}

intp xoStringRaw::RIndex( const char* find ) const
{
intp pos = 0;
intp last = -1;
while ( true )
{
const char* p = strstr( Z + pos, find );
if ( p == nullptr )
return last;
last = p - Z;
pos = last + 1;
}
XOPANIC("supposed to be unreachable");
return last;
}

bool xoStringRaw::operator==( const char* b ) const
{
return *this == Temp(const_cast<char*>(b));
}

bool xoStringRaw::operator==( const xoStringRaw& b ) const
{
if ( Z == nullptr )
{
return b.Z == nullptr || b.Z[0] == 0;
}
if ( b.Z == nullptr )
{
// First case here is already handled
return /* Z == nullptr || */ Z[0] == 0;
}
return strcmp( Z, b.Z ) == 0;
}

bool xoStringRaw::operator<( const xoStringRaw& b ) const
{
if ( Z == nullptr )
{
return b.Z != nullptr && b.Z[0] != 0;
}
if ( b.Z == nullptr )
{
return false;
}
return strcmp( Z, b.Z ) < 0;
}

xoStringRaw xoStringRaw::Temp( char* b )
{
xoStringRaw r;
r.Z = b;
return r;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoString::xoString()
{
Z = nullptr;
}

xoString::xoString( const xoString& b )
{
Z = nullptr;
*this = b;
}

xoString::xoString( const xoStringRaw& b )
{
Z = nullptr;
*this = b;
}

xoString::xoString( const char* z, intp maxLength )
{
Z = nullptr;
Set( z, maxLength );
}

xoString::~xoString()
{
Free();
}

void xoString::Set( const char* z, intp maxLength )
{
intp newLength = 0;
if ( z != nullptr )
newLength = strlen(z);

if ( maxLength >= 0 )
newLength = xoMin( newLength, maxLength );

if ( Length() == newLength )
{
memcpy( Z, z, newLength );
}
else
{
Free();
if ( newLength != 0 )
{
// add a null terminator, always, but don't assume that source has a null terminator
Alloc( newLength + 1 );
memcpy( Z, z, newLength );
Z[newLength] = 0;
}
}
}

void xoString::ReplaceAll( const char* find, const char* replace )
{
size_t findLen = strlen(find);
size_t replaceLen = strlen(replace);
std::string self = Z;
size_t pos = 0;
while ( (pos = self.find( find, pos )) != std::string::npos )
{
self.replace( pos, findLen, replace );
pos += replaceLen;
}
*this = self.c_str();
}

podvec<xoString> xoString::Split( const char* splitter ) const
{
podvec<xoString> v;
intp splitLen = strlen(splitter);
intp pos = 0;
intp len = Length();
while ( true )
{
const char* next = strstr( Z + pos, splitter );
if ( next == nullptr )
{
v += SubStr( pos, len );
break;
}
else
{
v += SubStr( pos, next - Z );
pos = next - Z + splitLen;
}
}
return v;
}

xoString xoString::SubStr( intp start, intp end ) const
{
auto len = Length();
start = xoClamp<intp>( start, 0, len );
end = xoClamp<intp>( end, 0, len );
xoString s;
s.Set( Z + start, end - start );
return s;
}

xoString& xoString::operator=( const xoString& b )
{
Set( b.Z );
return *this;
}

xoString& xoString::operator=( const xoStringRaw& b )
{
Set( b.Z );
return *this;
}

xoString& xoString::operator=( const char* b )
{
Set( b );
return *this;
}

xoString& xoString::operator+=( const xoStringRaw& b )
{
intp len1 = Length();
intp len2 = b.Length();
char* newZ = (char*) malloc( len1 + len2 + 1 );
XOASSERT(newZ);
memcpy( newZ, Z, len1 );
memcpy( newZ + len1, b.Z, len2 );
newZ[len1 + len2] = 0;
free( Z );
Z = newZ;
return *this;
}

xoString& xoString::operator+=( const char* b )
{
*this += xoTempString(b);
return *this;
}

xoString xoString::Join( const podvec<xoString>& parts, const char* joiner )
{
xoString r;
if ( parts.size() != 0 )
{
intp jlen = joiner == nullptr ? 0 : (intp) strlen(joiner);
intp total = 0;
for ( intp i = 0; i < parts.size(); i++ )
total += parts[i].Length() + jlen;
r.Alloc( total + 1 );

intp rpos = 0;
for ( intp i = 0; i < parts.size(); i++ )
{
const char* part = parts[i].Z;
if ( part != nullptr )
{
for ( intp j = 0; part[j]; j++, rpos++ )
r.Z[rpos] = part[j];
}
if ( i != parts.size() - 1 )
{
for ( intp j = 0; j < jlen; j++, rpos++ )
r.Z[rpos] = joiner[j];
}
}
r.Z[rpos] = 0;
}
return r;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XOAPI xoString operator+( const char* a, const xoStringRaw& b )
{
xoString r = a;
r += b;
return r;
}

XOAPI xoString operator+( const xoStringRaw& a, const char* b )
{
xoString r = a;
r += b;
return r;
}

XOAPI xoString operator+( const xoStringRaw& a, const xoStringRaw& b )
{
xoString r = a;
r += b.Z;
return r;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoTempString::xoTempString( const char* z )
{
Z = const_cast<char*>(z);
}

xoTempString::~xoTempString()
{
Z = nullptr;
}


xoStringTable::xoStringTable()
{
IdToName += "";
NameToId.insert( IdToName[0], 0 );
}

xoStringTable::~xoStringTable()
{
}

const char* xoStringTable::GetStr( int id ) const
{
if ( (uint32) id >= (uint32) IdToName.size() )
return "";
return IdToName[id];
}

int xoStringTable::GetId( const char* str )
{
XOASSERT( str != nullptr );
xoTempString s(str);
int v = 0;
if ( NameToId.get( s, v ) )
return v;
intp len = s.Length();
char* copy = (char*) Pool.Alloc( len + 1, false );
memcpy( copy, str, len );
copy[len] = 0;
IdToName += copy;
NameToId.insert( s, (int) IdToName.size() - 1 );
return (int) IdToName.size() - 1;
}

void xoStringTable::CloneFrom_Incremental( const xoStringTable& src )
{
for ( intp i = IdToName.size(); i < src.IdToName.size(); i++ )
{
int id = GetId( src.IdToName[i] );
XOASSERT( id == i );
}
}


#define EQ(a,b) (strcmp(a,b) == 0)

// Styles that are inherited by default
const xoStyleCategories xoInheritedStyleCategories[xoNumInheritedStyleCategories] = {
xoCatFontFamily,
xoCatFontSize,
xoCatColor,
xoCatText_Align_Vertical,
};

inline bool IsNumeric( char c )
{
return (c >= '0' && c <= '9') || (c == '.') || (c == '-');
}

// This is parsing whitespace, not DOM/textual whitespace
// In other words, it is the space between the comma and verdana in "font-family: verdana, arial",
inline bool IsWhitespace( char c )
{
return c == 32 || c == 9;
}

static bool MATCH( const char* s, intp start, intp end, const char* truth )
{
for ( ; start != end; truth++, start++ )
{
if ( s[start] != *truth ) return false;
}
return true;
}

static uint8 ParseHexChar( char ch )
{
if ( ch >= 'A' && ch <= 'F' )	return 10 + ch - 'A';
if ( ch >= 'a' && ch <= 'f' )	return 10 + ch - 'a';
else							return ch - '0';
}

static uint8 ParseHexCharPair( const char* ch )
{
return (ParseHexChar( ch[0] ) << 4) | ParseHexChar( ch[1] );
}

static uint8 ParseHexCharSingle( const char* ch )
{
uint8 v = ParseHexChar( ch[0] );
return (v << 4) | v;
}

static int FindSpaces( const char* s, intp len, int (&spaces)[10] )
{
int nspaces = 0;
for ( intp i = 0; i < len && nspaces < arraysize(spaces); i++ )
{
if ( IsWhitespace(s[i]) )
spaces[nspaces++] = (int) i;
}
return nspaces;
}

bool xoSize::Parse( const char* s, intp len, xoSize& v )
{
// 1.23px
// 1.23ep
// 1.23pt
// 1.23%
// 0
char digits[100];
if ( len > 30 )
{
xoParseFail( "Parse failed, size too big (>30 characters)\n" );
return false;
}
xoSize x = xoSize::Pixels(0);
intp nondig = 0;
for ( ; nondig < len; nondig++ )
{
digits[nondig] = s[nondig];
if ( !IsNumeric(s[nondig]) )
break;
}
digits[nondig] = 0;
x.Val = (float) atof( digits );
if ( nondig == len )
{
if ( len == 1 && s[0] == '0' )
{
// ok
}
else
{
xoParseFail( "Parse failed, invalid size: %.*s\n", (int) len, s );
return false;
}
}
else
{
if ( s[nondig] == '%' )
{
x.Type = xoSize::PERCENT;
}
else if ( s[nondig] == 'p' && len - nondig >= 2 )
{
if (		s[nondig + 1] == 'x' ) x.Type = xoSize::PX;
else if (	s[nondig + 1] == 't' ) x.Type = xoSize::PT;
else
{
xoParseFail( "Parse failed, invalid size: %.*s\n", (int) len, s );
return false;
}
}
else if ( s[nondig] == 'e' && len - nondig >= 2 && s[nondig + 1] == 'p' )
{
x.Type = xoSize::EP;
}
}
v = x;
return true;
}

bool xoStyleBox::Parse( const char* s, intp len, xoStyleBox& v )
{
int spaces[10];
int nspaces = FindSpaces( s, len, spaces );

// 20px
// 1px 2px 3px 4px (TODO)
xoStyleBox b;
if ( nspaces == 0 )
{
xoSize one;
if ( xoSize::Parse( s, len, one ) )
{
b.Left = b.Top = b.Bottom = b.Right = one;
v = b;
return true;
}
}

// 1px 2px 3px 4px
if ( nspaces == 3 )
{
bool ok1 = xoSize::Parse( s, spaces[0], b.Left );
bool ok2 = xoSize::Parse( s + spaces[0] + 1, spaces[1] - spaces[0] - 1, b.Top );
bool ok3 = xoSize::Parse( s + spaces[1] + 1, spaces[2] - spaces[1] - 1, b.Right );
bool ok4 = xoSize::Parse( s + spaces[2] + 1, (int) len - spaces[2] - 1, b.Bottom );
if ( ok1 && ok2 && ok3 && ok4 )
{
v = b;
return true;
}
}
return false;
}

bool xoColor::Parse( const char* s, intp len, xoColor& v )
{
xoColor c = xoColor::RGBA(0,0,0,0);
s++;
// #rgb
// #rgba
// #rrggbb
// #rrggbbaa
if ( len == 4 )
{
c.r = ParseHexCharSingle( s + 0 );
c.g = ParseHexCharSingle( s + 1 );
c.b = ParseHexCharSingle( s + 2 );
c.a = 255;
//XOTRACE( "color %s -> %d\n", s, (int) c.r );
}
else if ( len == 5 )
{
c.r = ParseHexCharSingle( s + 0 );
c.g = ParseHexCharSingle( s + 1 );
c.b = ParseHexCharSingle( s + 2 );
c.a = ParseHexCharSingle( s + 3 );
}
else if ( len == 7 )
{
c.r = ParseHexCharPair( s + 0 );
c.g = ParseHexCharPair( s + 2 );
c.b = ParseHexCharPair( s + 4 );
c.a = 255;
}
else if ( len == 9 )
{
c.r = ParseHexCharPair( s + 0 );
c.g = ParseHexCharPair( s + 2 );
c.b = ParseHexCharPair( s + 4 );
c.a = ParseHexCharPair( s + 6 );
}
else
{
xoParseFail( "Parse failed, invalid color %.*s\n", (int) len, s );
return false;
}
v = c;
return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoStyleAttrib::xoStyleAttrib()
{
memset( this, 0, sizeof(*this) );
}

void xoStyleAttrib::SetU32( xoStyleCategories cat, uint32 val )
{
Category = cat;
ValU32 = val;
}

void xoStyleAttrib::SetWithSubtypeU32( xoStyleCategories cat, uint8 subtype, uint32 val )
{
Category = cat;
SubType = subtype;
ValU32 = val;
}

void xoStyleAttrib::SetWithSubtypeF( xoStyleCategories cat, uint8 subtype, float val )
{
Category = cat;
SubType = subtype;
ValF = val;
}

void xoStyleAttrib::SetString( xoStyleCategories cat, const char* str, xoDoc* doc )
{
Category = cat;
ValU32 = doc->Strings.GetId( str );
}

void xoStyleAttrib::SetInherit( xoStyleCategories cat )
{
Category = cat;
Flags = FlagInherit;
}

const char* xoStyleAttrib::GetBackgroundImage( xoStringTable* strings ) const
{
return strings->GetStr( ValU32 );
}

xoFontID xoStyleAttrib::GetFont() const
{
return ValU32;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename T>
static bool ParseSingleAttrib( const char* s, intp len, bool (*parseFunc)(const char* s, intp len, T& t), xoStyleCategories cat, xoStyle& style )
{
T val;
if ( parseFunc( s, len, val ) )
{
xoStyleAttrib attrib;
attrib.Set( cat, val );
style.Set( attrib );
return true;
}
else
{
xoParseFail( "Parse failed, unknown value: '%.*s'\n", (int) len, s );
return false;
}
}

// This was added when font-family was stored as a string, but it is now stored as a xoFontID
static void ParseString( const char* s, intp len, xoStyleCategories cat, xoDoc* doc, xoStyle& style )
{
char stat[64];
xoStyleAttrib attrib;
if ( len < sizeof(stat) )
{
memcpy( stat, s, len );
stat[len] = 0;
attrib.Set( cat, stat, doc );
}
else
{
xoString copy;
copy.Set( s, len );
attrib.Set( cat, copy.Z, doc );
}
style.Set( attrib );
}

template<typename T>
static bool ParseCompound( const char* s, intp len, bool (*parseFunc)(const char* s, intp len, T& t), xoStyleCategories cat, xoStyle& style )
{
T val;
if ( parseFunc( s, len, val ) )
{
style.Set( cat, val );
return true;
}
else
{
xoParseFail( "Parse failed, unknown value: '%.*s'\n", (int) len, s );
return false;
}
}

static bool ParseDirect( const char* s, intp len, bool (*parseFunc)(const char* s, intp len, xoStyle& style), xoStyle& style )
{
if ( parseFunc( s, len, style ) )
{
return true;
}
else
{
xoParseFail( "Parse failed on: '%.*s'\n", (int) len, s );
return false;
}
}

static bool ParseFontFamily( const char* s, intp len, xoFontID& v )
{
bool onFont = false;
char buf[64];
intp bufPos = 0;
for ( intp i = 0; true; i++ )
{
if ( onFont )
{
if ( s[i] == ',' || i == len )
{
buf[bufPos] = 0;
v = xoGlobal()->FontStore->InsertByFacename( buf );
if ( v != xoFontIDNull )
return true;
onFont = false;
bufPos = 0;
}
else
{
buf[bufPos++] = s[i];
}
if ( i == len )
break;
}
else
{
if ( i == len )
break;
if ( IsWhitespace(s[i]) )
continue;
onFont = true;
buf[bufPos++] = s[i];
}
if ( bufPos >= arraysize(buf) )
{
xoParseFail( "Parse failed, font name too long (>63): '%*.s'\n", (int) len, s );
return false;
}
}
// not sure whether we should do this. One might want no font to be set instead.
v = xoGlobal()->FontStore->GetFallbackFontID();
return true;
}

bool xoStyle::Parse( const char* t, xoDoc* doc )
{
return Parse( t, INT32MAX, doc );
}

bool xoStyle::Parse( const char* t, intp maxLen, xoDoc* doc )
{
// "background: #8f8; width: 100%; height: 100%;"
#define TSTART	(t + startv)
#define TLEN	(i - startv)
intp startk = -1;
intp eq = -1;
intp startv = -1;
int nerror = 0;
for ( intp i = 0; true; i++ )
{
bool eof = t[i] == 0 || i == maxLen;
if ( t[i] == 32 ) {}
else if ( t[i] == ':' ) eq = i;
else if ( t[i] == ';' || (eof && startv != -1) )
{
bool ok = true;
if ( MATCH(t, startk, eq, "background") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoColor::Parse, xoCatBackground, *this ); }
else if ( MATCH(t, startk, eq, "color") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoColor::Parse, xoCatColor, *this ); }
else if ( MATCH(t, startk, eq, "width") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatWidth, *this ); }
else if ( MATCH(t, startk, eq, "height") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatHeight, *this ); }
else if ( MATCH(t, startk, eq, "padding") )						{ ok = ParseCompound( TSTART, TLEN, &xoStyleBox::Parse, xoCatPadding_Left, *this ); }
else if ( MATCH(t, startk, eq, "margin") )						{ ok = ParseCompound( TSTART, TLEN, &xoStyleBox::Parse, xoCatMargin_Left, *this ); }
else if ( MATCH(t, startk, eq, "display") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseDisplayType, xoCatDisplay, *this ); }
else if ( MATCH(t, startk, eq, "position") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParsePositionType, xoCatPosition, *this ); }
else if ( MATCH(t, startk, eq, "border") )						{ ok = ParseDirect( TSTART, TLEN, &xoParseBorder, *this ); }
else if ( MATCH(t, startk, eq, "border-radius") )				{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatBorderRadius, *this ); }
//else if ( MATCH(t, startk, eq, "left") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatLeft, *this ); }
//else if ( MATCH(t, startk, eq, "right") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatRight, *this ); }
//else if ( MATCH(t, startk, eq, "top") )							{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatTop, *this ); }
//else if ( MATCH(t, startk, eq, "bottom") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatBottom, *this ); }
else if ( MATCH(t, startk, eq, "break") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseBreakType, xoCatBreak, *this ); }
else if ( MATCH(t, startk, eq, "flow-axis") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseFlowAxis, xoCatFlow_Axis, *this ); }
else if ( MATCH(t, startk, eq, "flow-direction-horizontal") )	{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseFlowDirection, xoCatFlow_Direction_Horizontal, *this ); }
else if ( MATCH(t, startk, eq, "flow-direction-vertical") )		{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseFlowDirection, xoCatFlow_Direction_Vertical, *this ); }
else if ( MATCH(t, startk, eq, "box-sizing") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseBoxSize, xoCatBoxSizing, *this ); }
else if ( MATCH(t, startk, eq, "font-size") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &xoSize::Parse, xoCatFontSize, *this ); }
else if ( MATCH(t, startk, eq, "font-family") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &ParseFontFamily, xoCatFontFamily, *this ); }
else if ( MATCH(t, startk, eq, "text-align-vertical") )			{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseTextAlignVertical, xoCatText_Align_Vertical, *this ); }
else if ( MATCH(t, startk, eq, "left") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseHorizontalBinding, xoCatLeft, *this ); }
else if ( MATCH(t, startk, eq, "hcenter") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseHorizontalBinding, xoCatHCenter, *this ); }
else if ( MATCH(t, startk, eq, "right") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseHorizontalBinding, xoCatRight, *this ); }
else if ( MATCH(t, startk, eq, "top") )							{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseVerticalBinding, xoCatTop, *this ); }
else if ( MATCH(t, startk, eq, "vcenter") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseVerticalBinding, xoCatVCenter, *this ); }
else if ( MATCH(t, startk, eq, "bottom") )						{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseVerticalBinding, xoCatBottom, *this ); }
else if ( MATCH(t, startk, eq, "baseline") )					{ ok = ParseSingleAttrib( TSTART, TLEN, &xoParseVerticalBinding, xoCatBaseline, *this ); }
else
{
ok = false;
xoParseFail( "Parse failed - unknown property: '%.*s'\n", int(eq - startk), t + startk );
}
if ( !ok )
nerror++;
eq = -1;
startk = -1;
startv = -1;
}
else
{
if ( startk == -1 )						startk = i;
else if ( startv == -1 && eq != -1 )	startv = i;
}

if ( eof ) break;
}
return nerror == 0;
#undef TSTART
#undef TLEN
}

const xoStyleAttrib* xoStyle::Get( xoStyleCategories cat ) const
{
for ( intp i = 0; i < Attribs.size(); i++ )
{
if ( Attribs[i].Category == cat ) return &Attribs[i];
}
return NULL;
}

void xoStyle::GetBox( xoStyleCategories cat, xoStyleBox& box ) const
{
xoStyleCategories base = xoCatMakeBaseBox(cat);
for ( intp i = 0; i < Attribs.size(); i++ )
{
uint pindex = uint(Attribs[i].Category - base);
if ( pindex < 4 )
box.All[pindex] = Attribs[i].GetSize();
}
}

void xoStyle::SetBox( xoStyleCategories cat, xoStyleBox val )
{
if ( cat >= xoCatMargin_Left && cat <= xoCatBorder_Bottom )
{
SetBoxInternal( xoCatMakeBaseBox(cat), val );
}
else XOASSERT(false);
}

void xoStyle::SetUniformBox( xoStyleCategories cat, xoStyleAttrib val )
{
cat = xoCatMakeBaseBox(cat);
val.Category = (xoStyleCategories) (cat + 0);	Set( val );
val.Category = (xoStyleCategories) (cat + 1);	Set( val );
val.Category = (xoStyleCategories) (cat + 2);	Set( val );
val.Category = (xoStyleCategories) (cat + 3);	Set( val );
}

void xoStyle::SetUniformBox( xoStyleCategories cat, xoColor color )
{
xoStyleAttrib val;
val.SetColor( cat, color );
SetUniformBox( cat, val );
}

void xoStyle::SetUniformBox( xoStyleCategories cat, xoSize size )
{
xoStyleAttrib val;
val.SetSize( cat, size );
SetUniformBox( cat, val );
}

void xoStyle::SetBoxInternal( xoStyleCategories catBase, xoStyleBox val )
{
xoStyleAttrib a;
a.SetSize( (xoStyleCategories) (catBase + 0), val.Left );	Set( a );
a.SetSize( (xoStyleCategories) (catBase + 1), val.Top );	Set( a );
a.SetSize( (xoStyleCategories) (catBase + 2), val.Right );	Set( a );
a.SetSize( (xoStyleCategories) (catBase + 3), val.Bottom );	Set( a );
}

void xoStyle::Set( xoStyleAttrib attrib )
{
for ( intp i = 0; i < Attribs.size(); i++ )
{
if ( Attribs[i].Category == attrib.Category )
{
Attribs[i] = attrib;
return;
}
}
Attribs += attrib;
}

void xoStyle::Set( xoStyleCategories cat, xoStyleBox val )
{
SetBox( cat, val );
}

/*
void xoStyle::MergeInZeroCopy( int n, const xoStyle** src )
{
if ( n == 0 ) return;

// Use a lookup table to avoid making this merge operation O(n*m).
// If the list of attributes balloons, then we should probably use something like a two level tree here.
// This table is:
// Category > Attrib Index
u8 lut[xoCatEND];
static const u8 EMPTY = 255;
memset( lut, EMPTY, sizeof(lut) );
static_assert( xoCatEND < EMPTY, "xoCat__ fits in a byte" );

int isrc = 0;
if ( Attribs.size() == 0 )
{
// optimization for the case where we're initially empty
auto& s = src[0]->Attribs;
for ( intp i = 0; i < s.size(); i++ )
{
lut[s[i].Category] = (u8) i;
Attribs += s[i];
}
isrc = 1;
}

// Apply each xoStyle in turn. Later xoStyles override earlier ones.
for ( ; isrc < n; isrc++ )
{
auto& s = src[isrc]->Attribs;

for ( intp i = 0; i < s.size(); i++ )
{
u8 existing = lut[s[i].Category];
if ( existing == EMPTY )
{
// new category
lut[s[i].Category] = (u8) Attribs.size();
Attribs += s[i];
}
else
{
// overwrite existing category
Attribs[existing] = s[i];
}
}
}
}
*/

void xoStyle::Discard()
{
Attribs.clear_noalloc();
//Name.Discard();
}

void xoStyle::CloneSlowInto( xoStyle& c ) const
{
c.Attribs = Attribs;
}

void xoStyle::CloneFastInto( xoStyle& c, xoPool* pool ) const
{
//Name.CloneFastInto( c.Name, pool );
xoClonePodvecWithMemCopy( c.Attribs, Attribs, pool );
}

#define XX(name, type, setfunc, cat) \
void xoStyle::Set##name( type value ) \
{ \
xoStyleAttrib a; \
a.setfunc( cat, value ); \
Set( a ); \
}
NUSTYLE_SETTERS_2P
#undef XX

#define XX(name, type, setfunc) \
void xoStyle::Set##name( type value ) \
{ \
xoStyleAttrib a; \
a.setfunc( value ); \
Set( a ); \
}
NUSTYLE_SETTERS_1P
#undef XX

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoStyleSet::xoStyleSet()
{
Reset();
}

xoStyleSet::~xoStyleSet()
{
}

void xoStyleSet::Reset()
{
Lookup = NULL;
Attribs = NULL;
Count = 0;
Capacity = 0;
BitsPerSlot = 0;
SetSlotF = NULL;
GetSlotF = NULL;
}

void xoStyleSet::Grow( xoPool* pool )
{
XOASSERT( BitsPerSlot != 8 );
uint32 newbits = BitsPerSlot == 0 ? InitialBitsPerSlot : BitsPerSlot * 2;
uint32 totalBits = newbits * xoCatEND;
void*			newlookup = pool->Alloc( (totalBits + 7) / 8, true );
xoStyleAttrib*	newattribs = pool->AllocNT<xoStyleAttrib>( CapacityAt(newbits), false );
if ( BitsPerSlot )
{
if ( newbits == 4 )			MigrateLookup( Lookup, newlookup, &GetSlot2, &SetSlot4 );
else if ( newbits == 8 )	MigrateLookup( Lookup, newlookup, &GetSlot4, &SetSlot8 );

memcpy( newattribs, Attribs, CapacityAt(BitsPerSlot) * sizeof(xoStyleAttrib) );
}
Capacity = CapacityAt(newbits);
Lookup = newlookup;
Attribs = newattribs;
BitsPerSlot = newbits;
if ( newbits == 2 )			{ SetSlotF = &SetSlot2; GetSlotF = &GetSlot2; }
else if ( newbits == 4 )	{ SetSlotF = &SetSlot4; GetSlotF = &GetSlot4; }
else if ( newbits == 8 )	{ SetSlotF = &SetSlot8; GetSlotF = &GetSlot8; }
}

void xoStyleSet::Set( int n, const xoStyleAttrib* attribs, xoPool* pool )
{
for ( int i = 0; i < n; i++ )
Set( attribs[i], pool );
}

void xoStyleSet::Set( const xoStyleAttrib& attrib, xoPool* pool )
{
if ( attrib.Category == xoCatFontSize )
int abc = 123;
int32 slot = GetSlot( attrib.GetCategory() );
if ( slot != 0 )
{
Attribs[slot - 1] = attrib;
return;
}
if ( Count >= Capacity )
Grow( pool );
Attribs[Count] = attrib;
SetSlot( attrib.GetCategory(), Count + SlotOffset );
Count++;
//DebugCheckSanity();
}

xoStyleAttrib xoStyleSet::Get( xoStyleCategories cat ) const
{
int32 slot = GetSlot( cat ) - SlotOffset;
if ( slot == -1 )
return xoStyleAttrib();
return Attribs[slot];
}

void xoStyleSet::DebugCheckSanity() const
{
for ( int i = xoCatFIRST; i < xoCatEND; i++ )
{
xoStyleCategories cat = (xoStyleCategories) i;
xoStyleAttrib val = Get( cat );
XOASSERTDEBUG( val.IsNull() || val.Category == cat );
}
}

bool xoStyleSet::Contains( xoStyleCategories cat ) const
{
return GetSlot( cat ) != 0;
}

void xoStyleSet::MigrateLookup( const void* lutsrc, void* lutdst, GetSlotFunc getter, SetSlotFunc setter )
{
for ( int i = xoCatFIRST; i < xoCatEND; i++ )
{
int32 slot = getter( lutsrc, (xoStyleCategories) i );
if ( slot != 0 )
setter( lutdst, (xoStyleCategories) i, slot );
}
}

int32 xoStyleSet::GetSlot( xoStyleCategories cat ) const
{
if ( !GetSlotF ) return 0;
return GetSlotF( Lookup, cat );
}

void xoStyleSet::SetSlot( xoStyleCategories cat, int32 slot )
{
SetSlotF( Lookup, cat, slot );
}

template<uint32 BITS_PER_SLOT>
void xoStyleSet::TSetSlot( void* lookup, xoStyleCategories cat, int32 slot )
{
const uint32	mask	= (1 << BITS_PER_SLOT) - 1;
uint8*			lookup8	= (uint8*) lookup;

if ( BITS_PER_SLOT == 8 )
{
lookup8[cat] = slot;
}
else
{
uint32	intra_byte_mask;
uint32	ibyte;
if ( BITS_PER_SLOT == 2 )		{ ibyte = ((uint32) cat) >> 2;	intra_byte_mask = 3; }
else if ( BITS_PER_SLOT == 4 )	{ ibyte = ((uint32) cat) >> 1;	intra_byte_mask = 1; }

uint8	v = lookup8[ibyte];
uint8	islotinbyte = ((uint32) cat) & intra_byte_mask;
uint8	ishift = islotinbyte * BITS_PER_SLOT;
uint8	shiftedmask = mask << ishift;
v = v & ~shiftedmask;
v = v | (((uint32) slot) << ishift);
lookup8[ibyte] = v;
}
}

template<uint32 BITS_PER_SLOT>
int32 xoStyleSet::TGetSlot( const void* lookup, xoStyleCategories cat )
{
const uint32 mask		= (1 << BITS_PER_SLOT) - 1;
const uint8* lookup8	= (const uint8*) lookup;

if ( BITS_PER_SLOT == 8 )
{
return lookup8[cat];
}
else
{
uint32	intra_byte_mask;
uint32	ibyte;
if ( BITS_PER_SLOT == 2 )		{ ibyte = ((uint32) cat) >> 2;	intra_byte_mask = 3; }
else if ( BITS_PER_SLOT == 4 )	{ ibyte = ((uint32) cat) >> 1;	intra_byte_mask = 1; }

uint8	v = lookup8[ibyte];
uint8	islotinbyte = ((uint32) cat) & intra_byte_mask;
uint8	ishift = islotinbyte * BITS_PER_SLOT;
uint8	shiftedmask = mask << ishift;
v = (v & shiftedmask) >> ishift;
return v;
}
}

int32 xoStyleSet::GetSlot2( const void* lookup, xoStyleCategories cat ) { return TGetSlot<2>( lookup, cat ); }
int32 xoStyleSet::GetSlot4( const void* lookup, xoStyleCategories cat ) { return TGetSlot<4>( lookup, cat ); }
int32 xoStyleSet::GetSlot8( const void* lookup, xoStyleCategories cat ) { return TGetSlot<8>( lookup, cat ); }

void xoStyleSet::SetSlot2( void* lookup, xoStyleCategories cat, int32 slot ) { TSetSlot<2>( lookup, cat, slot ); }
void xoStyleSet::SetSlot4( void* lookup, xoStyleCategories cat, int32 slot ) { TSetSlot<4>( lookup, cat, slot ); }
void xoStyleSet::SetSlot8( void* lookup, xoStyleCategories cat, int32 slot ) { TSetSlot<8>( lookup, cat, slot ); }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoStyleTable::xoStyleTable()
{
}

xoStyleTable::~xoStyleTable()
{
}

void xoStyleTable::AddDummyStyleZero()
{
GetOrCreate( "" );
}

void xoStyleTable::Discard()
{
Styles.hack( 0, 0, NULL );
Names.hack( 0, 0, NULL );
}

const xoStyle* xoStyleTable::GetByID( xoStyleID id ) const
{
return &Styles[id];
}

xoStyle* xoStyleTable::GetOrCreate( const char* name )
{
xoTempString n(name);
// find existing
int* pindex = NameToIndex.getp( n );
if ( pindex ) return &Styles[*pindex];

// create new
int index = (int) Styles.size();
Styles.add();
Names.add();
xoStyle* s = &Styles[index];
NameToIndex.insert( n, index );
Names[index] = xoString( name );
return s;
}

xoStyleID xoStyleTable::GetStyleID( const char* name )
{
xoTempString n(name);
int* pindex = NameToIndex.getp( n );
if ( pindex )	return xoStyleID( *pindex );
else			return xoStyleID(0);
}

void xoStyleTable::CloneSlowInto( xoStyleTable& c ) const
{
// The renderer doesn't need a Name -> ID table. That lookup table is only for end-user convenience.
c.Styles = Styles;
}

void xoStyleTable::CloneFastInto( xoStyleTable& c, xoPool* pool ) const
{
// The renderer doesn't need a Name -> ID table. That lookup table is only for end-user convenience.
xoClonePodvecWithMemCopy( c.Styles, Styles, pool );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

XOAPI bool xoParseDisplayType( const char* s, intp len, xoDisplayType& t )
{
if ( MATCH(s, 0, len, "block") ) { t = xoDisplayBlock; return true; }
if ( MATCH(s, 0, len, "inline") ) { t = xoDisplayInline; return true; }
return false;
}

XOAPI bool xoParsePositionType( const char* s, intp len, xoPositionType& t )
{
if ( MATCH(s, 0, len, "static") )	{ t = xoPositionStatic; return true; }
if ( MATCH(s, 0, len, "absolute") ) { t = xoPositionAbsolute; return true; }
if ( MATCH(s, 0, len, "relative") ) { t = xoPositionRelative; return true; }
if ( MATCH(s, 0, len, "fixed") )	{ t = xoPositionFixed; return true; }
return false;
}

XOAPI bool xoParseBreakType( const char* s, intp len, xoBreakType& t )
{
if ( MATCH(s, 0, len, "none") )		{ t = xoBreakNULL; return true; }
if ( MATCH(s, 0, len, "before") )	{ t = xoBreakBefore; return true; }
if ( MATCH(s, 0, len, "after") )	{ t = xoBreakAfter; return true; }
return false;
}

XOAPI bool xoParseFlowAxis( const char* s, intp len, xoFlowAxis& t )
{
if ( MATCH(s, 0, len, "horizontal") )	{ t = xoFlowAxisHorizontal; return true; }
if ( MATCH(s, 0, len, "vertical") )		{ t = xoFlowAxisVertical; return true; }
return false;
}

XOAPI bool xoParseFlowDirection( const char* s, intp len, xoFlowDirection& t )
{
if ( MATCH(s, 0, len, "normal") )	{ t = xoFlowDirectionNormal; return true; }
if ( MATCH(s, 0, len, "reverse") )	{ t = xoFlowDirectionReversed; return true; }
return false;
}

XOAPI bool xoParseBoxSize( const char* s, intp len, xoBoxSizeType& t )
{
if ( MATCH(s, 0, len, "content") )	{ t = xoBoxSizeContent; return true; }
if ( MATCH(s, 0, len, "border") )	{ t = xoBoxSizeBorder; return true; }
if ( MATCH(s, 0, len, "margin") )	{ t = xoBoxSizeMargin; return true; }
return false;
}

XOAPI bool xoParseTextAlignVertical( const char* s, intp len, xoTextAlignVertical& t )
{
if ( MATCH(s, 0, len, "baseline") )	{ t = xoTextAlignVerticalBaseline; return true; }
if ( MATCH(s, 0, len, "top") )		{ t = xoTextAlignVerticalTop; return true; }
return false;
}

XOAPI bool xoParseHorizontalBinding( const char* s, intp len, xoHorizontalBindings& t )
{
if ( MATCH(s, 0, len, "left") )		{ t = xoHorizontalBindingLeft; return true; }
if ( MATCH(s, 0, len, "hcenter") )	{ t = xoHorizontalBindingCenter; return true; }
if ( MATCH(s, 0, len, "right") )	{ t = xoHorizontalBindingRight; return true; }
return false;
}

XOAPI bool xoParseVerticalBinding( const char* s, intp len, xoVerticalBindings& t )
{
if ( MATCH(s, 0, len, "top") )		{ t = xoVerticalBindingTop; return true; }
if ( MATCH(s, 0, len, "vcenter") )	{ t = xoVerticalBindingCenter; return true; }
if ( MATCH(s, 0, len, "bottom") )	{ t = xoVerticalBindingBottom; return true; }
if ( MATCH(s, 0, len, "baseline") )	{ t = xoVerticalBindingBaseline; return true; }
return false;
}

XOAPI bool xoParseBorder( const char* s, intp len, xoStyle& style )
{
int spaces[10];
int nspaces = FindSpaces( s, len, spaces );

if ( nspaces == 0 )
{
// 1px		OR
// #000
xoColor color;
if ( xoColor::Parse( s, len, color ) )
{
style.SetUniformBox( xoCatBorderColor_Left, color );
return true;
}
xoSize size;
if ( xoSize::Parse( s, len, size ) )
{
style.SetBox( xoCatBorder_Left, xoStyleBox::MakeUniform(size) );
return true;
}
}
else if ( nspaces == 1 )
{
// 1px #000
xoSize size;
xoColor color;
if ( xoSize::Parse( s, spaces[0], size ) )
{
if ( xoColor::Parse( s + spaces[0] + 1, len - spaces[0] - 1, color ) )
{
style.SetBox( xoCatBorder_Left, xoStyleBox::MakeUniform(size) );
style.SetUniformBox( xoCatBorderColor_Left, color );
return true;
}
}
}
else if ( nspaces == 3 )
{
// 1px 2px 3px 4px
xoStyleBox box;
bool s1 = xoSize::Parse( s, spaces[0], box.Left );
bool s2 = xoSize::Parse( s + spaces[0] + 1, spaces[1] - spaces[0] - 1, box.Top );
bool s3 = xoSize::Parse( s + spaces[1] + 1, spaces[2] - spaces[1] - 1, box.Right );
bool s4 = xoSize::Parse( s + spaces[2] + 1, len - spaces[2] - 1, box.Bottom );
if ( s1 && s2 && s3 && s4 )
{
style.SetBox( xoCatBorder_Left, box );
return true;
}
}

return false;
}


static const TCHAR*		WClass = _T("xo");

#if XO_PLATFORM_ANDROID
xoSysWnd*				SingleMainWnd = NULL;
#elif XO_PLATFORM_LINUX_DESKTOP
// TODO: multiple windows
xoSysWnd*				SingleMainWnd = NULL;
#endif

void xoSysWnd::PlatformInitialize()
{
#if XO_PLATFORM_WIN_DESKTOP
WNDCLASSEX wcex;

wcex.cbSize = sizeof(WNDCLASSEX);

wcex.style			= 0;//CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
wcex.lpfnWndProc	= xoDocGroup::StaticWndProc;
wcex.cbClsExtra		= 0;
wcex.cbWndExtra		= 0;
wcex.hInstance		= GetModuleHandle(NULL);
wcex.hIcon			= NULL;
wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
wcex.hbrBackground	= NULL;//(HBRUSH)(COLOR_WINDOW+1);
wcex.lpszMenuName	= NULL;
wcex.lpszClassName	= WClass;
wcex.hIconSm		= NULL;

ATOM wclass_atom = RegisterClassEx(&wcex);
#elif XO_PLATFORM_ANDROID
#elif XO_PLATFORM_LINUX_DESKTOP
#else
XOTODO_STATIC
#endif
}

xoSysWnd::xoSysWnd()
{
#if XO_PLATFORM_WIN_DESKTOP
SysWnd = NULL;
#elif XO_PLATFORM_ANDROID
SingleMainWnd = this;
RelativeClientRect = xoBox(0,0,0,0);
#elif XO_PLATFORM_LINUX_DESKTOP
XDisplay = NULL;
//XWindowRoot = NULL;
VisualInfo = NULL;
//ColorMap = NULL;
//SetWindowAttributes = NULL;
//XWindow = NULL;
GLContext = NULL;
//WindowAttributes = NULL;
//Event = NULL;
#else
XOTODO_STATIC
#endif
DocGroup = new xoDocGroup();
DocGroup->Wnd = this;
Renderer = NULL;
}

xoSysWnd::~xoSysWnd()
{
#if XO_PLATFORM_WIN_DESKTOP
if ( Renderer )
{
Renderer->DestroyDevice( *this );
delete Renderer;
Renderer = NULL;
}
DestroyWindow( SysWnd );
#elif XO_PLATFORM_ANDROID
SingleMainWnd = NULL;
#elif XO_PLATFORM_LINUX_DESKTOP
if ( XDisplay != nullptr )
{
glXMakeCurrent( XDisplay, None, NULL );
glXDestroyContext( XDisplay, GLContext );
XDestroyWindow( XDisplay, XWindow );
XCloseDisplay( XDisplay );
}
SingleMainWnd = NULL;
#else
XOTODO_STATIC
#endif
xoGlobal()->DocRemoveQueue.Add( DocGroup );
DocGroup = NULL;
}

xoSysWnd* xoSysWnd::Create()
{
#if XO_PLATFORM_WIN_DESKTOP
bool ok = false;
xoSysWnd* w = new xoSysWnd();
XOTRACE("DocGroup = %p\n", w->DocGroup);
w->SysWnd = CreateWindow( WClass, _T("xo"), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, GetModuleHandle(NULL), w->DocGroup );
if ( w->SysWnd )
{
if ( w->InitializeRenderer() )
ok = true;
}
if ( !ok )
{
delete w;
w = NULL;
}
return w;
#elif XO_PLATFORM_ANDROID
xoSysWnd* w = new xoSysWnd();
w->InitializeRenderer();
return w;
#elif XO_PLATFORM_LINUX_DESKTOP
GLint att[] = { GLX_RGBA, GLX_DEPTH_SIZE, 16, GLX_DOUBLEBUFFER, None };
xoSysWnd* w = new xoSysWnd();
w->XDisplay = XOpenDisplay( NULL );
if ( w->XDisplay == NULL ) { XOTRACE("Cannot connect to X server\n" ); delete w; return nullptr; }
w->XWindowRoot = DefaultRootWindow( w->XDisplay );
w->VisualInfo = glXChooseVisual( w->XDisplay, 0, att );
if ( w->VisualInfo == NULL ) { XOTRACE("no appropriate visual found\n" ); delete w; return nullptr; }
XOTRACE( "visual %p selected\n", (void*) w->VisualInfo->visualid );
w->ColorMap = XCreateColormap( w->XDisplay, w->XWindowRoot, w->VisualInfo->visual, AllocNone );
XSetWindowAttributes swa;
swa.colormap = w->ColorMap;
swa.event_mask = ExposureMask | KeyPressMask | PointerMotionMask;
w->XWindow = XCreateWindow( w->XDisplay, w->XWindowRoot, 0, 0, 600, 600, 0, w->VisualInfo->depth, InputOutput, w->VisualInfo->visual, CWColormap | CWEventMask, &swa );
XMapWindow( w->XDisplay, w->XWindow );
XStoreName( w->XDisplay, w->XWindow, "xo" );
w->GLContext = glXCreateContext( w->XDisplay, w->VisualInfo, NULL, GL_TRUE );
glXMakeCurrent( w->XDisplay, w->XWindow, w->GLContext );
w->InitializeRenderer();
glXMakeCurrent( w->XDisplay, None, NULL );
SingleMainWnd = w;
return w;
#else
XOTODO_STATIC
#endif
}

xoSysWnd* xoSysWnd::CreateWithDoc()
{
xoSysWnd* w = Create();
if ( !w )
return NULL;
w->Attach( new xoDoc(), true );
xoGlobal()->DocAddQueue.Add( w->DocGroup );
return w;
}

void xoSysWnd::Show()
{
#if XO_PLATFORM_WIN_DESKTOP
ShowWindow( SysWnd, SW_SHOW );
#elif XO_PLATFORM_ANDROID
#elif XO_PLATFORM_LINUX_DESKTOP
#else
XOTODO_STATIC
#endif
}

xoDoc* xoSysWnd::Doc()
{
return DocGroup->Doc;
}

void xoSysWnd::Attach( xoDoc* doc, bool destroyDocWithGroup )
{
DocGroup->Doc = doc;
DocGroup->DestroyDocWithGroup = destroyDocWithGroup;
}

bool xoSysWnd::BeginRender()
{
if ( Renderer )
return Renderer->BeginRender( *this );
else
return false;
}

void xoSysWnd::EndRender()
{
if ( Renderer )
Renderer->EndRender( *this );
}

void xoSysWnd::SurfaceLost()
{
if ( Renderer )
Renderer->SurfaceLost();
}

void xoSysWnd::SetPosition( xoBox box, uint setPosFlags )
{
#if XO_PLATFORM_WIN_DESKTOP
uint wflags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
if ( !!(setPosFlags & SetPosition_Move) ) wflags = wflags & ~SWP_NOMOVE;
if ( !!(setPosFlags & SetPosition_Size) ) wflags = wflags & ~SWP_NOSIZE;
SetWindowPos( SysWnd, NULL, box.Left, box.Top, box.Width(), box.Height(), wflags );
#elif XO_PLATFORM_ANDROID
#elif XO_PLATFORM_LINUX_DESKTOP
XOTRACE( "xoSysWnd.SetPosition is not implemented\n" );
#else
XOTODO_STATIC
#endif
}

xoBox xoSysWnd::GetRelativeClientRect()
{
#if XO_PLATFORM_WIN_DESKTOP
RECT r;
POINT p0 = {0,0};
ClientToScreen( SysWnd, &p0 );
GetClientRect( SysWnd, &r );
xoBox box = r;
box.Offset( p0.x, p0.y );
return box;
#elif XO_PLATFORM_ANDROID
return RelativeClientRect;
#elif XO_PLATFORM_LINUX_DESKTOP
XWindowAttributes wa;
XGetWindowAttributes( XDisplay, XWindow, &wa );
return xoBox( wa.x, wa.y, wa.x + wa.width, wa.y + wa.height );
#else
XOTODO_STATIC
#endif
}

bool xoSysWnd::InitializeRenderer()
{
#if XO_PLATFORM_WIN_DESKTOP
if ( xoGlobal()->PreferOpenGL )
{
if ( InitializeRenderer_Any<xoRenderGL>( Renderer ) )
return true;
if ( InitializeRenderer_Any<xoRenderDX>( Renderer ) )
return true;
}
else
{
if ( InitializeRenderer_Any<xoRenderDX>( Renderer ) )
return true;
if ( InitializeRenderer_Any<xoRenderGL>( Renderer ) )
return true;
}
return false;
#else
InitializeRenderer_Any<xoRenderGL>( Renderer );
#endif
}

template<typename TRenderer>
bool xoSysWnd::InitializeRenderer_Any( xoRenderBase*& renderer )
{
renderer = new TRenderer();
if ( renderer->InitializeDevice( *this ) )
{
XOTRACE( "Successfully initialized %s renderer\n", renderer->RendererName() );
return true;
}
else
{
delete renderer;
renderer = NULL;
return false;
}
}


xoDocGroup::xoDocGroup()
{
AbcCriticalSectionInitialize( DocLock );
DestroyDocWithGroup = false;
Doc = NULL;
Wnd = NULL;
RenderDoc = new xoRenderDoc();
RenderStats.Reset();
}

xoDocGroup::~xoDocGroup()
{
delete RenderDoc;
if ( DestroyDocWithGroup )
delete Doc;
AbcCriticalSectionDestroy( DocLock );
}

xoRenderResult xoDocGroup::Render()
{
return RenderInternal( NULL );
}

xoRenderResult xoDocGroup::RenderToImage( xoImage& image )
{
// The 10 here is an arbitrary thumbsuck. We'll see if we ever need a controllable limit.
const int maxAttempts = 10;
xoRenderResult res = xoRenderResultNeedMore;
for ( int attempt = 0; res == xoRenderResultNeedMore && attempt < maxAttempts; attempt++ )
res = RenderInternal( &image );
return res;
}

// This is always called from the Render thread
xoRenderResult xoDocGroup::RenderInternal( xoImage* targetImage )
{
bool haveLock = false;
// I'm not quite sure how we should handle this. The idea is that you don't want to go without a UI update
// for too long, even if the UI thread is taking its time, and being bombarded with messages.
uint32 rDocAge = Doc->GetVersion() - RenderDoc->Doc.GetVersion();
if ( rDocAge > 0 || targetImage != NULL )
{
// If UI thread has performed many updates since we last rendered,
// then pause our thread until we can gain the DocLock
haveLock = true;
AbcCriticalSectionEnter( DocLock );
}
else
{
// The UI thread has not done much since we last rendered, so do not wait for the lock
haveLock = AbcCriticalSectionTryEnter( DocLock );
}

if ( !haveLock )
{
NUTIME( "Render: Failed to acquire DocLock\n" );
return xoRenderResultNeedMore;
}

// TODO: If AnyAnimationsRunning(), then we are not idle
bool docValid = RenderDoc->WindowWidth != 0 && RenderDoc->WindowHeight != 0;
bool docModified = Doc->GetVersion() != RenderDoc->Doc.GetVersion();

if ( docModified && docValid )
{
//XOTRACE( "Render Version %u\n", Doc->GetVersion() );
RenderDoc->CopyFromCanonical( *Doc, RenderStats );

// Assume we are the only renderer of 'Doc'. If this assumption were not true, then you would need to update
// all renderers simultaneously, so that you can guarantee that UsableIDs all go to FreeIDs atomically.
//XOTRACE( "MakeFreeIDsUsable\n" );
Doc->MakeFreeIDsUsable();
Doc->ResetModifiedBitmap();			// AbcBitMap has an absolutely awful implementation of this (byte-filled vs SSE or at least pointer-word-size-filled)
}
AbcCriticalSectionLeave( DocLock );

xoRenderResult rendResult = xoRenderResultIdle;

if ( (docModified || targetImage != NULL) && docValid && Wnd != NULL )
{
//NUTIME( "Render start\n" );
if ( !Wnd->BeginRender() )
{
NUTIME( "BeginRender failed\n" );
return xoRenderResultNeedMore;
}

//NUTIME( "Render DO\n" );
rendResult = RenderDoc->Render( Wnd->Renderer );

if ( targetImage != NULL )
Wnd->Renderer->ReadBackbuffer( *targetImage );

//NUTIME( "Render Finish\n" );
Wnd->EndRender();
}

return rendResult;
}

// This is always called from the UI thread
void xoDocGroup::ProcessEvent( xoEvent& ev )
{
TakeCriticalSection lock( DocLock );
uint32 initialVersion = Doc->GetVersion();
if ( ev.Type != xoEventTimer )
XOTRACE_LATENCY("ProcessEvent (not a timer)\n");
switch ( ev.Type )
{
case xoEventWindowSize:
RenderDoc->WindowWidth = (uint32) ev.Points[0].x;
RenderDoc->WindowHeight = (uint32) ev.Points[0].y;
Doc->IncVersion();
//NUTIME( "Processed WindowSize event. Document at version %d\n", Doc->GetVersion() );
break;
}
if ( BubbleEvent( ev ) )
Doc->IncVersion();
}

// Returns true if the event was handled
bool xoDocGroup::BubbleEvent( xoEvent& ev )
{
// TODO. My plan is to go with upward bubbling only. The inner-most
// control gets the event first, then outward.
// A return value of false means "cancel the bubble".
// But ah.... downward bubbling is necessary for things like shortcut
// keys. I'm not sure how one does that with HTML.
// Right.. so "capturing" is the method where the event propagates inwards.
// IE does not support capturing though, so nobody really use it.
// We simply ignore the question of how to do shortcut keys for now.

XOTRACE_EVENTS( "BubbleEvent type=%d\n", (int) ev.Type );

xoDomNode* el = &Doc->Root;
bool stop = false;
bool handled = false;

if ( el->HandlesEvent(ev.Type) )
{
const podvec<xoEventHandler>& h = el->GetHandlers();
XOTRACE_EVENTS( "BubbleEvent found %d event handlers\n", (int) h.size() );
for ( intp i = 0; i < h.size() && !stop; i++ )
{
if ( h[i].Handles( ev.Type ) )
{
handled = true;
xoEvent c = ev;
c.Context = h[i].Context;
c.Target = el;
if ( !h[i].Func( c ) )
{
stop = true;
}
}
}
}

return handled;
}

/*
void xoDocGroup::FindTarget( const xoVec2f& p, pvect<xoRenderDomEl*>& chain )
{
chain += &RenderDoc->RenderRoot;
while ( true )
{
xoRenderDomEl* top = chain.back();
for ( intp i = 0; i < top->Children.size(); i++ )
{
//if ( top->Children[i]->Pos )
}
}
}
*/

bool xoDocGroup::IsDocVersionDifferentToRenderer() const
{
return Doc->GetVersion() != RenderDoc->Doc.GetVersion();
}


LRESULT CALLBACK xoDocGroup::StaticWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
xoDocGroup* proc = (xoDocGroup*) GetWindowLongPtr( hWnd, GWLP_USERDATA );
if ( proc == NULL && lParam != NULL && message == WM_NCCREATE )
{
// This is passed in via CreateWindow()
// The one message that we unfortunately miss is WM_GETMINMAXINFO, which gets sent before WM_NCCREATE
CREATESTRUCT* cs = (CREATESTRUCT*) lParam;
proc = (xoDocGroup*) cs->lpCreateParams;
SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR) proc );
}

if ( proc && proc->Doc )
{
return proc->WndProc( hWnd, message, wParam, lParam );
}
else
{
// This path gets hit before WM_CREATE
return DefWindowProc(hWnd, message, wParam, lParam);
}
}

/*
Windows peculiarities
---------------------

WM_NCLBUTTONDOWN:
If you receive a WM_NCLBUTTONDOWN, and call DefWindowProc, it will enter a modal loop. So your application-level message loop will not
get called until the user finishes sizing the window.
Since we run our renderer from the application's main message pump, we cease to render while the window is being resized.
Our solution: Whenever we receive WM_NCLBUTTONDOWN, start a timer. Stop that timer when DefWindowProc returns.
Since rendering happens on the main window message thread, we're not violating any thread model principle here.

*/

enum Timers
{
TimerRenderOutsideMainMsgPump	= 1,
TimerGenericEvent				= 2,
};

LRESULT xoDocGroup::WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
XOASSERT( Doc != NULL );
PAINTSTRUCT ps;
HDC dc;
xoEvent ev;
ev.DocGroup = this;
LRESULT result = 0;
auto cursor = XOVEC2( (float) GET_X_LPARAM(lParam), (float) GET_Y_LPARAM(lParam) );

switch (message)
{
case WM_ERASEBKGND:
return 1;

case WM_PAINT:
// TODO: Adjust this on the fly, using the minimum interval of all generic timer subscribers
// Also.. find a better place to put this
//SetTimer( hWnd, TimerGenericEvent, 15, NULL );
//SetTimer( hWnd, TimerGenericEvent, 150, NULL );

dc = BeginPaint(hWnd, &ps);
EndPaint(hWnd, &ps);
break;

case WM_SIZE:
ev.MakeWindowSize( int(lParam & 0xffff), int((lParam >> 16) & 0xffff) );
xoGlobal()->EventQueue.Add( ev );
break;

case WM_TIMER:
if ( wParam == TimerRenderOutsideMainMsgPump )
Render();
else if ( wParam == TimerGenericEvent )
{
ev.Type = xoEventTimer;
xoGlobal()->EventQueue.Add( ev );
}
break;

case WM_NCLBUTTONDOWN:
// Explanation above titled 'WM_NCLBUTTONDOWN'
SetTimer( hWnd, TimerRenderOutsideMainMsgPump, 1000 / xoGlobal()->TargetFPS, NULL );
result = DefWindowProc(hWnd, message, wParam, lParam);
KillTimer( hWnd, TimerRenderOutsideMainMsgPump );
return result;

case WM_DESTROY:
PostQuitMessage(0);
break;

case WM_MOUSEMOVE:
ev.Type = xoEventMouseMove;
ev.PointCount = 1;
ev.Points[0] = cursor;
XOTRACE_LATENCY("MouseMove\n");
xoGlobal()->EventQueue.Add( ev );
break;

case WM_LBUTTONUP:
// Click event needs refinement (ie on down, capture, etc)
ev.Type = xoEventClick;
ev.PointCount = 1;
XOTRACE_LATENCY("LButtonUp\n");
ev.Points[0] = cursor;
xoGlobal()->EventQueue.Add( ev );
break;

default:
return DefWindowProc(hWnd, message, wParam, lParam);
}

return 0;
}




xoDomEl::xoDomEl( xoDoc* doc, xoTag tag )
{
Doc = doc;
Tag = tag;
InternalID = 0;
Version = 0;
}

xoDomEl::~xoDomEl()
{
}

// all memory allocations come from the pool. The also happens to be recursive.
/*
void xoDomEl::CloneFastInto( xoDomEl& c, xoPool* pool, uint cloneFlags ) const
{
xoDoc* cDoc = c.GetDoc();
c.InternalID = InternalID;
c.Tag = Tag;
c.Version = Version;
Style.CloneFastInto( c.Style, pool );

XOASSERT(false); // Text?

// copy classes
xoClonePodvecWithMemCopy( c.Classes, Classes, pool );

// alloc list of pointers to children
xoClonePvectPrepare( c.Children, Children, pool );

// alloc children
for ( int i = 0; i < Children.size(); i++ )
c.Children[i] = pool->AllocT<xoDomEl>( true );

// copy children
for ( int i = 0; i < Children.size(); i++ )
{
c.Children[i]->Doc = c.Doc;
Children[i]->CloneFastInto( *c.Children[i], pool, cloneFlags );
}

if ( !!(cloneFlags & xoCloneFlagEvents) )
XOPANIC("clone events is TODO");

cDoc->ChildAddedFromDocumentClone( &c );
}
*/

void xoDomEl::IncVersion()
{
Version++;
Doc->SetChildModified( InternalID );
}

// memory allocations come from the regular heap. This also happens to not be recursive.
void xoDomEl::CloneSlowIntoBase( xoDomEl& c, uint cloneFlags ) const
{
c.InternalID = InternalID;
c.Tag = Tag;
c.Version = Version;
}


xoDomNode::xoDomNode( xoDoc* doc, xoTag tag ) : xoDomEl(doc, tag)
{
AllEventMask = 0;
}

xoDomNode::~xoDomNode()
{
for ( intp i = 0; i < Children.size(); i++ )
Doc->FreeChild( Children[i] );
Children.clear();
}

void xoDomNode::SetText( const char* txt )
{
if ( Children.size() != 1 || Children[0]->GetTag() != xoTagText )
{
RemoveAllChildren();
AddChild( xoTagText );
}
Children[0]->SetText( txt );
}

const char* xoDomNode::GetText() const
{
if ( Children.size() == 1 && Children[0]->GetTag() == xoTagText )
{
return Children[0]->GetText();
}
else
{
return "";
}
}

void xoDomNode::CloneSlowInto( xoDomEl& c, uint cloneFlags ) const
{
CloneSlowIntoBase( c, cloneFlags );
xoDomNode& cnode = static_cast<xoDomNode&>(c);
xoDoc* cDoc = c.GetDoc();

Style.CloneSlowInto( cnode.Style );
cnode.Classes = Classes;

// By the time we get here, all relevant DOM elements inside the destination document
// have already been created. That is why we are not recursive here.
cnode.Children.clear_noalloc();
for ( intp i = 0; i < Children.size(); i++ )
cnode.Children += cDoc->GetChildByInternalIDMutable( Children[i]->GetInternalID() );

if ( !!(cloneFlags & xoCloneFlagEvents) )
XOPANIC("clone events is TODO");
}

void xoDomNode::ForgetChildren()
{
Children.clear_noalloc();
}

xoDomEl* xoDomNode::AddChild( xoTag tag )
{
IncVersion();
xoDomEl* c = Doc->AllocChild( tag );
Children += c;
Doc->ChildAdded( c );
return c;
}

xoDomNode* xoDomNode::AddNode( xoTag tag )
{
AbcAssert( tag != xoTagText );
return static_cast<xoDomNode*>(AddChild(tag));
}

xoDomText* xoDomNode::AddText( const char* txt )
{
xoDomText* el = static_cast<xoDomText*>(AddChild(xoTagText));
el->SetText( txt );
return el;
}

void xoDomNode::RemoveChild( xoDomEl* c )
{
if ( !c ) return;
IncVersion();
intp ix = Children.find( c );
XOASSERT( ix != -1 );
Children.erase(ix);
Doc->ChildRemoved( c );
Doc->FreeChild( c );
}

void xoDomNode::RemoveAllChildren()
{
IncVersion();
for ( intp i = 0; i < Children.size(); i++ )
{
Doc->ChildRemoved( Children[i] );
Doc->FreeChild( Children[i] );
}
Children.clear();
}

xoDomEl* xoDomNode::ChildByIndex( intp index )
{
XOASSERT( (uintp) index < (uintp) Children.size() );
return Children[index];
}

const xoDomEl* xoDomNode::ChildByIndex( intp index ) const
{
XOASSERT( (uintp) index < (uintp) Children.size() );
return Children[index];
}

void xoDomNode::Discard()
{
InternalID = 0;
AllEventMask = 0;
Version = 0;
Style.Discard();
Classes.hack( 0, 0, NULL );
Children.hack( 0, 0, NULL );
Handlers.hack( 0, 0, NULL );
}

xoString xoDomNode::Parse( const char* src )
{
RemoveAllChildren();
return ParseAppend( src );
}

xoString xoDomNode::ParseAppend( const char* src )
{
xoDocParser p;
return p.Parse( src, this );
}

xoString xoDomNode::ParseAppend( const xoStringRaw& src )
{
return ParseAppend( src.Z );
}

bool xoDomNode::StyleParse( const char* t, intp maxLen )
{
IncVersion();
return Style.Parse( t, maxLen, Doc );
}

bool xoDomNode::StyleParsef( const char* t, ... )
{
char buff[8192];
va_list va;
va_start( va, t );
uint r = vsnprintf( buff, arraysize(buff), t, va );
va_end( va );
buff[arraysize(buff) - 1] = 0;
if ( r < arraysize(buff) )
{
return StyleParse( buff );
}
else
{
xoString str = xoString(t);
str.Z[50] = 0;
xoParseFail( "Parse string is too long for StyleParsef: %s...", str.Z );
XOASSERTDEBUG(false);
return false;
}
}

void xoDomNode::HackSetStyle( const xoStyle& style )
{
IncVersion();
Style = style;
}

void xoDomNode::AddClass( const char* klass )
{
IncVersion();
xoStyleID id = Doc->ClassStyles.GetStyleID( klass );
if ( Classes.find( id ) == -1 )
Classes += id;
}

void xoDomNode::RemoveClass( const char* klass )
{
IncVersion();
xoStyleID id = Doc->ClassStyles.GetStyleID( klass );
intp index = Classes.find( id );
if ( index != -1 )
Classes.erase( index );
}

void xoDomNode::AddHandler( xoEvents ev, xoEventHandlerF func, bool isLambda, void* context )
{
for ( intp i = 0; i < Handlers.size(); i++ )
{
if ( Handlers[i].Context == context && Handlers[i].Func == func )
{
XOASSERT(isLambda == Handlers[i].IsLambda());
Handlers[i].Mask |= ev;
RecalcAllEventMask();
return;
}
}
auto& h = Handlers.add();
h.Context = context;
h.Func = func;
h.Mask = ev;
if ( isLambda )
h.SetLambda();
RecalcAllEventMask();
}

void xoDomNode::AddHandler( xoEvents ev, xoEventHandlerLambda lambda )
{
xoEventHandlerLambda* copy = new xoEventHandlerLambda( lambda );
AddHandler( ev, xoEventHandler_LambdaStaticFunc, true, copy );
}

void xoDomNode::AddHandler( xoEvents ev, xoEventHandlerF func, void* context )
{
AddHandler( ev, func, false, context );
}

void xoDomNode::RecalcAllEventMask()
{
uint32 m = 0;
for ( intp i = 0; i < Handlers.size(); i++ )
m |= Handlers[i].Mask;
AllEventMask = m;
}


xoDomText::xoDomText( xoDoc* doc, xoTag tag ) : xoDomEl(doc, tag)
{
}

xoDomText::~xoDomText()
{
}

void xoDomText::SetText( const char* txt )
{
Text = txt;
}

const char* xoDomText::GetText() const
{
return Text.Z;
}

void xoDomText::CloneSlowInto( xoDomEl& c, uint cloneFlags ) const
{
CloneSlowIntoBase( c, cloneFlags );
xoDomText& ctext = static_cast<xoDomText&>(c);

ctext.Text = Text;
}

void xoDomText::ForgetChildren()
{
}


xoImage::xoImage()
{
}

xoImage::~xoImage()
{
Free();
}

xoImage* xoImage::Clone() const
{
xoImage* c = new xoImage();
c->Set( TexFormat, GetWidth(), GetHeight(), GetData() );
return c;
}

void xoImage::Free()
{
if ( TexData )
{
AbcAlignedFree( TexData );
TexData = NULL;
}
TexID = xoTextureIDNull;
}

void xoImage::Set( xoTexFormat format, u32 width, u32 height, const void* bytes )
{
Alloc( format, width, height );
size_t size = TexWidth * TexHeight * xoTexFormatBytesPerPixel(format);
if ( size != 0 )
memcpy( TexData, bytes, size );
}

void xoImage::Alloc( xoTexFormat format, u32 width, u32 height )
{
size_t existingFormatBPP = xoTexFormatBytesPerPixel(TexFormat);
size_t requiredFormatBPP = xoTexFormatBytesPerPixel(format);

if ( width == TexWidth && height == TexHeight && existingFormatBPP == requiredFormatBPP )
{
if ( TexFormat != format )
TexFormat = format;
return;
}

if ( TexWidth != width || TexWidth != height )
Free();
TexWidth = width;
TexHeight = height;
TexFormat = format;
if ( TexWidth != 0 && TexHeight != 0 )
{
TexInvalidate();
TexStride = TexWidth * (uint32) TexBytesPerPixel();
size_t size = TexHeight * TexStride;
TexData = AbcAlignedMalloc( size, 16 );
AbcCheckAlloc( TexData );
}
}


const char* xoImageStore::NullImageName = "NULL";

xoImageStore::xoImageStore()
{
xoImage* nimg = new xoImage();
u32 ndata[2][2] = {
{0xffffffff, 0xff000000},
{0xff000000, 0xffffffff},
};
nimg->Set( xoTexFormatRGBA8, 2, 2, ndata );
XOASSERT( NullImageIndex == ImageList.size() );
Set( NullImageName, nimg );
}

xoImageStore::~xoImageStore()
{
delete_all( ImageList );
}

void xoImageStore::Set( const char* name, xoImage* img )
{
xoTempString sname(name);
int index = -1;
bool exists = NameToIndex.get( sname, index );
if ( exists )
{
delete ImageList[index];
ImageList[index] = img;
}
else
{
NameToIndex.insert( sname, (int) ImageList.size() );
ImageList += img;
}
}

xoImage* xoImageStore::Get( const char* name ) const
{
int index = -1;
if ( NameToIndex.get( xoTempString(name), index ) )
return ImageList[index];
else
return NULL;
}

xoImage* xoImageStore::GetOrNull( const char* name ) const
{
xoImage* img = Get( name );
if ( img )
return img;
return ImageList[NullImageIndex];
}

const xoImage* xoImageStore::GetNull() const
{
return ImageList[NullImageIndex];
}

void xoImageStore::CloneFrom( const xoImageStore& src )
{
delete_all( ImageList );
NameToIndex.clear();

Set( NullImageName, src.Get( NullImageName )->Clone() );

for ( auto it = src.NameToIndex.begin(); it != src.NameToIndex.end(); it++ )
{
if ( it.val() != NullImageIndex )
Set( it.key().Z, src.ImageList[it.val()]->Clone() );
}
}


/* This is called serially.

Why do we perform layout in multiple passes, loading all missing glyphs at the end of each pass?
The reason is because we eventually want to be able to parallelize layout.

Missing glyphs are a once-off cost (ie once per application instance),
so it's not worth trying to use a mutable glyph cache.

*/
void xoLayout::Layout( const xoDoc& doc, u32 docWidth, u32 docHeight, xoRenderDomNode& root, xoPool* pool )
{
Doc = &doc;
DocWidth = docWidth;
DocHeight = docHeight;
Pool = pool;
Stack.Initialize( Doc, Pool );
Fonts = xoGlobal()->FontStore->GetImmutableTable();

while ( true )
{
LayoutInternal( root );

if ( GlyphsNeeded.size() == 0 )
{
XOTRACE_LAYOUT_VERBOSE( "Layout done\n" );
break;
}
else
{
XOTRACE_LAYOUT_VERBOSE( "Layout done (but need another pass for missing glyphs)\n" );
RenderGlyphsNeeded();
}
}
}

void xoLayout::LayoutInternal( xoRenderDomNode& root )
{
PtToPixel = 1.0;	// TODO
EpToPixel = xoGlobal()->EpToPixel;

XOTRACE_LAYOUT_VERBOSE( "Layout 1\n" );

Pool->FreeAll();
root.Children.clear();
Stack.Reset();

XOTRACE_LAYOUT_VERBOSE( "Layout 2\n" );

NodeState s;
memset( &s, 0, sizeof(s) );
s.ParentContentBox.SetInt( 0, 0, DocWidth, DocHeight );
//s.PositionedAncestor = s.ParentContentBox;
s.ParentContentBoxHasWidth = true;
s.ParentContentBoxHasHeight = true;
s.PosX = s.ParentContentBox.Left;
s.PosY = s.ParentContentBox.Top;
s.PosMaxX = s.PosX;
s.PosMaxY = s.PosY;
s.PosBaselineY = xoPosNULL;

XOTRACE_LAYOUT_VERBOSE( "Layout 3 DocBox = %d,%d,%d,%d\n", s.ParentContentBox.Left, s.ParentContentBox.Top, s.ParentContentBox.Right, s.ParentContentBox.Bottom );

RunNode( s, Doc->Root, &root );
}

void xoLayout::RunNode( NodeState& s, const xoDomNode& node, xoRenderDomNode* rnode )
{
XOTRACE_LAYOUT_VERBOSE( "Layout (%d) Run 1\n", node.GetInternalID() );
xoStyleResolver::ResolveAndPush( Stack, &node );
rnode->SetStyle( Stack );

XOTRACE_LAYOUT_VERBOSE( "Layout (%d) Run 2\n", node.GetInternalID() );
rnode->InternalID = node.GetInternalID();
if ( rnode->InternalID == 50 )
int abc = 123;

//auto display = Stack.Get( xoCatDisplay ).GetDisplayType();
auto position = Stack.Get( xoCatPosition ).GetPositionType();
auto boxSizing = Stack.Get( xoCatBoxSizing ).GetBoxSizing();
xoPos contentWidth = ComputeDimension( s.ParentContentBox.Width(), s.ParentContentBoxHasWidth, xoCatWidth );
xoPos contentHeight = ComputeDimension( s.ParentContentBox.Height(), s.ParentContentBoxHasHeight, xoCatHeight );
xoPos borderRadius = ComputeDimension( 0, false, xoCatBorderRadius );
xoBox margin = ComputeBox( s.ParentContentBox, s.ParentContentBoxHasWidth, s.ParentContentBoxHasHeight, xoCatMargin_Left );
xoBox padding = ComputeBox( s.ParentContentBox, s.ParentContentBoxHasWidth, s.ParentContentBoxHasHeight, xoCatPadding_Left );
xoBox border = ComputeBox( s.ParentContentBox, s.ParentContentBoxHasWidth, s.ParentContentBoxHasHeight, xoCatBorder_Left );

// It might make for less arithmetic if we work with marginBoxWidth and marginBoxHeight instead of contentBoxWidth and contentBoxHeight. We'll see.
bool haveWidth = contentWidth != xoPosNULL;
bool haveHeight = contentHeight != xoPosNULL;
rnode->Style.BorderRadius = xoPosToReal( borderRadius );

if ( boxSizing == xoBoxSizeContent ) {}
else if ( boxSizing == xoBoxSizeBorder )
{
if ( haveWidth )	contentWidth -= border.Left + border.Right + padding.Left + padding.Right;
if ( haveHeight )	contentHeight -= border.Top + border.Bottom + padding.Top + padding.Bottom;
}
else if ( boxSizing == xoBoxSizeMargin )
{
if ( haveWidth )	contentWidth -= margin.Left + margin.Right + border.Left + border.Right + padding.Left + padding.Right;
if ( haveHeight )	contentHeight -= margin.Top + margin.Bottom + border.Top + border.Bottom + padding.Top + padding.Bottom;
}

xoBox marginBox;
if ( position == xoPositionAbsolute )
{
marginBox = ComputeSpecifiedPosition( s );
}
else
{
marginBox.Left = marginBox.Right = s.PosX;
marginBox.Top = marginBox.Bottom = s.PosY;
if ( haveWidth ) marginBox.Right += margin.Left + border.Left + padding.Left + contentWidth + padding.Right + border.Right + margin.Right;
if ( haveHeight ) marginBox.Bottom += margin.Top + border.Top + padding.Top + contentHeight + padding.Bottom + border.Bottom + margin.Bottom;
}

// Check if this block overflows. If we don't have width yet, then we'll check overflow after laying out our children
if ( position == xoPositionStatic && s.ParentContentBoxHasWidth && haveWidth )
PositionBlock( s, marginBox );

bool enableRecursiveLayout = false;

// cs: child state
NodeState cs;
for ( int pass = 0; true; pass++ )
{
XOASSERTDEBUG( pass < 2 );

xoBox contentBox = marginBox;
contentBox.Left += border.Left + padding.Left + margin.Left;
contentBox.Top += border.Top + padding.Top + margin.Top;
if ( haveWidth )	contentBox.Right -= border.Right + padding.Right + margin.Right;
else				contentBox.Right = contentBox.Left;
if ( haveHeight )	contentBox.Bottom -= border.Bottom + padding.Bottom + margin.Bottom;
else				contentBox.Bottom = contentBox.Top;

cs = s;
cs.ParentContentBox = contentBox;
cs.ParentContentBoxHasWidth = haveWidth;
cs.ParentContentBoxHasHeight = haveHeight;
cs.PosX = cs.PosMaxX = contentBox.Left;
cs.PosY = cs.PosMaxY = contentBox.Top;
cs.PosBaselineY = s.PosBaselineY;

XOTRACE_LAYOUT_VERBOSE( "Layout (%d) Run 3 (position = %d) (%d %d)\n", node.GetInternalID(), (int) position, s.ParentContentBoxHasWidth ? 1 : 0, haveWidth ? 1 : 0 );

const pvect<xoDomEl*>& nodeChildren = node.GetChildren();
for ( int i = 0; i < nodeChildren.size(); i++ )
{
const xoDomEl* child = nodeChildren[i];
if ( child->GetTag() == xoTagText )
{
xoRenderDomText* rchild = new (Pool->AllocT<xoRenderDomText>(false)) xoRenderDomText( child->GetInternalID(), Pool );
rnode->Children += rchild;
RunText( cs, *static_cast<const xoDomText*>(child), rchild );
}
else
{
xoRenderDomNode* rchild = new (Pool->AllocT<xoRenderDomNode>(false)) xoRenderDomNode( child->GetInternalID(), child->GetTag(), Pool );
rnode->Children += rchild;
RunNode( cs, *static_cast<const xoDomNode*>(child), rchild );
}
}

if ( !haveWidth )	marginBox.Right = cs.PosMaxX + padding.Right + border.Right + margin.Right;
if ( !haveHeight )	marginBox.Bottom = cs.PosMaxY + padding.Bottom + border.Bottom + margin.Bottom;

// Since our width was undefined, we couldn't check for overflow until we'd layed out our children.
// If we do overflow now, then we need to retrofit all of our child boxes with an offset.
if ( enableRecursiveLayout && position == xoPositionStatic && s.ParentContentBoxHasWidth && !haveWidth )
{
xoPoint offset = PositionBlock( s, marginBox );
if ( offset != xoPoint(0,0) )
{
haveWidth = true;
//haveHeight = true;		// We do in fact NOT know height, because it can be altered by the resetting of the baseline on the new line
rnode->Children.clear();
continue;
}
}
else
{
s.PosX = marginBox.Right;
}

rnode->Pos = marginBox.ShrunkBy( margin );
break;
}

XOTRACE_LAYOUT_VERBOSE( "Layout (%d) marginBox: %d,%d,%d,%d\n", node.GetInternalID(), marginBox.Left, marginBox.Top, marginBox.Right, marginBox.Bottom );

s.PosMaxY = xoMax( s.PosMaxY, marginBox.Bottom );
if ( s.PosBaselineY == xoPosNULL )
s.PosBaselineY = cs.PosBaselineY;

Stack.StackPop();
}

void xoLayout::RunText( NodeState& s, const xoDomText& node, xoRenderDomText* rnode )
{
XOTRACE_LAYOUT_VERBOSE( "Layout text (%d) Run 1\n", node.GetInternalID() );
rnode->InternalID = node.GetInternalID();
rnode->SetStyle( Stack );

XOTRACE_LAYOUT_VERBOSE( "Layout text (%d) Run 2\n", node.GetInternalID() );

rnode->FontID = Stack.Get( xoCatFontFamily ).GetFont();

xoStyleAttrib fontSizeAttrib = Stack.Get( xoCatFontSize );
xoPos fontHeight = ComputeDimension( s.ParentContentBox.Height(), s.ParentContentBoxHasHeight, fontSizeAttrib.GetSize() );

float fontSizePxUnrounded = xoPosToReal( fontHeight );

// round font size to integer units
rnode->FontSizePx = (uint8) xoRound( fontSizePxUnrounded );

// Nothing prevents somebody from setting a font size to zero
if ( rnode->FontSizePx < 1 )
return;

bool subPixel = xoGlobal()->EnableSubpixelText && rnode->FontSizePx <= xoGlobal()->MaxSubpixelGlyphSize;
if ( subPixel )
rnode->Flags |= xoRenderDomText::FlagSubPixelGlyphs;

TempText.Node = &node;
TempText.RNode = rnode;
TempText.Words.clear_noalloc();
TempText.GlyphCount = 0;
GenerateTextWords( s, TempText );
if ( !TempText.GlyphsNeeded )
GenerateTextOutput( s, TempText );
}

void xoLayout::GenerateTextWords( NodeState& s, TextRunState& ts )
{
const char* txt = ts.Node->GetText();
xoGlyphCache* glyphCache = xoGlobal()->GlyphCache;
xoGlyphCacheKey key = MakeGlyphCacheKey( ts.RNode );

ts.GlyphsNeeded = false;
bool onSpace = false;
Word word;
word.Start = 0;
word.Width = 0;
for ( intp i = 0; true; i++ )
{
bool isSpace = IsSpace(txt[i]) || IsLinebreak(txt[i]);
if ( isSpace || onSpace || txt[i] == 0 )
{
word.End = (int32) i;
if ( word.End != word.Start )
ts.Words += word;
word.Start = (int32) i;
word.Width = 0;
onSpace = isSpace;
}
if ( txt[i] == 0 )
break;
key.Char = txt[i];
const xoGlyph* glyph = glyphCache->GetGlyph( key );
if ( !glyph )
{
ts.GlyphsNeeded = true;
GlyphsNeeded.insert( key );
continue;
}
if ( glyph->IsNull() )
{
// TODO: Handle missing glyph by drawing a rectangle or something
continue;
}
ts.GlyphCount++;
word.Width += xoRealToPos( glyph->MetricLinearHoriAdvance );
}
}

/*

This diagram was created using asciiflow (http://asciiflow.com/)

++  XXXXXXXXXXXX
XX |      X       X                    |             X
X  |      X       X                    |             X
X  |      X       X                    |             X
X  |      X       X                    |             X
ascender   X  |      XXXXXXXXX     XXXXXXXX       |             X
X  |      X       X     X      X       |             X
X  |      X       X     X      X       |             X lineheight
XX |      X       X     XXXXXXXX       |             X
++X++ baseline   X
XX |                    X              |             X
descender   X  |                    X              |             X
X  |                    X              |             X
XX |                    X              |             X
|                                   |             X
++  XXXXXXXXXXXX


*/
void xoLayout::GenerateTextOutput( NodeState& s, TextRunState& ts )
{
const char* txt = ts.Node->GetText();
xoGlyphCache* glyphCache = xoGlobal()->GlyphCache;
xoGlyphCacheKey key = MakeGlyphCacheKey( ts.RNode );
const xoFont* font = Fonts.GetByFontID( ts.RNode->FontID );

xoPos fontHeightRounded = xoRealToPos( ts.RNode->FontSizePx );
xoPos fontAscender = xoRealx256ToPos( font->Ascender_x256 * ts.RNode->FontSizePx );
xoTextAlignVertical valign = Stack.Get( xoCatText_Align_Vertical ).GetTextAlignVertical();

// if we add a "line-height" style then we'll want to multiply that by this
xoPos lineHeight = xoRealx256ToPos( ts.RNode->FontSizePx * font->LineHeight_x256 );
if ( xoGlobal()->RoundLineHeights )
lineHeight = xoPosRoundUp( lineHeight );

int fontHeightPx = ts.RNode->FontSizePx;
ts.RNode->Text.reserve( ts.GlyphCount );
bool parentHasWidth = s.ParentContentBoxHasWidth;
bool enableKerning = xoGlobal()->EnableKerning;

xoPos baseline = 0;
if ( valign == xoTextAlignVerticalTop || s.PosBaselineY == xoPosNULL )		baseline = s.PosY + fontAscender;
else if ( valign == xoTextAlignVerticalBaseline )							baseline = s.PosBaselineY;
else																		XOTODO;

// First text in the line defines the baseline
if ( s.PosBaselineY == xoPosNULL )
s.PosBaselineY = baseline;

for ( intp iword = 0; iword < ts.Words.size(); iword++ )
{
const Word& word = ts.Words[iword];
bool isSpace = word.Length() == 1 && txt[word.Start] == 32;
bool isNewline = word.Length() == 1 && txt[word.Start] == '\n';
bool over = parentHasWidth ? s.PosX + word.Width > s.ParentContentBox.Right : false;
if ( over )
{
bool futile = s.PosX == s.ParentContentBox.Left && word.Width > s.ParentContentBox.Width();
if ( !futile )
{
NextLine( s );
baseline = s.PosY + fontAscender;
// If the line break was performed for a space, then treat that space as "done"
if ( isSpace )
continue;
}
}

if ( isSpace )
{
s.PosX += xoRealx256ToPos( font->LinearHoriAdvance_Space_x256 ) * fontHeightPx;
}
else if ( isNewline )
{
NextLine( s );
baseline = s.PosY + fontAscender;
}
else
{
const xoGlyph* prevGlyph = nullptr;
for ( intp i = word.Start; i < word.End; i++ )
{
key.Char = txt[i];
const xoGlyph* glyph = glyphCache->GetGlyph( key );
__analysis_assume( glyph != nullptr );
if ( glyph->IsNull() )
continue;
if ( enableKerning && prevGlyph )
{
// Multithreading hazard here. I'm not sure whether FT_Get_Kerning is thread safe.
// Also, I have stepped inside there and I see it does a binary search. We would probably
// be better off caching the kerning for frequent pairs of glyphs in a hash table.
FT_Vector kern;
FT_Get_Kerning( font->FTFace, prevGlyph->FTGlyphIndex, glyph->FTGlyphIndex, FT_KERNING_UNSCALED, &kern );
xoPos kerning = ((kern.x * fontHeightPx) << xoPosShift) / font->FTFace->units_per_EM;
s.PosX += kerning;
}
ts.RNode->Text.Count++;
xoRenderCharEl& rtxt = ts.RNode->Text.back();
rtxt.Char = key.Char;
rtxt.X = s.PosX + xoRealx256ToPos( glyph->MetricLeftx256 );
rtxt.Y = baseline - xoRealToPos( glyph->MetricTop );			// rtxt.Y is the top of the glyph bitmap. glyph->MetricTop is the distance from the baseline to the top of the glyph
s.PosX += xoRealToPos( glyph->MetricLinearHoriAdvance );
s.PosMaxX = xoMax( s.PosMaxX, s.PosX );
prevGlyph = glyph;
}
}
s.PosMaxY = xoMax( s.PosMaxY, baseline - fontAscender + lineHeight );
}
}

void xoLayout::NextLine( NodeState& s )
{
s.PosX = s.ParentContentBox.Left;
s.PosY = s.PosMaxY;
s.PosBaselineY = xoPosNULL;
}

xoPoint xoLayout::PositionBlock( NodeState& s, xoBox& marginBox )
{
XOASSERTDEBUG(s.ParentContentBoxHasWidth);

xoPoint offset(0,0);

// Going to next line is futile if this block is as far to the left as possible
const bool futile = marginBox.Left == s.ParentContentBox.Left;
if ( marginBox.Right > s.ParentContentBox.Right && !futile )
{
// Block does not fit on this line, it must move onto the next line.
XOTRACE_LAYOUT_VERBOSE( "Layout block does not fit %d,%d\n", s.PosX, s.PosY );
NextLine( s );
offset = xoPoint( s.PosX - marginBox.Left, s.PosY - marginBox.Top );
marginBox.Offset( offset.X, offset.Y );
}
else
{
XOTRACE_LAYOUT_VERBOSE( "Layout block fits %d,%d\n", s.PosX, s.PosY );
}
s.PosX = marginBox.Right;
return offset;
}

void xoLayout::OffsetRecursive( xoRenderDomNode* rnode, xoPoint offset )
{
rnode->Pos.Offset( offset );
for ( intp i = 0; i < rnode->Children.size(); i++ )
{
if ( rnode->Children[i]->Tag == xoTagText )
{
xoRenderDomText* txt = static_cast<xoRenderDomText*>(rnode->Children[i]);
for ( intp j = 0; j < txt->Text.size(); j++ )
{
txt->Text[j].X += offset.X;
txt->Text[j].Y += offset.Y;
}
}
else
{
xoRenderDomNode* node = static_cast<xoRenderDomNode*>(rnode->Children[i]);
OffsetRecursive( node, offset );
}
}
}

bool xoLayout::IsSpace( int ch )
{
return ch == 32;
}

bool xoLayout::IsLinebreak( int ch )
{
return ch == '\r' || ch == '\n';
}

xoGlyphCacheKey	xoLayout::MakeGlyphCacheKey( xoRenderDomText* rnode )
{
uint8 glyphFlags = rnode->IsSubPixel() ? xoGlyphFlag_SubPixel_RGB : 0;
return xoGlyphCacheKey( rnode->FontID, 0, rnode->FontSizePx, glyphFlags );
}

void xoLayout::RenderGlyphsNeeded()
{
for ( auto it = GlyphsNeeded.begin(); it != GlyphsNeeded.end(); it++ )
xoGlobal()->GlyphCache->RenderGlyph( *it );
GlyphsNeeded.clear();
}

xoPos xoLayout::ComputeDimension( xoPos container, bool isContainerDefined, xoStyleCategories cat )
{
return ComputeDimension( container, isContainerDefined, Stack.Get( cat ).GetSize() );
}

xoPos xoLayout::ComputeDimension( xoPos container, bool isContainerDefined, xoSize size )
{
switch ( size.Type )
{
case xoSize::NONE: return xoPosNULL;
case xoSize::PX: return xoRealToPos( size.Val );
case xoSize::PT: return xoRealToPos( size.Val * PtToPixel );
case xoSize::EP: return xoRealToPos( size.Val * EpToPixel );
case xoSize::PERCENT:
if ( container == xoPosNULL || !isContainerDefined )
return xoPosNULL;
else
return xoPos((float) container * (size.Val * 0.01f));
default: XOPANIC("Unrecognized size type"); return 0;
}
}

xoBox xoLayout::ComputeSpecifiedPosition( const NodeState& s )
{
//xoBox reference = s.PositionedAncestor;
xoBox reference = s.ParentContentBox;
xoBox box = reference;
bool refWidthDefined = s.ParentContentBoxHasWidth;
bool refHeightDefined = s.ParentContentBoxHasHeight;
auto left = Stack.Get( xoCatLeft );
auto right = Stack.Get( xoCatRight );
auto top = Stack.Get( xoCatTop );
auto bottom = Stack.Get( xoCatBottom );
auto width = Stack.Get( xoCatWidth );
auto height = Stack.Get( xoCatHeight );
if ( !left.IsNull() )	box.Left = reference.Left + ComputeDimension( reference.Width(), refWidthDefined, left.GetSize() );
if ( !right.IsNull() )	box.Right = reference.Right + ComputeDimension( reference.Width(), refWidthDefined, right.GetSize() );
if ( !top.IsNull() )	box.Top = reference.Top + ComputeDimension( reference.Height(), refHeightDefined, top.GetSize() );
if ( !bottom.IsNull() )	box.Bottom = reference.Bottom + ComputeDimension( reference.Height(), refHeightDefined, bottom.GetSize() );
if ( !width.IsNull() && !left.IsNull() && right.IsNull() ) box.Right = box.Left + ComputeDimension( reference.Width(), refWidthDefined, width.GetSize() );
if ( !width.IsNull() && left.IsNull() && !right.IsNull() ) box.Left = box.Right - ComputeDimension( reference.Width(), refWidthDefined, width.GetSize() );
if ( !height.IsNull() && !top.IsNull() && bottom.IsNull() ) box.Bottom = box.Top + ComputeDimension( reference.Height(), refHeightDefined, height.GetSize() );
if ( !height.IsNull() && top.IsNull() && !bottom.IsNull() ) box.Top = box.Bottom - ComputeDimension( reference.Height(), refHeightDefined, height.GetSize() );
return box;
}

void xoLayout::ComputeRelativeOffset( const NodeState& s, xoBox& box )
{
XOTODO;
//auto left = Stack.Get( xoCatLeft );
//auto top = Stack.Get( xoCatTop );
//if ( !left.IsNull() )		box.Left += ComputeDimension( s.ParentContentBox.Width(), s.ParentContentBoxHasWidth, left.GetSize() );
//if ( !top.IsNull() )		box.Top += ComputeDimension( s.ParentContentBox.Height(), s.ParentContentBoxHasHeight, top.GetSize() );
}

xoBox xoLayout::ComputeBox( xoBox container, bool widthDefined, bool heightDefined, xoStyleCategories cat )
{
return ComputeBox( container, widthDefined, heightDefined, Stack.GetBox( cat ) );
}

xoBox xoLayout::ComputeBox( xoBox container, bool widthDefined, bool heightDefined, xoStyleBox box )
{
xoBox b;
b.Left = ComputeDimension( container.Width(), widthDefined, box.Left );
b.Right = ComputeDimension( container.Width(), widthDefined, box.Right );
b.Top = ComputeDimension( container.Height(), heightDefined, box.Top );
b.Bottom = ComputeDimension( container.Height(), heightDefined, box.Bottom );
return b;
}


/* This is called serially.

Why do we perform layout in multiple passes, loading all missing glyphs at the end of each pass?
The reason is because we eventually want to be able to parallelize layout.

Missing glyphs are a once-off cost (ie once per application instance),
so it's not worth trying to use a mutable glyph cache.

*/
void xoLayout2::Layout( const xoDoc& doc, u32 docWidth, u32 docHeight, xoRenderDomNode& root, xoPool* pool )
{
Doc = &doc;
DocWidth = docWidth;
DocHeight = docHeight;
Pool = pool;
Stack.Initialize( Doc, Pool );
ChildOutStack.Init( 1024 * 1024 );
LineBoxStack.Init( 1024 * 1024 );
Fonts = xoGlobal()->FontStore->GetImmutableTable();
SnapBoxes = xoGlobal()->SnapBoxes;
SnapSubpixelHorzText = xoGlobal()->SnapSubpixelHorzText;

while ( true )
{
LayoutInternal( root );

if ( GlyphsNeeded.size() == 0 )
{
XOTRACE_LAYOUT_VERBOSE( "Layout done\n" );
break;
}
else
{
XOTRACE_LAYOUT_VERBOSE( "Layout done (but need another pass for missing glyphs)\n" );
RenderGlyphsNeeded();
}
}
}

void xoLayout2::RenderGlyphsNeeded()
{
for ( auto it = GlyphsNeeded.begin(); it != GlyphsNeeded.end(); it++ )
xoGlobal()->GlyphCache->RenderGlyph( *it );
GlyphsNeeded.clear();
}

void xoLayout2::LayoutInternal( xoRenderDomNode& root )
{
PtToPixel = 1.0;	// TODO
EpToPixel = xoGlobal()->EpToPixel;

XOTRACE_LAYOUT_VERBOSE( "Layout 1\n" );

Pool->FreeAll();
root.Children.clear();
Stack.Reset();

XOTRACE_LAYOUT_VERBOSE( "Layout 2\n" );

LayoutInput in;
in.ParentWidth = xoIntToPos( DocWidth );
in.ParentHeight = xoIntToPos( DocHeight );
in.OuterBaseline = xoPosNULL;

LayoutOutput out;

XOTRACE_LAYOUT_VERBOSE( "Layout 3 DocBox = %d,%d,%d,%d\n", s.ParentContentBox.Left, s.ParentContentBox.Top, s.ParentContentBox.Right, s.ParentContentBox.Bottom );

RunNode( Doc->Root, in, out, &root );
}

void xoLayout2::RunNode( const xoDomNode& node, const LayoutInput& in, LayoutOutput& out, xoRenderDomNode* rnode )
{
XOTRACE_LAYOUT_VERBOSE( "Layout (%d) Run 1\n", node.GetInternalID() );
xoStyleResolver::ResolveAndPush( Stack, &node );
rnode->SetStyle( Stack );

XOTRACE_LAYOUT_VERBOSE( "Layout (%d) Run 2\n", node.GetInternalID() );
rnode->InternalID = node.GetInternalID();

xoBoxSizeType boxSizing = Stack.Get( xoCatBoxSizing ).GetBoxSizing();
xoPos borderRadius = ComputeDimension( 0, xoCatBorderRadius );
xoPos contentWidth = ComputeDimension( in.ParentWidth, xoCatWidth );
xoPos contentHeight = ComputeDimension( in.ParentHeight, xoCatHeight );
xoBox margin = ComputeBox( in.ParentWidth, in.ParentHeight, xoCatMargin_Left );		// it may be wise to disallow percentage sizing here
xoBox padding = ComputeBox( in.ParentWidth, in.ParentHeight, xoCatPadding_Left );	// same here
xoBox border = ComputeBox( in.ParentWidth, in.ParentHeight, xoCatBorder_Left );		// and here

// It might make for less arithmetic if we work with marginBoxWidth and marginBoxHeight instead of contentBoxWidth and contentBoxHeight. We'll see.

// This box holds the offsets from the 4 sides of our origin, to our content box. (Our origin is our parent's content box, but since it's relative here, it starts at 0,0)
xoBox toContent;
toContent.Left = margin.Left + border.Left + padding.Left;
toContent.Right = margin.Right + border.Right + padding.Right;
toContent.Top = margin.Top + border.Top + padding.Top;
toContent.Bottom = margin.Bottom + border.Bottom + padding.Bottom;

if ( boxSizing == xoBoxSizeContent ) {}
else if ( boxSizing == xoBoxSizeBorder )
{
if ( IsDefined(contentWidth) )	contentWidth -= border.Left + border.Right + padding.Left + padding.Right;
if ( IsDefined(contentHeight) )	contentHeight -= border.Top + border.Bottom + padding.Top + padding.Bottom;
}
else if ( boxSizing == xoBoxSizeMargin )
{
if ( IsDefined(contentWidth) )	contentWidth -= margin.Left + margin.Right + border.Left + border.Right + padding.Left + padding.Right;
if ( IsDefined(contentHeight) )	contentHeight -= margin.Top + margin.Bottom + border.Top + border.Bottom + padding.Top + padding.Bottom;
}

if ( SnapBoxes )
{
if ( IsDefined(contentWidth) )	contentWidth = xoPosRoundUp( contentWidth );
if ( IsDefined(contentHeight) )	contentHeight = xoPosRoundUp( contentHeight );
}

xoPos autoWidth = 0;
xoPos autoHeight = 0;
xoPos outerBaseline = IsDefined(in.OuterBaseline) ? in.OuterBaseline - toContent.Top : xoPosNULL;

// If we don't know our width and height yet then we need to delay bindings until our first pass is done
// The buffer size of 16 here is thumbsuck. One can't make it too big, because this is a recursive function.
// -- I first tried to have an optimized case for binding during first pass, but I have given up on that.
// -- One could revisit it once the design is nailed down.
xoLifoVector<LayoutOutput> outs( ChildOutStack );
outs.AddN( node.ChildCount() );

xoLifoVector<LineBox> lineBoxes( LineBoxStack );
lineBoxes.Push( LineBox::Make( xoPosNULL, -1, INT32MAX ) );

FlowState flow;
flow.PosMajor = 0;
flow.PosMinor = 0;
flow.MajorMax = 0;
flow.NumLines = 0;

for ( intp i = 0; i < node.ChildCount(); i++ )
{
const xoDomEl* c = node.ChildByIndex( i );
LayoutInput cin;
LayoutOutput cout;
cin.OuterBaseline = IsDefined(outerBaseline) ? outerBaseline : lineBoxes.Back().InnerBaseline;
cin.ParentWidth = contentWidth;
cin.ParentHeight = contentHeight;
xoPoint offset(0,0);
int nlines = flow.NumLines;
bool breakBefore = false;
if ( c->GetTag() == xoTagText )
{
xoRenderDomText* rchildTxt = new (Pool->AllocT<xoRenderDomText>(false)) xoRenderDomText( c->GetInternalID(), Pool );
rnode->Children += rchildTxt;
RunText( *static_cast<const xoDomText*>(c), cin, cout, rchildTxt );
breakBefore = FlowBreakBefore( cout, flow );
offset += FlowRun( cin, cout, flow, rchildTxt );
// Text elements cannot choose their layout. They are forced to start in the top-left of their parent, and perform text layout inside that space.
}
else
{
xoRenderDomNode* rchildNode = new (Pool->AllocT<xoRenderDomNode>(false)) xoRenderDomNode( c->GetInternalID(), c->GetTag(), Pool );
rnode->Children += rchildNode;
RunNode( *static_cast<const xoDomNode*>(c), cin, cout, rchildNode );
breakBefore = FlowBreakBefore( cout, flow );
offset += FlowRun( cin, cout, flow, rchildNode );
}
outs[i] = cout;
if ( flow.NumLines != nlines && breakBefore )
{
// Create a new linebox BEFORE adding this child's state
lineBoxes.Back().LastChild = int(i - 1);
lineBoxes += LineBox::Make( xoPosNULL, -1, INT32MAX );
}
if ( IsNull(lineBoxes.Back().InnerBaseline) && IsDefined(cout.NodeBaseline) )
{
lineBoxes.Back().InnerBaseline = cout.NodeBaseline + offset.Y;
lineBoxes.Back().InnerBaselineDefinedBy = (int) i;
}
if ( flow.NumLines != nlines && !breakBefore )
{
// Create a new linebox AFTER adding this child's state
lineBoxes.Back().LastChild = (int) i;
lineBoxes += LineBox::Make( xoPosNULL, -1, INT32MAX );
}
autoWidth = xoMax( autoWidth, flow.PosMinor );
autoHeight = xoMax( autoHeight, flow.MajorMax );
}

if ( IsNull(contentWidth) ) contentWidth = SnapBoxes ? xoPosRoundUp(autoWidth) : autoWidth;
if ( IsNull(contentHeight) ) contentHeight = SnapBoxes ?  xoPosRoundUp(autoHeight) : autoHeight;

// Apply bindings
{
int iLineBox = 0;
LayoutInput cin;
cin.OuterBaseline = IsDefined(outerBaseline) ? outerBaseline : lineBoxes[iLineBox].InnerBaseline;
cin.ParentWidth = contentWidth;
cin.ParentHeight = contentHeight;
for ( intp i = 0; i < node.ChildCount(); i++ )
{
const xoDomEl* c = node.ChildByIndex( i );
xoPoint offset(0,0);
if ( c->GetTag() != xoTagText )
offset = PositionChildFromBindings( cin, outs[i], rnode->Children[i] );
if ( i == lineBoxes[iLineBox].InnerBaselineDefinedBy )
lineBoxes[iLineBox].InnerBaseline += offset.Y;
if ( lineBoxes[iLineBox].LastChild == i )
iLineBox++;
}
}

rnode->Pos = xoBox( 0, 0, contentWidth, contentHeight ).OffsetBy( toContent.Left, toContent.Top );
rnode->Style.BackgroundColor = Stack.Get( xoCatBackground ).GetColor();
rnode->Style.BorderRadius = xoPosToReal( borderRadius );
rnode->Style.BorderSize = border;
rnode->Style.Padding = padding;
rnode->Style.BorderColor = Stack.Get( xoCatBorderColor_Left ).GetColor();

out.NodeBaseline = IsDefined(lineBoxes[0].InnerBaseline) ? lineBoxes[0].InnerBaseline + toContent.Top : xoPosNULL;
out.NodeWidth = contentWidth + border.Left + border.Right + margin.Left + margin.Right + padding.Left + padding.Right;
out.NodeHeight = contentHeight + border.Top + border.Bottom + margin.Top + margin.Bottom + padding.Top + padding.Bottom;
out.Binds = ComputeBinds();
out.Break = Stack.Get( xoCatBreak ).GetBreakType();
//out.Position = Stack.Get( xoCatPosition ).GetPositionType();

Stack.StackPop();
}

void xoLayout2::RunText( const xoDomText& node, const LayoutInput& in, LayoutOutput& out, xoRenderDomText* rnode )
{
XOTRACE_LAYOUT_VERBOSE( "Layout text (%d) Run 1\n", node.GetInternalID() );
rnode->InternalID = node.GetInternalID();
rnode->SetStyle( Stack );

XOTRACE_LAYOUT_VERBOSE( "Layout text (%d) Run 2\n", node.GetInternalID() );

rnode->FontID = Stack.Get( xoCatFontFamily ).GetFont();

xoStyleAttrib fontSizeAttrib = Stack.Get( xoCatFontSize );
xoPos fontHeight = ComputeDimension( in.ParentHeight, fontSizeAttrib.GetSize() );

float fontSizePxUnrounded = xoPosToReal( fontHeight );

// round font size to integer units
rnode->FontSizePx = (uint8) xoRound( fontSizePxUnrounded );

out.NodeWidth = 0;
out.NodeHeight = 0;
out.NodeBaseline = 0;

// Nothing prevents somebody from setting a font size to zero
if ( rnode->FontSizePx < 1 )
return;

bool subPixel = xoGlobal()->EnableSubpixelText && rnode->FontSizePx <= xoGlobal()->MaxSubpixelGlyphSize;
if ( subPixel )
rnode->Flags |= xoRenderDomText::FlagSubPixelGlyphs;

TempText.Node = &node;
TempText.RNode = rnode;
TempText.Words.clear_noalloc();
TempText.GlyphCount = 0;
//TempText.FontWidthScale = 1.08f;	// Verdana looks a lot better with an extra 8%
//TempText.FontWidthScale = 1.05f;
TempText.FontWidthScale = 1.0f;
GenerateTextWords( TempText );
if ( !TempText.GlyphsNeeded )
GenerateTextOutput( in, out, TempText );
}

/*

This diagram was created using asciiflow (http://asciiflow.com/)

++  XXXXXXXXXXXX
XX |      X       X                    |             X
X  |      X       X                    |             X
X  |      X       X                    |             X
X  |      X       X                    |             X
ascender   X  |      XXXXXXXXX     XXXXXXXX       |             X
X  |      X       X     X      X       |             X
X  |      X       X     X      X       |             X lineheight
XX |      X       X     XXXXXXXX       |             X
++X++ baseline   X
XX |                    X              |             X
descender   X  |                    X              |             X
X  |                    X              |             X
XX |                    X              |             X
|                                   |             X
++  XXXXXXXXXXXX


*/
void xoLayout2::GenerateTextOutput( const LayoutInput& in, LayoutOutput& out, TextRunState& ts )
{
const char* txt = ts.Node->GetText();
xoGlyphCache* glyphCache = xoGlobal()->GlyphCache;
xoGlyphCacheKey key = MakeGlyphCacheKey( ts.RNode );
const xoFont* font = Fonts.GetByFontID( ts.RNode->FontID );

xoPos fontHeightRounded = xoRealToPos( ts.RNode->FontSizePx );
xoPos fontAscender = xoRealx256ToPos( font->Ascender_x256 * ts.RNode->FontSizePx );
//xoTextAlignVertical valign = Stack.Get( xoCatText_Align_Vertical ).GetTextAlignVertical();

// if we add a "line-height" style then we'll want to multiply that by this
xoPos lineHeight = xoRealx256ToPos( ts.RNode->FontSizePx * font->LineHeight_x256 );
if ( xoGlobal()->RoundLineHeights )
lineHeight = xoPosRoundUp( lineHeight );

int fontHeightPx = ts.RNode->FontSizePx;
ts.RNode->Text.reserve( ts.GlyphCount );
bool parentHasWidth = IsDefined(in.ParentWidth);
bool enableKerning = xoGlobal()->EnableKerning;

//xoPos baseline = 0;
//if ( valign == xoTextAlignVerticalTop || s.PosBaselineY == xoPosNULL )		baseline = s.PosY + fontAscender;
//else if ( valign == xoTextAlignVerticalBaseline )							baseline = s.PosBaselineY;
//else																		XOTODO;

// First text in the line defines the baseline
//if ( s.PosBaselineY == xoPosNULL )
//	s.PosBaselineY = baseline;
if ( strcmp(txt, "world") == 0 )
int abc = 123;

xoPos posX = 0;
xoPos posMaxX = 0;
xoPos posMaxY = 0;
//xoPos baseline = IsDefined(in.ParentBaseline) ? in.ParentBaseline : fontAscender;
xoPos baseline = fontAscender;
out.NodeBaseline = baseline;

for ( intp iword = 0; iword < ts.Words.size(); iword++ )
{
const Word& word = ts.Words[iword];
bool isSpace = word.Length() == 1 && txt[word.Start] == 32;
bool isNewline = word.Length() == 1 && txt[word.Start] == '\n';
//bool over = parentHasWidth ? s.PosX + word.Width > s.ParentContentBox.Right : false;
bool over = parentHasWidth ? posX + word.Width > in.ParentWidth : false;
if ( over )
{
bool futile = posX == 0;
if ( !futile )
{
//NextLine( s );
baseline += lineHeight;
posX = 0;
// If the line break was performed for a space, then treat that space as "done"
if ( isSpace )
continue;
}
}

if ( isSpace )
{
posX += xoRealx256ToPos( font->LinearHoriAdvance_Space_x256 ) * fontHeightPx;
}
else if ( isNewline )
{
//NextLine( s );
baseline += lineHeight;
posX = 0;
}
else
{
const xoGlyph* prevGlyph = nullptr;
for ( intp i = word.Start; i < word.End; i++ )
{
key.Char = txt[i];
const xoGlyph* glyph = glyphCache->GetGlyph( key );
__analysis_assume( glyph != nullptr );
if ( glyph->IsNull() )
continue;
if ( enableKerning && prevGlyph )
{
// Multithreading hazard here. I'm not sure whether FT_Get_Kerning is thread safe.
// Also, I have stepped inside there and I see it does a binary search. We would probably
// be better off caching the kerning for frequent pairs of glyphs in a hash table.
FT_Vector kern;
FT_Get_Kerning( font->FTFace, prevGlyph->FTGlyphIndex, glyph->FTGlyphIndex, FT_KERNING_UNSCALED, &kern );
xoPos kerning = ((kern.x * fontHeightPx) << xoPosShift) / font->FTFace->units_per_EM;
posX += kerning;
}
ts.RNode->Text.Count++;
xoRenderCharEl& rtxt = ts.RNode->Text.back();
rtxt.Char = key.Char;
rtxt.X = posX + xoRealx256ToPos( glyph->MetricLeftx256 );
rtxt.Y = baseline - xoRealToPos( glyph->MetricTop );			// rtxt.Y is the top of the glyph bitmap. glyph->MetricTop is the distance from the baseline to the top of the glyph
posX += HoriAdvance( glyph, ts );
posMaxX = xoMax( posMaxX, posX );
prevGlyph = glyph;
}
}
posMaxY = xoMax( posMaxY, baseline - fontAscender + lineHeight );
}

out.NodeWidth = posMaxX;
out.NodeHeight = posMaxY;
}

void xoLayout2::GenerateTextWords( TextRunState& ts )
{
const char* txt = ts.Node->GetText();
xoGlyphCache* glyphCache = xoGlobal()->GlyphCache;
xoGlyphCacheKey key = MakeGlyphCacheKey( ts.RNode );

ts.GlyphsNeeded = false;
bool onSpace = false;
Word word;
word.Start = 0;
word.Width = 0;
for ( intp i = 0; true; i++ )
{
bool isSpace = IsSpace(txt[i]) || IsLinebreak(txt[i]);
if ( isSpace || onSpace || txt[i] == 0 )
{
word.End = (int32) i;
if ( word.End != word.Start )
ts.Words += word;
word.Start = (int32) i;
word.Width = 0;
onSpace = isSpace;
}
if ( txt[i] == 0 )
break;
key.Char = txt[i];
const xoGlyph* glyph = glyphCache->GetGlyph( key );
if ( !glyph )
{
ts.GlyphsNeeded = true;
GlyphsNeeded.insert( key );
continue;
}
if ( glyph->IsNull() )
{
// TODO: Handle missing glyph by drawing a rectangle or something
continue;
}
ts.GlyphCount++;
word.Width += HoriAdvance( glyph, ts );
}
}

xoPoint xoLayout2::PositionChildFromBindings( const LayoutInput& cin, const LayoutOutput& cout, xoRenderDomEl* rchild )
{
xoPoint child, parent;
child.X = HBindOffset( cout.Binds.HChild, cout.NodeWidth );
child.Y = VBindOffset( cout.Binds.VChild, cout.NodeBaseline, cout.NodeHeight );
parent.X = HBindOffset( cout.Binds.HParent, cin.ParentWidth );
parent.Y = VBindOffset( cout.Binds.VParent, cin.OuterBaseline, cin.ParentHeight );
xoPoint offset( parent.X - child.X, parent.Y - child.Y );
rchild->Pos.Offset( offset );
return offset;
}

xoPos xoLayout2::ComputeDimension( xoPos container, xoStyleCategories cat )
{
return ComputeDimension( container, Stack.Get( cat ).GetSize() );
}

xoPos xoLayout2::ComputeDimension( xoPos container, xoSize size )
{
switch ( size.Type )
{
case xoSize::NONE: return xoPosNULL;
case xoSize::PX: return xoRealToPos( size.Val );
case xoSize::PT: return xoRealToPos( size.Val * PtToPixel );
case xoSize::EP: return xoRealToPos( size.Val * EpToPixel );
case xoSize::PERCENT:
if ( container == xoPosNULL )
return xoPosNULL;
else
return xoPos( xoRound((float) container * (size.Val * 0.01f)) ); // this might be sloppy floating point. Small rational percentages like 25% (1/4) ought to be preserved precisely.
default: XOPANIC("Unrecognized size type"); return 0;
}
}

xoBox xoLayout2::ComputeBox( xoPos containerWidth, xoPos containerHeight, xoStyleCategories cat )
{
return ComputeBox( containerWidth, containerHeight, Stack.GetBox( cat ) );
}

xoBox xoLayout2::ComputeBox( xoPos containerWidth, xoPos containerHeight, xoStyleBox box )
{
xoBox b;
b.Left = ComputeDimension( containerWidth, box.Left );
b.Right = ComputeDimension( containerWidth, box.Right );
b.Top = ComputeDimension( containerHeight, box.Top );
b.Bottom = ComputeDimension( containerHeight, box.Bottom );
return b;
}

xoLayout2::BindingSet xoLayout2::ComputeBinds()
{
xoHorizontalBindings left = Stack.Get( xoCatLeft ).GetHorizontalBinding();
xoHorizontalBindings hcenter = Stack.Get( xoCatHCenter ).GetHorizontalBinding();
xoHorizontalBindings right = Stack.Get( xoCatRight ).GetHorizontalBinding();

xoVerticalBindings top = Stack.Get( xoCatTop ).GetVerticalBinding();
xoVerticalBindings vcenter = Stack.Get( xoCatVCenter ).GetVerticalBinding();
xoVerticalBindings bottom = Stack.Get( xoCatBottom ).GetVerticalBinding();
xoVerticalBindings baseline = Stack.Get( xoCatBaseline ).GetVerticalBinding();

BindingSet binds = {xoHorizontalBindingNULL, xoHorizontalBindingNULL, xoVerticalBindingNULL, xoVerticalBindingNULL};

if ( left != xoHorizontalBindingNULL )		{ binds.HChild = xoHorizontalBindingLeft; binds.HParent = left; }
if ( hcenter != xoHorizontalBindingNULL )	{ binds.HChild = xoHorizontalBindingCenter; binds.HParent = hcenter; }
if ( right != xoHorizontalBindingNULL )		{ binds.HChild = xoHorizontalBindingRight; binds.HParent = right; }

if ( top != xoVerticalBindingNULL )			{ binds.VChild = xoVerticalBindingTop; binds.VParent = top; }
if ( vcenter != xoVerticalBindingNULL )		{ binds.VChild = xoVerticalBindingCenter; binds.VParent = vcenter; }
if ( bottom != xoVerticalBindingNULL )		{ binds.VChild = xoVerticalBindingBottom; binds.VParent = bottom; }
if ( baseline != xoVerticalBindingNULL )	{ binds.VChild = xoVerticalBindingBaseline; binds.VParent = baseline; }

return binds;
}

xoPos xoLayout2::HoriAdvance( const xoGlyph* glyph, const TextRunState& ts )
{
if ( SnapSubpixelHorzText )
return xoIntToPos( glyph->MetricHoriAdvance );
else
return xoRealToPos( glyph->MetricLinearHoriAdvance * ts.FontWidthScale );
}

xoPos xoLayout2::HBindOffset( xoHorizontalBindings bind, xoPos width )
{
switch ( bind )
{
case xoHorizontalBindingNULL:
case xoHorizontalBindingLeft:	return 0;
case xoHorizontalBindingCenter:	return width / 2;
case xoHorizontalBindingRight:	return width;
default:
XOASSERTDEBUG(false);
return 0;
}
}

xoPos xoLayout2::VBindOffset( xoVerticalBindings bind, xoPos baseline, xoPos height )
{
switch ( bind )
{
case xoVerticalBindingNULL:
case xoVerticalBindingTop:		return 0;
case xoVerticalBindingCenter:	return height / 2;
case xoVerticalBindingBottom:	return height;
case xoVerticalBindingBaseline:
if ( IsDefined(baseline) )
return baseline;
else
{
XOTRACE_LAYOUT_WARNING( "Undefined baseline used in alignment\n" );
return height;
}
default:
XOASSERTDEBUG(false);
return 0;
}
}

bool xoLayout2::IsSpace( int ch )
{
return ch == 32;
}

bool xoLayout2::IsLinebreak( int ch )
{
return ch == '\r' || ch == '\n';
}

xoGlyphCacheKey	xoLayout2::MakeGlyphCacheKey( xoRenderDomText* rnode )
{
uint8 glyphFlags = rnode->IsSubPixel() ? xoGlyphFlag_SubPixel_RGB : 0;
return xoGlyphCacheKey( rnode->FontID, 0, rnode->FontSizePx, glyphFlags );
}

void xoLayout2::FlowNewline( FlowState& flow )
{
flow.PosMinor = 0;
flow.PosMajor = flow.MajorMax;
flow.NumLines++;
}

bool xoLayout2::FlowBreakBefore( const LayoutOutput& cout, FlowState& flow )
{
if ( cout.GetBreak() == xoBreakBefore )
{
FlowNewline( flow );
return true;
}
return false;
}

xoPoint xoLayout2::FlowRun( const LayoutInput& cin, const LayoutOutput& cout, FlowState& flow, xoRenderDomEl* rendEl )
{
if ( IsDefined(cin.ParentWidth) )
{
bool over = flow.PosMinor + cout.NodeWidth > cin.ParentWidth;
bool futile = flow.PosMinor == 0;
if ( over && !futile )
FlowNewline( flow );
}
xoPoint offset( flow.PosMinor, flow.PosMajor );
rendEl->Pos.Offset( offset.X, offset.Y );
flow.PosMinor += cout.NodeWidth;
flow.MajorMax = xoMax( flow.MajorMax, flow.PosMajor + cout.NodeHeight );

if ( cout.GetBreak() == xoBreakAfter )
FlowNewline( flow );

return offset;
}


/*
xoTextLayout::xoTextLayout()
{
}

xoTextLayout::~xoTextLayout()
{
}

void xoTextLayout::GenerateBoxes( const xoDomText& node, xoRenderDomText* rnode )
{
}

*/


struct TempString
{
intp	Capacity;
intp	Len;
char*	Buf;
char	StaticBuf[256];

TempString()
{
Capacity = arraysize(StaticBuf);
Len = 0;
Buf = StaticBuf;
Buf[0] = 0;
}
~TempString()
{
if ( Buf != StaticBuf )
free( Buf );
}
void Add( char c )
{
if ( Len == Capacity - 1 )
{
if ( Capacity == arraysize(StaticBuf) )
{
Capacity *= 2;
Buf = (char*) xoMallocOrDie( Capacity );
memcpy( Buf, StaticBuf, Len );
}
else
{
Capacity *= 2;
Buf = (char*) xoReallocOrDie( Buf, Capacity );
}
}
Buf[Len++] = c;
}
void Terminate()
{
Buf[Len] = 0;
}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoString xoDocParser::Parse( const char* src, xoDomNode* target )
{
enum States
{
SText,
STagOpen,
STagClose,
SCompactClose,
SAttribs,
SAttribName,
SAttribBodyStart,
SAttribBodySingleQuote,
SAttribBodyDoubleQuote,
};

States s = SText;
intp pos = 0;
intp xStart = 0;
intp xEnd = 0;
intp txtStart = 0;
pvect<xoDomNode*> stack;
stack += target;

auto err = [&]( const char* msg ) -> xoString
{
intp start = xoMax<intp>( pos - 1, 0 );
xoString sample;
sample.Set( src + start, 10 );
return fmt( "Parse error at position %v (%v): %v", pos, sample.Z, msg );
};

auto newNode = [&]() -> xoString
{
if ( xEnd - xStart <= 0 ) return "Tag is empty";
intp i = 0;
for ( ; i < xoTagEND; i++ )
{
if ( EqNoCase(xoTagNames[i], src + xStart, xEnd - xStart) )
break;
}
if ( i == xoTagEND )
return xoString("Unrecognized tag ") + xoString( src + xStart, xEnd - xStart );
stack += stack.back()->AddNode( (xoTag) i );
return "";
};

auto newText = [&]() -> xoString
{
bool white = true;
intp escape = -1;
TempString str;
for ( intp i = txtStart; i < pos; i++ )
{
int c = src[i];
if ( escape != -1 )
{
if ( c == ';' )
{
intp len = i - escape;
if (		len == 2 && src[escape] == 'l' && src[escape + 1] == 't' ) str.Add( '<' );
else if (	len == 2 && src[escape] == 'g' && src[escape + 1] == 't' ) str.Add( '>' );
else if (	len == 3 && src[escape] == 'a' && src[escape + 1] == 'm' && src[escape + 2] == 'p' ) str.Add( '&' );
else return fmt( "Invalid escape sequence (%v)", xoString(src + escape, len).Z );
escape = -1;
}
}
else
{
bool w = IsWhite(c);
if ( c == '&' )				escape = i + 1;
else if ( w && white )		{}					// trim leading whitespace
else if ( c == '\r' )		{}					// ignore '\r'
else						str.Add( c );
white = white && w;
}
}
if ( escape != -1 )
return "Unfinished escape sequence";
// trim trailing whitespace
while ( str.Len != 0 && IsWhite(str.Buf[str.Len - 1]) )
str.Len--;
if ( str.Len != 0 )
{
str.Terminate();
stack.back()->AddText( str.Buf );
}
return "";
};

auto closeNodeCompact = [&]() -> xoString
{
if ( stack.size() == 1 )
return "Too many closing tags"; // not sure if this is reachable; suspect not.
stack.pop();
return "";
};

auto closeNode = [&]() -> xoString
{
if ( stack.size() == 1 )
return "Too many closing tags";
xoDomNode* top = stack.back();
if ( !EqNoCase(xoTagNames[top->GetTag()], src + xStart, xEnd - xStart) )
return fmt( "Cannot close %v here. Expected %v close.", xoString(src + xStart, xEnd - xStart).Z, xoTagNames[top->GetTag()] );
stack.pop();
return "";
};

auto setAttrib = [&]() -> xoString
{
if ( xEnd - xStart <= 0 ) return "Attribute name is empty"; // should be impossible to reach this, due to possible state transitions

xoDomNode* node = stack.back();
char buf[64];

intp bodyStart = xEnd + 2;
if ( EqNoCase("style", src + xStart, xEnd - xStart) )
{
if ( node->StyleParse( src + bodyStart, pos - bodyStart ) )
return "";
return xoString( "Invalid style: " ) + xoString( src + bodyStart, pos - bodyStart );
}
else if ( EqNoCase("class", src + xStart, xEnd - xStart) )
{
intp cstart = bodyStart;
for ( intp i = bodyStart; i <= pos; i++ )
{
if ( i == pos || IsWhite(src[i]) )
{
intp len = i - cstart;
if ( len > 0 )
{
if ( len < arraysize(buf) - 1 )
{
memcpy( buf, src + cstart, len );
buf[len] = 0;
node->AddClass( buf );
}
else
{
node->AddClass( xoString(src + cstart, i - cstart).Z );
}
}
cstart = i + 1;
}
}
return "";
}

return xoString("Unrecognized attribute ") + xoString( src + xStart, xEnd - xStart );
};

for ( ; src[pos]; pos++ )
{
int c = src[pos];
xoString e;
switch ( s )
{
case SText:
if ( c == '<' )						{ s = STagOpen; xStart = pos + 1; e = newText(); break; }
else								{ break; }
case STagOpen:
if ( IsWhite(c) )					{ s = SAttribs; xEnd = pos; e = newNode(); break; }
else if ( c == '/' )				{ s = STagClose; xStart = pos + 1; break; }
else if ( c == '>' )				{ s = SText; txtStart = pos + 1; xEnd = pos; e = newNode(); break; }
else if ( IsAlpha(c) )				{ break; }
else								{ return err( "Expected a tag name" ); }
case STagClose:
if ( c == '>' )						{ s = SText; txtStart = pos + 1; xEnd = pos; e = closeNode(); break; }
else if ( IsAlpha(c) )				{ break; }
else								{ return err( "Expected >" ); }
case SCompactClose:
if ( c == '>' )						{ s = SText; txtStart = pos + 1; e = closeNodeCompact(); break; }
else								{ return err( "Expected >" ); }
case SAttribs:
if ( IsWhite(c) )					{ break; }
else if ( IsAlpha(c) )				{ s = SAttribName; xStart = pos; break; }
else if ( c == '/' )				{ s = SCompactClose; break; }
else if ( c == '>' )				{ s = SText; txtStart = pos + 1; break; }
else								{ return err( "Expected attributes or >" ); }
case SAttribName:
if ( IsAlpha(c) )					{ break; }
else if ( c == '=' )				{ xEnd = pos; s = SAttribBodyStart; break; }
else								{ return err( "Expected attribute name or =" ); }
case SAttribBodyStart:
if ( c == '\'' )					{ s = SAttribBodySingleQuote; break; }
if ( c == '"' )						{ s = SAttribBodyDoubleQuote; break; }
else 								{ return err( "Expected \"" ); }
case SAttribBodySingleQuote:
if ( c == '\'' )					{ s = SAttribs; e = setAttrib(); break; }
case SAttribBodyDoubleQuote:
if ( c == '"' )						{ s = SAttribs; e = setAttrib(); break; }
}
if ( e != "" )
return err( e.Z );
}

if ( s != SText )
return err( "Unfinished" );

if ( stack.size() != 1 )
return err( "Unclosed tags" );

return "";
}

bool xoDocParser::IsWhite( int c )
{
return c == ' ' || c == '\t' || c == '\r' || c == '\n';
}

bool xoDocParser::IsAlpha( int c )
{
return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

bool xoDocParser::EqNoCase( const char* a, const char* b, intp bLen )
{
for ( intp i = 0; ; i++ )
{
if ( a[i] == 0 && i == bLen ) return true;
if ( a[i] == 0 && i < bLen ) return false;
if ( i == bLen ) return false;
int aa = a[i] >= 'a' && a[i] <= 'z' ? a[i] + 'A' - 'a' : a[i];
int bb = b[i] >= 'a' && b[i] <= 'z' ? b[i] + 'A' - 'a' : b[i];
if ( aa != bb ) return false;
}
// should be unreachable
XOASSERTDEBUG(false);
return false;
}


xoRenderBase::xoRenderBase()
{
TexIDOffset = 0;
}

xoRenderBase::~xoRenderBase()
{
}

void xoRenderBase::Ortho( xoMat4f &imat, double left, double right, double bottom, double top, double znear, double zfar )
{
xoMat4f m;
m.Zero();
double A = 2 / (right - left);
double B = 2 / (top - bottom);
double C = -2 / (zfar - znear);
double tx = -(right + left) / (right - left);
double ty = -(top + bottom) / (top - bottom);
double tz = -(zfar + znear) / (zfar - znear);
m.m(0,0) = (float) A;
m.m(1,1) = (float) B;
m.m(2,2) = (float) C;
m.m(3,3) = 1;
m.m(0,3) = (float) tx;
m.m(1,3) = (float) ty;
m.m(2,3) = (float) tz;
imat = imat * m;
}

void xoRenderBase::SurfaceLost_ForgetTextures()
{
TexIDOffset++;
if ( TexIDOffset >= xoGlobal()->MaxTextureID )
TexIDOffset = 0;
TexIDToNative.clear();
}

bool xoRenderBase::IsTextureValid( xoTextureID texID ) const
{
xoTextureID relativeID = texID - TEX_OFFSET_ONE - TexIDOffset;
return relativeID < (xoTextureID) TexIDToNative.size();
}

xoTextureID xoRenderBase::RegisterTexture( void* deviceTexID )
{
xoTextureID maxTexID = xoGlobal()->MaxTextureID;
xoTextureID id = TexIDOffset + (xoTextureID) TexIDToNative.size();
if ( id > maxTexID )
id -= maxTexID;

TexIDToNative += deviceTexID;
return id + TEX_OFFSET_ONE;
}

void* xoRenderBase::GetTextureDeviceHandle( xoTextureID texID ) const
{
xoTextureID absolute = texID - TEX_OFFSET_ONE - TexIDOffset;
if ( absolute >= (xoTextureID) TexIDToNative.size() )
{
XOPANIC( "xoRenderBase::GetTextureDeviceHandle: Invalid texture ID. Use IsTextureValid() to check if a texture is valid." );
return NULL;
}
return TexIDToNative[absolute];
}

void xoRenderBase::EnsureTextureProperlyDefined( xoTexture* tex, int texUnit )
{
XOASSERT( tex->TexWidth != 0 && tex->TexHeight != 0 );
XOASSERT( tex->TexFormat != xoTexFormatInvalid );
XOASSERT( texUnit < xoMaxTextureUnits );
}

std::string xoRenderBase::CommonShaderDefines()
{
std::string s;
s.append( fmt( "#define XO_GLYPH_ATLAS_SIZE %v\n", xoGlyphAtlasSize ).Z );
return s;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool xoRenderDummy::InitializeDevice( xoSysWnd& wnd )
{
return false;
}
void xoRenderDummy::DestroyDevice( xoSysWnd& wnd )
{
}
void xoRenderDummy::SurfaceLost()
{
}

bool xoRenderDummy::BeginRender( xoSysWnd& wnd )
{
return false;
}
void xoRenderDummy::EndRender( xoSysWnd& wnd )
{
}

void xoRenderDummy::PreRender()
{
}
void xoRenderDummy::PostRenderCleanup()
{
}

xoProgBase* xoRenderDummy::GetShader( xoShaders shader )
{
return NULL;
}
void xoRenderDummy::ActivateShader( xoShaders shader )
{
}

void xoRenderDummy::DrawQuad( const void* v )
{
}

bool xoRenderDummy::LoadTexture( xoTexture* tex, int texUnit )
{
return true;
}
bool xoRenderDummy::ReadBackbuffer( xoImage& image )
{
return false;
}


#if XO_BUILD_DIRECTX

#define CHECK_HR(hresult, msg) if (FAILED(hresult)) { XOTRACE("%s failed: 0x%08x\n", msg, hresult); return false; }

xoRenderDX::xoRenderDX()
{
memset( &D3D, 0, sizeof(D3D) );
FBWidth = FBHeight = 0;
AllProgs[0] = &PFill;
AllProgs[1] = &PRect;
AllProgs[2] = &PTextRGB;
AllProgs[3] = &PTextWhole;
static_assert(NumProgs == 4, "Add new shader here");
}

xoRenderDX::~xoRenderDX()
{
}

const char*	xoRenderDX::RendererName()
{
return "DirectX 11";
}

bool xoRenderDX::InitializeDevice( xoSysWnd& wnd )
{
if ( !InitializeDXDevice(wnd) )
return false;

if ( !InitializeDXSurface(wnd) )
return false;

return true;
}

bool xoRenderDX::InitializeDXDevice( xoSysWnd& wnd )
{
DXGI_SWAP_CHAIN_DESC swap;
memset( &swap, 0, sizeof(swap) );
swap.BufferDesc.Width = 0;
swap.BufferDesc.Height = 0;
swap.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
swap.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE;
swap.BufferDesc.Scaling = DXGI_MODE_SCALING_CENTERED;
if ( xoGlobal()->EnableVSync )
{
// This has no effect on windowed rendering. Also, it is dumb to assume 60 hz.
swap.BufferDesc.RefreshRate.Numerator = 1;
swap.BufferDesc.RefreshRate.Denominator = 60;
}
swap.SampleDesc.Count = 1;
swap.SampleDesc.Quality = 0;
swap.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
swap.BufferCount = 1;
swap.OutputWindow = wnd.SysWnd;
swap.Windowed = true;
swap.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
swap.Flags = 0;

HRESULT eCreate = D3D11CreateDeviceAndSwapChain(
NULL,
D3D_DRIVER_TYPE_HARDWARE,
NULL,
D3D11_CREATE_DEVICE_SINGLETHREADED,
NULL,
0,
D3D11_SDK_VERSION,
&swap,
&D3D.SwapChain,
&D3D.Device,
&D3D.FeatureLevel,
&D3D.Context
);

CHECK_HR(eCreate, "D3D11CreateDeviceAndSwapChain")

D3D11_RASTERIZER_DESC rast;
memset( &rast, 0, sizeof(rast) );
rast.FillMode = D3D11_FILL_SOLID;
rast.CullMode = D3D11_CULL_NONE;
rast.FrontCounterClockwise = TRUE; // The default DirectX value is FALSE, but we stick to the default OpenGL value which is CCW = Front
rast.DepthBias = 0;
rast.DepthBiasClamp = 0.0f;
rast.SlopeScaledDepthBias = 0.0f;
rast.DepthClipEnable = FALSE;
rast.ScissorEnable = FALSE;
rast.MultisampleEnable = FALSE;
rast.AntialiasedLineEnable = FALSE;

HRESULT eRast = D3D.Device->CreateRasterizerState( &rast, &D3D.Rasterizer );
CHECK_HR(eRast, "CreateRasterizerState");

D3D11_BLEND_DESC blend;
memset( &blend, 0, sizeof(blend) );
blend.AlphaToCoverageEnable = FALSE;
blend.IndependentBlendEnable = FALSE;
blend.RenderTarget[0].BlendEnable    = true;
blend.RenderTarget[0].SrcBlend       = D3D11_BLEND_SRC_ALPHA;
blend.RenderTarget[0].DestBlend      = D3D11_BLEND_INV_SRC_ALPHA;
blend.RenderTarget[0].BlendOp        = D3D11_BLEND_OP_ADD;
blend.RenderTarget[0].SrcBlendAlpha  = D3D11_BLEND_SRC_ALPHA;
blend.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
blend.RenderTarget[0].BlendOpAlpha   = D3D11_BLEND_OP_ADD;
blend.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
HRESULT eBlendNormal = D3D.Device->CreateBlendState( &blend, &D3D.BlendNormal );
CHECK_HR(eBlendNormal, "CreateBlendNormal");

memset( &blend, 0, sizeof(blend) );
blend.AlphaToCoverageEnable = FALSE;
blend.IndependentBlendEnable = FALSE;
blend.RenderTarget[0].BlendEnable    = true;
blend.RenderTarget[0].SrcBlend       = D3D11_BLEND_SRC1_COLOR;
blend.RenderTarget[0].DestBlend      = D3D11_BLEND_INV_SRC1_COLOR;
blend.RenderTarget[0].BlendOp        = D3D11_BLEND_OP_ADD;
blend.RenderTarget[0].SrcBlendAlpha  = D3D11_BLEND_ONE;
blend.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_INV_SRC_ALPHA;
blend.RenderTarget[0].BlendOpAlpha   = D3D11_BLEND_OP_ADD;
blend.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
HRESULT eBlendDual = D3D.Device->CreateBlendState( &blend, &D3D.BlendDual );
CHECK_HR(eBlendDual, "CreateBlendDual");

D3D11_SAMPLER_DESC sampler;
memset( &sampler, 0, sizeof(sampler) );
sampler.Filter = D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
sampler.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
sampler.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
sampler.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
sampler.MipLODBias = 0.0f;
sampler.MaxAnisotropy = 1;
sampler.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
sampler.BorderColor[0] = 0;
sampler.BorderColor[1] = 0;
sampler.BorderColor[2] = 0;
sampler.BorderColor[3] = 0;
sampler.MinLOD = 0;
sampler.MaxLOD = D3D11_FLOAT32_MAX;
HRESULT eSampler1 = D3D.Device->CreateSamplerState( &sampler, &D3D.SamplerLinear );
CHECK_HR(eSampler1, "CreateSamplerLinear");

sampler.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
HRESULT eSampler2 = D3D.Device->CreateSamplerState( &sampler, &D3D.SamplerPoint );
CHECK_HR(eSampler2, "CreateSamplerPoint");

return true;
}

bool xoRenderDX::InitializeDXSurface( xoSysWnd& wnd )
{
HRESULT hr = S_OK;

auto rect = wnd.GetRelativeClientRect();
FBWidth = rect.Width();
FBHeight = rect.Height();
if ( !WindowResized() )
return false;

if ( !CreateShaders() )
return false;

if ( !SetupBuffers() )
return false;

return true;
}

bool xoRenderDX::WindowResized()
{
HRESULT hr = S_OK;

if ( D3D.RenderTargetView != NULL )
{
D3D.Context->OMSetRenderTargets( 0, NULL, NULL );
D3D.RenderTargetView->Release();
D3D.RenderTargetView = NULL;
hr = D3D.SwapChain->ResizeBuffers( 0, FBWidth, FBHeight, DXGI_FORMAT_UNKNOWN, 0 );
CHECK_HR(hr, "SwapChain.ResizeBuffers");
}

// Get a buffer and create a render target view
ID3D11Texture2D* pBackBuffer = NULL;
hr = D3D.SwapChain->GetBuffer( 0, __uuidof(ID3D11Texture2D), (void**) &pBackBuffer );
CHECK_HR(hr, "SwapChain.GetBuffer");

hr = D3D.Device->CreateRenderTargetView( pBackBuffer, NULL, &D3D.RenderTargetView );
pBackBuffer->Release();
CHECK_HR(hr, "Device.CreateRenderTargetView");

D3D.Context->OMSetRenderTargets( 1, &D3D.RenderTargetView, NULL );

// Setup the viewport
D3D11_VIEWPORT vp;
vp.Width = (FLOAT) FBWidth;
vp.Height = (FLOAT) FBHeight;
vp.MinDepth = 0.0f;
vp.MaxDepth = 1.0f;
vp.TopLeftX = 0;
vp.TopLeftY = 0;
D3D.Context->RSSetViewports( 1, &vp );

return true;
}

bool xoRenderDX::CreateShaders()
{
for ( int i = 0; i < NumProgs; i++ )
{
if ( !CreateShader(AllProgs[i]) )
return false;
}
return true;
}

bool xoRenderDX::CreateShader( xoDXProg* prog )
{
std::string name = prog->Name();

std::string vert_src = CommonShaderDefines() + prog->VertSrc();
std::string frag_src = CommonShaderDefines() + prog->FragSrc();

// Vertex shader
ID3DBlob* vsBlob = NULL;
if ( !CompileShader( (name + "Vertex").c_str(), vert_src.c_str(), "vs_4_0", &vsBlob ) )
return false;

HRESULT hr = D3D.Device->CreateVertexShader( vsBlob->GetBufferPointer(), vsBlob->GetBufferSize(), NULL, &prog->Vert );
if ( FAILED(hr) )
{
XOTRACE( "CreateVertexShader failed (0x%08x) for %s", hr, (const char*) prog->Name() );
vsBlob->Release();
return false;
}

bool layoutOK = CreateVertexLayout( prog, vsBlob );
vsBlob->Release();
if ( !layoutOK )
return false;

// Pixel shader
ID3DBlob* psBlob = NULL;
if ( !CompileShader( (name + "Frag").c_str(), frag_src.c_str(), "ps_4_0", &psBlob ) )
return false;

hr = D3D.Device->CreatePixelShader( psBlob->GetBufferPointer(), psBlob->GetBufferSize(), NULL, &prog->Frag );
psBlob->Release();
if( FAILED(hr) )
{
XOTRACE( "CreatePixelShader failed (0x%08x) for %s", hr, (const char*) prog->Name() );
return false;
}

return true;
}

bool xoRenderDX::CreateVertexLayout( xoDXProg* prog, ID3DBlob* vsBlob )
{
xoVertexType vtype = prog->VertexType();

static_assert(xoVertexType_END == 3, "Create new vertex layout here");

// When I try to use DXGI_FORMAT_R8G8B8A8_UNORM_SRGB here, I get a failure without any indication as to what's wrong.
// OK.. so it is not supported as "Input assembler vertex buffer resources":
// http://www.gamedev.net/topic/643471-creatinputlayout-returns-a-null-pointer/
// http://msdn.microsoft.com/en-us/library/windows/desktop/ff471325%28v=vs.85%29.aspx
D3D11_INPUT_ELEMENT_DESC layouts[xoVertexType_END - 1][4] =
{
// xoVertexType_PTC
{
{ "POSITION",	0, DXGI_FORMAT_R32G32B32_FLOAT,		0, offsetof(xoVx_PTC,Pos),		D3D11_INPUT_PER_VERTEX_DATA, 0 },
{ "TEXCOORD",	0, DXGI_FORMAT_R32G32_FLOAT,		0, offsetof(xoVx_PTC,UV),		D3D11_INPUT_PER_VERTEX_DATA, 0 },
{ "COLOR",		0, DXGI_FORMAT_R8G8B8A8_UNORM,		0, offsetof(xoVx_PTC,Color),	D3D11_INPUT_PER_VERTEX_DATA, 0 },
},
// xoVertexType_PTCV4
{
{ "POSITION",	0, DXGI_FORMAT_R32G32B32_FLOAT,		0, offsetof(xoVx_PTCV4,Pos),	D3D11_INPUT_PER_VERTEX_DATA, 0 },
{ "TEXCOORD",	1, DXGI_FORMAT_R32G32_FLOAT,		0, offsetof(xoVx_PTCV4,UV),		D3D11_INPUT_PER_VERTEX_DATA, 0 },
{ "COLOR",		0, DXGI_FORMAT_R8G8B8A8_UNORM,		0, offsetof(xoVx_PTCV4,Color),	D3D11_INPUT_PER_VERTEX_DATA, 0 },
{ "TEXCOORD",	2, DXGI_FORMAT_R32G32B32A32_FLOAT,	0, offsetof(xoVx_PTCV4,V4),		D3D11_INPUT_PER_VERTEX_DATA, 0 },
},
};
int layoutSizes[xoVertexType_END - 1] =
{
3,	// PTC
4,	// PTCV4
};

static_assert(xoVertexType_NULL == 0, "xoVertexType_NULL = 0");
int index = vtype - 1;

HRESULT hr = D3D.Device->CreateInputLayout( layouts[index], layoutSizes[index], vsBlob->GetBufferPointer(), vsBlob->GetBufferSize(), &prog->VertLayout );
if ( FAILED(hr) )
{
XOTRACE( "Vertex layout for %s invalid (0x%08x)", (const char*) prog->Name(), hr );
return false;
}

return true;
}

DISABLE_CODE_ANALYSIS_WARNINGS_PUSH_USING_FAILED_CALL_VALUE

bool xoRenderDX::CompileShader( const char* name, const char* source, const char* shaderTarget, ID3DBlob** blob )
{
//D3D_SHADER_MACRO macros[1] = {
//	{NULL,NULL}
//};
uint32 flags1 = D3DCOMPILE_ENABLE_STRICTNESS | D3DCOMPILE_WARNINGS_ARE_ERRORS;
flags1 |= D3DCOMPILE_DEBUG;

ID3DBlob* err = NULL;
HRESULT hr = D3DCompile( source, strlen(source), name, NULL, NULL, "main", shaderTarget, flags1, 0, blob, &err );
if ( FAILED(hr) )
{
if ( err != NULL )
{
XOTRACE( "Shader %s compilation failed (0x%08x): %s\n", name, hr, (const char*) err->GetBufferPointer() );
err->Release();
}
else
XOTRACE( "Shader %s compilation failed (0x%08x)\n", name, hr );
return false;
}

return true;
}

DISABLE_CODE_ANALYSIS_WARNINGS_POP

bool xoRenderDX::SetupBuffers()
{
if ( NULL == (D3D.VertBuffer = CreateBuffer( sizeof(xoVx_PTCV4) * 4, D3D11_USAGE_DYNAMIC, D3D11_BIND_VERTEX_BUFFER, D3D11_CPU_ACCESS_WRITE, NULL )) )
return false;

uint16 quadIndices[4] = {0, 1, 3, 2};
if ( NULL == (D3D.QuadIndexBuffer = CreateBuffer( sizeof(quadIndices), D3D11_USAGE_IMMUTABLE, D3D11_BIND_INDEX_BUFFER, 0, quadIndices )) )
return false;

if ( NULL == (D3D.ShaderPerFrameConstants = CreateBuffer( sizeof(xoShaderPerFrame), D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, NULL )) )
return false;

if ( NULL == (D3D.ShaderPerObjectConstants = CreateBuffer( sizeof(xoShaderPerObject), D3D11_USAGE_DYNAMIC, D3D11_BIND_CONSTANT_BUFFER, D3D11_CPU_ACCESS_WRITE, NULL )) )
return false;

return true;
}

void xoRenderDX::DestroyDevice( xoSysWnd& wnd )
{
// free up all buffers etc
}

void xoRenderDX::SurfaceLost()
{
}

bool xoRenderDX::BeginRender( xoSysWnd& wnd )
{
xoBox rect = wnd.GetRelativeClientRect();
if ( rect.Width() != FBWidth || rect.Height() != FBHeight )
{
FBWidth = rect.Width();
FBHeight = rect.Height();
if ( !WindowResized() )
return false;
}

return true;
}

void xoRenderDX::EndRender( xoSysWnd& wnd )
{
HRESULT hr = D3D.SwapChain->Present( 0, 0 );
if (!SUCCEEDED(hr))
XOTRACE( "DirectX Present failed: 0x%08x", hr );

D3D.ActiveProgram = nullptr;

// TODO: Handle
//	DXGI_ERROR_DEVICE_REMOVED
//	DXGI_ERROR_DRIVER_INTERNAL_ERROR
// as described here: http://msdn.microsoft.com/en-us/library/windows/apps/dn458383.aspx "Handling device removed scenarios in Direct3D 11"
}

void xoRenderDX::PreRender()
{
D3D.Context->RSSetState( D3D.Rasterizer );

// Clear the back buffer
auto clear = xoGlobal()->ClearColor;
float clearColor[4] = {clear.r / 255.0f, clear.g / 255.0f, clear.b / 255.0f, clear.a / 255.0f};
clearColor[0] = xoSRGB2Linear( clear.r );
clearColor[1] = xoSRGB2Linear( clear.g );
clearColor[2] = xoSRGB2Linear( clear.b );
D3D.Context->ClearRenderTargetView( D3D.RenderTargetView, clearColor );

SetShaderFrameUniforms();
}

bool xoRenderDX::SetShaderFrameUniforms()
{
xoMat4f mvproj;
mvproj.Identity();
Ortho( mvproj, 0, FBWidth, FBHeight, 0, 0, 1 );
ShaderPerFrame.MVProj = mvproj.Transposed();
ShaderPerFrame.VPort_HSize = Vec2f( FBWidth / 2.0f, FBHeight / 2.0f );

D3D11_MAPPED_SUBRESOURCE sub;
if ( FAILED(D3D.Context->Map( D3D.ShaderPerFrameConstants, 0, D3D11_MAP_WRITE_DISCARD, 0, &sub )) )
return false;
memcpy( sub.pData, &ShaderPerFrame, sizeof(ShaderPerFrame) );
D3D.Context->Unmap( D3D.ShaderPerFrameConstants, 0 );

return true;
}

bool xoRenderDX::SetShaderObjectUniforms()
{
D3D11_MAPPED_SUBRESOURCE sub;
if ( FAILED(D3D.Context->Map( D3D.ShaderPerObjectConstants, 0, D3D11_MAP_WRITE_DISCARD, 0, &sub )) )
return false;
memcpy( sub.pData, &ShaderPerObject, sizeof(ShaderPerObject) );
D3D.Context->Unmap( D3D.ShaderPerObjectConstants, 0 );
D3D.Context->VSSetConstantBuffers( ConstantSlotPerObject, 1, &D3D.ShaderPerObjectConstants );
D3D.Context->PSSetConstantBuffers( ConstantSlotPerObject, 1, &D3D.ShaderPerObjectConstants );
return true;
}

ID3D11Buffer* xoRenderDX::CreateBuffer( size_t sizeBytes, D3D11_USAGE usage, D3D11_BIND_FLAG bind, uint cpuAccess, const void* initialContent )
{
ID3D11Buffer* buffer = nullptr;
D3D11_BUFFER_DESC bd;
memset( &bd, 0, sizeof(bd) );
bd.ByteWidth = (UINT) sizeBytes;
bd.Usage = usage;
bd.BindFlags = bind;
bd.CPUAccessFlags = cpuAccess;
D3D11_SUBRESOURCE_DATA sub;
sub.pSysMem = initialContent;
sub.SysMemPitch = 0;
sub.SysMemSlicePitch = 0;
HRESULT hr = D3D.Device->CreateBuffer( &bd, initialContent != NULL ? &sub : NULL, &buffer );
if ( !SUCCEEDED(hr) )
{
buffer = nullptr;
XOTRACE( "CreateBuffer failed: %08x", hr );
}
return buffer;
}

bool xoRenderDX::CreateTexture2D( xoTexture* tex )
{
D3D11_TEXTURE2D_DESC desc;
memset( &desc, 0, sizeof(desc) );
desc.Width = tex->TexWidth;
desc.Height = tex->TexHeight;
desc.MipLevels = 1;					// 0 = generate all levels. 1 = just one level
desc.ArraySize = 1;
desc.SampleDesc.Count = 1;
desc.Usage = D3D11_USAGE_DEFAULT;
desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
desc.CPUAccessFlags = 0;
desc.MiscFlags = 0;
switch ( tex->TexFormat )
{
case xoTexFormatRGBA8:	desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; break;
case xoTexFormatGrey8:	desc.Format = DXGI_FORMAT_R8_UNORM; break;
default:				XOPANIC("Unrecognized texture format");
}
ID3D11Texture2D* dxTex = NULL;
HRESULT hr = D3D.Device->CreateTexture2D( &desc, NULL, &dxTex );
if ( !SUCCEEDED(hr) )
{
XOTRACE( "CreateTexture2D failed: %08x", hr );
return false;
}
Texture2D* t = new Texture2D();
t->Tex = dxTex;
hr = D3D.Device->CreateShaderResourceView( dxTex, NULL, &t->View );
if ( !SUCCEEDED(hr) )
{
XOTRACE( "CreateTexture2D.CreateShaderResourceView failed: %08x", hr );
delete t;
dxTex->Release();
return false;
}
tex->TexID = RegisterTextureDX( t );
tex->TexInvalidate();
return true;
}

void xoRenderDX::UpdateTexture2D( ID3D11Texture2D* dxTex, xoTexture* tex )
{
xoBox invRect = tex->TexInvalidRect;
xoBox fullRect = xoBox(0, 0, tex->TexWidth, tex->TexHeight);
invRect.ClampTo( fullRect );

if ( invRect.IsAreaZero() )
return;
D3D11_BOX box;
box.left = invRect.Left;
box.right = invRect.Right;
box.top = invRect.Top;
box.bottom = invRect.Bottom;
box.front = 0;
box.back = 1;
D3D.Context->UpdateSubresource( dxTex, 0, &box, tex->TexDataAt(invRect.Left, invRect.Top), tex->TexStride, 0 );
}

void xoRenderDX::PostRenderCleanup()
{
}

xoProgBase* xoRenderDX::GetShader( xoShaders shader )
{
switch ( shader )
{
case xoShaderFill:		return &PFill;
//case xoShaderFillTex:	return &PFillTex;
case xoShaderRect:		return &PRect;
case xoShaderTextRGB:	return &PTextRGB;
case xoShaderTextWhole:	return &PTextWhole;
default:
XOTODO;
return NULL;
}
}

void xoRenderDX::ActivateShader( xoShaders shader )
{
xoDXProg* p = (xoDXProg*) GetShader( shader );
if ( p == D3D.ActiveProgram )
return;

D3D.Context->VSSetShader( p->Vert, NULL, 0 );
D3D.Context->PSSetShader( p->Frag, NULL, 0 );
D3D.Context->IASetInputLayout( p->VertLayout );
D3D.Context->VSSetConstantBuffers( ConstantSlotPerFrame, 1, &D3D.ShaderPerFrameConstants );
D3D.Context->PSSetConstantBuffers( ConstantSlotPerFrame, 1, &D3D.ShaderPerFrameConstants );
D3D.ActiveProgram = p;

float blendFactors[4] = {0,0,0,0};
uint sampleMask = 0xffffffff;

if ( shader == xoShaderTextRGB )
D3D.Context->OMSetBlendState( D3D.BlendDual, blendFactors, sampleMask );
else
D3D.Context->OMSetBlendState( D3D.BlendNormal, blendFactors, sampleMask );

//D3D.Context->PSSetSamplers( 0, 1, &D3D.SamplerLinear );
D3D.Context->PSSetSamplers( 0, 1, &D3D.SamplerPoint );
}

void xoRenderDX::DrawQuad( const void* v )
{
SetShaderObjectUniforms();

const int nvert = 4;
const byte* vbyte = (const byte*) v;

// map vertex buffer with DISCARD
D3D11_MAPPED_SUBRESOURCE map;
memset( &map, 0, sizeof(map) );
HRESULT hr = D3D.Context->Map( D3D.VertBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &map );
if ( FAILED(hr) )
{
XOTRACE_RENDER( "Vertex buffer map failed: %d", hr);
return;
}

//int vertexSize = D3D.ActiveProgramInfo->VertexSize;
int vertexSize = (int) xoVertexSize( D3D.ActiveProgram->VertexType() );

memcpy( map.pData, v, nvert * vertexSize );
D3D.Context->Unmap( D3D.VertBuffer, 0 );

UINT stride = vertexSize;
UINT offset = 0;
D3D.Context->IASetVertexBuffers( 0, 1, &D3D.VertBuffer, &stride, &offset );
D3D.Context->IASetIndexBuffer( D3D.QuadIndexBuffer, DXGI_FORMAT_R16_UINT, 0 );
//D3D.Context->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
D3D.Context->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP );
D3D.Context->DrawIndexed( 4, 0, 0 );

//D3D.Context->IASetPrimitiveTopology( D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST );
//D3D.Context->Draw( 3, 0 );
}

bool xoRenderDX::LoadTexture( xoTexture* tex, int texUnit )
{
EnsureTextureProperlyDefined( tex, texUnit );

if ( !IsTextureValid( tex->TexID ) )
{
if ( !CreateTexture2D( tex ) )
return false;
}
Texture2D* mytex = GetTextureDX( tex->TexID );

UpdateTexture2D( mytex->Tex, tex );

D3D.Context->PSSetShaderResources( 0, 1, &mytex->View );

return true;
}

bool xoRenderDX::ReadBackbuffer( xoImage& image )
{
D3D11_TEXTURE2D_DESC desc;
memset( &desc, 0, sizeof(desc) );
desc.Width = FBWidth;
desc.Height = FBHeight;
desc.MipLevels = 1;					// 0 = generate all levels. 1 = just one level
desc.ArraySize = 1;
desc.SampleDesc.Count = 1;
desc.Usage = D3D11_USAGE_STAGING;
desc.BindFlags = 0;
desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
desc.MiscFlags = 0;
desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
ID3D11Texture2D* tempTex = NULL;
HRESULT hr = D3D.Device->CreateTexture2D( &desc, NULL, &tempTex );
if ( !SUCCEEDED(hr) )
{
XOTRACE( "CreateTexture2D for ReadBackBuffer failed: %08x", hr );
return false;
}

ID3D11Texture2D* backBuffer = NULL;
hr = D3D.SwapChain->GetBuffer( 0, __uuidof(ID3D11Texture2D), (void**) &backBuffer );
bool ok = false;
if ( SUCCEEDED(hr) )
{
D3D11_BOX srcBox = { 0, 0, 0, FBWidth, FBHeight, 1 };
D3D.Context->CopySubresourceRegion( tempTex, 0, 0, 0, 0, backBuffer, 0, &srcBox );
backBuffer->Release();

D3D11_MAPPED_SUBRESOURCE map;
if ( SUCCEEDED(D3D.Context->Map( tempTex, 0, D3D11_MAP_READ, 0, &map )) )
{
image.Alloc( xoTexFormatRGBA8, FBWidth, FBHeight );
for ( int i = 0; i < FBHeight; i++ )
memcpy( image.TexDataAtLine(i), (char*) map.pData + map.RowPitch * (uint) i, image.TexStride );
D3D.Context->Unmap( tempTex, 0 );
ok = true;
}
}

tempTex->Release();

return ok;
}


#endif

#if XO_BUILD_DIRECTX

xoDXProg::xoDXProg()
{
ResetBase();
}

xoDXProg::~xoDXProg()
{
}

void			xoDXProg::Reset()					{ ResetBase(); }
const char*		xoDXProg::VertSrc()					{ return NULL; }
const char*		xoDXProg::FragSrc()					{ return NULL; }
const char*		xoDXProg::Name()					{ return "<unnamed shader>"; }
void			xoDXProg::ResetBase()				{ Vert = NULL; Frag = NULL; VertLayout = NULL; }
bool			xoDXProg::LoadVariablePositions()	{ return false; }
uint32			xoDXProg::PlatformMask()			{ return xoPlatform_All; }
xoVertexType	xoDXProg::VertexType()				{ return xoVertexType_NULL; }

#endif


xoRenderResult xoRenderer::Render( xoImageStore* images, xoStringTable* strings, xoRenderBase* driver, xoRenderDomNode* root, int width, int height )
{
Driver = driver;
Images = images;
Strings = strings;

Driver->PreRender();

// This phase is probably worth parallelizing
RenderEl( xoPoint(0,0), root );
// After RenderNode we are serial again.

Driver->PostRenderCleanup();

bool needGlyphs = GlyphsNeeded.size() != 0;
RenderGlyphsNeeded();

return needGlyphs ? xoRenderResultNeedMore : xoRenderResultIdle;
}

void xoRenderer::RenderEl( xoPoint base, xoRenderDomEl* el )
{
if ( el->Tag == xoTagText )
RenderText( base, static_cast<xoRenderDomText*>(el) );
else
{
xoRenderDomNode* node = static_cast<xoRenderDomNode*>(el);
RenderNode( base, node );
xoPoint newBase = base + xoPoint( node->Pos.Left, node->Pos.Top );
for ( intp i = 0; i < node->Children.size(); i++ )
RenderEl( newBase, node->Children[i] );
}
}

void xoRenderer::RenderNode( xoPoint base, xoRenderDomNode* node )
{
// always shade rectangles well
const bool alwaysGoodRects = true;

xoStyleRender* style = &node->Style;
xoBox pos = node->Pos;
pos.Offset( base );
xoBoxF border = style->BorderSize.ToRealBox();
xoBoxF padding = style->Padding.ToRealBox();
float bottom = xoPosToReal( pos.Bottom ) + border.Bottom + padding.Bottom;
float top = xoPosToReal( pos.Top ) - border.Top - padding.Top;
float left = xoPosToReal( pos.Left ) - border.Left - padding.Left;
float right = xoPosToReal( pos.Right ) + border.Right + padding.Right;

float radius = style->BorderRadius;
bool useRectShader = alwaysGoodRects || radius != 0;

float width = right - left;
float height = bottom - top;
float mindim = xoMin(width, height);
mindim = xoMax(mindim, 0.0f);
radius = xoMin(radius, mindim / 2);

if ( mindim <= 0 )
return;

float padU = 0;
float padV = 0;
float pad = useRectShader ? 1.0f : 0.0f;
if ( pad != 0 )
{
padU = pad / width;
padV = pad / height;
}

xoVx_PTC corners[4];
corners[0].Pos = XOVEC3(left - pad, top - pad, 0);
corners[1].Pos = XOVEC3(left - pad, bottom + pad, 0);
corners[2].Pos = XOVEC3(right + pad, bottom + pad, 0);
corners[3].Pos = XOVEC3(right + pad, top - pad, 0);

corners[0].UV = XOVEC2(-padU, -padV);
corners[1].UV = XOVEC2(-padU, 1 + padV);
corners[2].UV = XOVEC2(1 + padU, 1 + padV);
corners[3].UV = XOVEC2(1 + padU, -padV);

//auto bg = style.Get( xoCatBackground );
//auto bgImage = style.Get( xoCatBackgroundImage );
xoColor bg = style->BackgroundColor;
const char* bgImage = Strings->GetStr( style->BackgroundImageID );
if ( bg.a != 0 )
{
for ( int i = 0; i < 4; i++ )
corners[i].Color = bg.GetRGBA();

if ( useRectShader )
{
Driver->ActivateShader( xoShaderRect );
Driver->ShaderPerObject.Box = xoVec4f( left, top, right, bottom );
//Driver->ShaderPerObject.Border = xoVec4f( border.Left, border.Top, border.Right, border.Bottom );
Driver->ShaderPerObject.Border = xoVec4f( border.Left + 0.5f, border.Top + 0.5f, border.Right + 0.5f, border.Bottom + 0.5f );
//Driver->ShaderPerObject.Border = xoVec4f( border.Left - 0.5f, border.Top - 0.5f, border.Right - 0.5f, border.Bottom - 0.5f );
Driver->ShaderPerObject.Radius = radius + 0.5f; // see the shader for an explanation of this 0.5
Driver->ShaderPerObject.BorderColor = style->BorderColor.GetVec4Linear();
Driver->DrawQuad( corners );
}
else
{
if ( bgImage[0] != 0 )
{
Driver->ActivateShader( xoShaderFillTex );
if ( !LoadTexture( Images->GetOrNull( bgImage ), 0 ) )
return;
Driver->DrawQuad( corners );
}
else
{
Driver->ActivateShader( xoShaderFill );
Driver->DrawQuad( corners );
}
}
}
}

void xoRenderer::RenderText( xoPoint base, xoRenderDomText* node )
{
bool subPixelGlyphs = node->Flags & xoRenderDomText::FlagSubPixelGlyphs;
for ( intp i = 0; i < node->Text.size(); i++ )
{
if ( subPixelGlyphs )
RenderTextChar_SubPixel( base, node, node->Text[i] );
else
RenderTextChar_WholePixel( base, node, node->Text[i] );
}
}

void xoRenderer::RenderTextChar_SubPixel( xoPoint base, xoRenderDomText* node, const xoRenderCharEl& txtEl )
{
xoGlyphCacheKey glyphKey( node->FontID, txtEl.Char, node->FontSizePx, xoGlyphFlag_SubPixel_RGB );
const xoGlyph* glyph = xoGlobal()->GlyphCache->GetGlyph( glyphKey );
if ( !glyph )
{
GlyphsNeeded.insert( glyphKey );
return;
}

xoTextureAtlas* atlas = xoGlobal()->GlyphCache->GetAtlasMutable( glyph->AtlasID );
float atlasScaleX = 1.0f / atlas->GetWidth();
float atlasScaleY = 1.0f / atlas->GetHeight();

float top = xoPosToReal( xoPosRound(base.Y + txtEl.Y) );
float left = xoPosToReal( base.X + txtEl.X );

// Our glyph has a single column on the left and right side, so that our clamped texture
// reads will pickup a zero when reading off beyond the edge of the glyph
int horzPad = 1;
int nonPaddedWidth = glyph->Width - horzPad * 2;

// Our texture (minus the padding) can be missing 1 or 2 columns on its right side,
// but our proper width in pixels DOES include those 1 or 2 missing columns (they are simply black).
// We clamp our texture reads to our freetype-rasterized limits, but the vertex coordinates we emit
// now to the GPU includes those 1 or 2 missing columns.
// This issue exists because freetype's bitmaps will never include a column of pure black on the left
// or right edge of the glyph.
int roundedWidth = (nonPaddedWidth + 2) / 3;

// We don't need to round our horizontal position to any fixed grid - the interpolation
// is correct regardless, and since we clobber all horizontal hinting, horizontal
// grid-fitting should have little effect.
//left = (float) floor(left * 3 + 0.5) / 3.0f;
//top = (float) floor(top + 0.5); -- vertical rounding has been moved to fixed point layout

// You cannot do this here - it needs to happen during layout (which it does indeed)
//if ( xoGlobal()->SnapSubpixelHorzText )
//	left = floor(left + 0.5f);

float right = left + roundedWidth;
float bottom = top + glyph->Height;

// We have to 'overdraw' on the left and right by 1 pixel, to ensure that we filter over the edges.
int overdraw = 1;
left -= overdraw;
right += overdraw;

xoVx_PTCV4 corners[4];
corners[0].Pos = XOVEC3(left, top, 0);
corners[1].Pos = XOVEC3(left, bottom, 0);
corners[2].Pos = XOVEC3(right, bottom, 0);
corners[3].Pos = XOVEC3(right, top, 0);

float u0 = (glyph->X + horzPad - overdraw * 3) * atlasScaleX;
float v0 = glyph->Y * atlasScaleY;
float u1 = (glyph->X + horzPad + (roundedWidth + overdraw) * 3) * atlasScaleX;
float v1 = (glyph->Y + glyph->Height) * atlasScaleY;

corners[0].UV = XOVEC2(u0, v0);
corners[1].UV = XOVEC2(u0, v1);
corners[2].UV = XOVEC2(u1, v1);
corners[3].UV = XOVEC2(u1, v0);

// Obviously our clamping is not affected by overdraw. It remains our absolute texel limits.
xoVec4f clamp;
clamp.x = (glyph->X + 0.5f) * atlasScaleX;
clamp.y = (glyph->Y + 0.5f) * atlasScaleY;
clamp.z = (glyph->X + glyph->Width - 0.5f) * atlasScaleX;
clamp.w = (glyph->Y + glyph->Height - 0.5f) * atlasScaleY;

uint32 color = node->Color.GetRGBA();

for ( int i = 0; i < 4; i++ )
{
corners[i].Color = color;
corners[i].V4 = clamp;
}

Driver->ActivateShader( xoShaderTextRGB );
if ( !LoadTexture( atlas, 0 ) )
return;
Driver->DrawQuad( corners );
}

void xoRenderer::RenderTextChar_WholePixel( xoPoint base, xoRenderDomText* node, const xoRenderCharEl& txtEl )
{
xoGlyphCacheKey glyphKey( node->FontID, txtEl.Char, node->FontSizePx, 0 );
const xoGlyph* glyph = xoGlobal()->GlyphCache->GetGlyph( glyphKey );
if ( !glyph )
{
GlyphsNeeded.insert( glyphKey );
return;
}

xoTextureAtlas* atlas = xoGlobal()->GlyphCache->GetAtlasMutable( glyph->AtlasID );
float atlasScaleX = 1.0f / atlas->GetWidth();
float atlasScaleY = 1.0f / atlas->GetHeight();

float top = xoPosToReal( base.Y + txtEl.Y );
float left = xoPosToReal( base.X + txtEl.X );

// a single pixel of padding is necessary to ensure that we're not short-sampling
// the edges of the glyphs
int pad = 1;

// We only use whole pixel rendering on high resolution devices, and glyph sizes, as measured
// in device pixels, are always high enough that it ends up being more important to have sub-pixel
// positioning than to render the glyphs without any resampling.
//
//                       Snapping On                                 Snapping Off
// Rendering             Crisper, because no resampling              Fuzzier, because of resampling
// Positioning           Text cannot be positioned sub-pixel         Text can be positioned with sub-pixel accuracy in X and Y

bool snapToWholePixels = false;
if ( snapToWholePixels )
{
left = (float) floor(left + 0.5f);
top = (float) floor(top + 0.5f);
}

left -= pad;
top -= pad;

float right = left + glyph->Width + pad * 2;
float bottom = top + glyph->Height + pad * 2;

xoVx_PTC corners[4];
corners[0].Pos = XOVEC3(left, top, 0);
corners[1].Pos = XOVEC3(left, bottom, 0);
corners[2].Pos = XOVEC3(right, bottom, 0);
corners[3].Pos = XOVEC3(right, top, 0);

float u0 = (glyph->X - pad) * atlasScaleX;
float v0 = (glyph->Y - pad) * atlasScaleY;
float u1 = (glyph->X + glyph->Width + pad * 2) * atlasScaleX;
float v1 = (glyph->Y + glyph->Height + pad * 2) * atlasScaleY;

corners[0].UV = XOVEC2(u0, v0);
corners[1].UV = XOVEC2(u0, v1);
corners[2].UV = XOVEC2(u1, v1);
corners[3].UV = XOVEC2(u1, v0);

uint32 color = node->Color.GetRGBA();

for ( int i = 0; i < 4; i++ )
corners[i].Color = color;

Driver->ActivateShader( xoShaderTextWhole );
if ( !LoadTexture( atlas, 0 ) )
return;
Driver->DrawQuad( corners );
}

void xoRenderer::RenderGlyphsNeeded()
{
for ( auto it = GlyphsNeeded.begin(); it != GlyphsNeeded.end(); it++ )
xoGlobal()->GlyphCache->RenderGlyph( *it );
GlyphsNeeded.clear();
}

bool xoRenderer::LoadTexture( xoTexture* tex, int texUnit )
{
if ( !Driver->LoadTexture(tex, texUnit) )
return false;

tex->TexValidate();
return true;
}

#if XO_BUILD_OPENGL

static bool GLIsBooted = false;

#ifndef GL_FRAMEBUFFER_SRGB
#define GL_FRAMEBUFFER_SRGB                 0x8DB9
#endif
#ifndef GL_RG
#define GL_RG                               0x8227
#endif
#ifndef GL_UNPACK_ROW_LENGTH
#define GL_UNPACK_ROW_LENGTH                0x0CF2
#endif
#ifndef GL_SRC1_COLOR
#define GL_SRC1_COLOR                       0x88F9
#endif
#ifndef GL_ONE_MINUS_SRC1_COLOR
#define GL_ONE_MINUS_SRC1_COLOR             0x88FA
#endif
#ifndef GL_ONE_MINUS_SRC1_ALPHA
#define GL_ONE_MINUS_SRC1_ALPHA             0x88FB
#endif

static const char* nu_GLSLPrefix = R"(
float fromSRGB_Component(float srgb)
{
float sRGB_Low	= 0.0031308;
float sRGB_a	= 0.055;

if (srgb <= 0.04045)
return srgb / 12.92;
else
return pow((srgb + sRGB_a) / (1.0 + sRGB_a), 2.4);
}

vec4 fromSRGB(vec4 c)
{
vec4 linear_c;
linear_c.r = fromSRGB_Component(c.r);
linear_c.g = fromSRGB_Component(c.g);
linear_c.b = fromSRGB_Component(c.b);
linear_c.a = c.a;
return linear_c;
}
)";

xoRenderGL::xoRenderGL()
{
#if XO_PLATFORM_WIN_DESKTOP
GLRC = NULL;
DC = NULL;
#endif
Have_Unpack_RowLength = false;
Have_sRGB_Framebuffer = false;
Have_BlendFuncExtended = false;
AllProgs[0] = &PRect;
AllProgs[1] = &PFill;
AllProgs[2] = &PFillTex;
AllProgs[3] = &PTextRGB;
AllProgs[4] = &PTextWhole;
//AllProgs[5] = &PCurve;
static_assert(NumProgs == 5, "Add your new shader here");
Reset();
}

xoRenderGL::~xoRenderGL()
{
}

void xoRenderGL::Reset()
{
for ( int i = 0; i < NumProgs; i++ )
AllProgs[i]->Reset();
memset( BoundTextures, 0, sizeof(BoundTextures) );
ActiveShader = xoShaderInvalid;
}

const char*	xoRenderGL::RendererName()
{
return "OpenGL";
}

#if XO_PLATFORM_WIN_DESKTOP

typedef BOOL (*_wglChoosePixelFormatARB) (HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats);

static void xoBootGL_FillPFD( PIXELFORMATDESCRIPTOR& pfd )
{
const DWORD flags = 0
| PFD_DRAW_TO_WINDOW	// support window
| PFD_SUPPORT_OPENGL	// support OpenGL
| PFD_DOUBLEBUFFER		// double buffer
| 0;

// Note that this must match the attribs used by wglChoosePixelFormatARB (I find that strange).
PIXELFORMATDESCRIPTOR base = {
sizeof(PIXELFORMATDESCRIPTOR),   // size of this pfd
1,                     // version number
flags,
PFD_TYPE_RGBA,         // RGBA type
24,                    // color depth
0, 0, 0, 0, 0, 0,      // color bits ignored
0,                     // alpha bits
0,                     // shift bit ignored
0,                     // no accumulation buffer
0, 0, 0, 0,            // accum bits ignored
16,                    // z-buffer
0,                     // no stencil buffer
0,                     // no auxiliary buffer
PFD_MAIN_PLANE,        // main layer
0,                     // reserved
0, 0, 0                // layer masks ignored
};

pfd = base;
}

static bool xoBootGL( HWND wnd )
{
HDC dc = GetDC( wnd );

// get the best available match of pixel format for the device context
PIXELFORMATDESCRIPTOR pfd;
xoBootGL_FillPFD( pfd );
int iPixelFormat = ChoosePixelFormat( dc, &pfd );

if ( iPixelFormat != 0 )
{
// make that the pixel format of the device context
BOOL setOK = SetPixelFormat(dc, iPixelFormat, &pfd);
HGLRC rc = wglCreateContext( dc );
wglMakeCurrent( dc, rc );
int wglLoad = wgl_LoadFunctions( dc );
int oglLoad = ogl_LoadFunctions();
XOTRACE( "wgl_Load: %d\n", wglLoad );
XOTRACE( "ogl_Load: %d\n", oglLoad );
GLIsBooted = true;
wglMakeCurrent( NULL, NULL );
wglDeleteContext( rc );
}

ReleaseDC( wnd, dc );

return true;
}
#endif

#if XO_PLATFORM_WIN_DESKTOP
bool xoRenderGL::InitializeDevice( xoSysWnd& wnd )
{
if ( !GLIsBooted )
{
if ( !xoBootGL( wnd.SysWnd ) )
return false;
}

bool allGood = false;
HGLRC rc = NULL;
HDC dc = GetDC( wnd.SysWnd );
if ( !dc )
return false;

int attribs[] =
{
WGL_DRAW_TO_WINDOW_ARB,		1,
WGL_SUPPORT_OPENGL_ARB,		1,
WGL_DOUBLE_BUFFER_ARB,		1,
WGL_PIXEL_TYPE_ARB,			WGL_TYPE_RGBA_ARB,
WGL_COLOR_BITS_ARB,			24,
WGL_ALPHA_BITS_ARB,			0,
WGL_DEPTH_BITS_ARB,			16,
WGL_STENCIL_BITS_ARB,		0,
WGL_SWAP_METHOD_ARB,		WGL_SWAP_EXCHANGE_ARB,	// This was an attempt to lower latency on Windows 8.0, but it seems to have no effect
0
};
PIXELFORMATDESCRIPTOR pfd;
xoBootGL_FillPFD( pfd );
int formats[20];
uint numformats = 0;
BOOL chooseOK = wglChoosePixelFormatARB( dc, attribs, NULL, arraysize(formats), formats, &numformats );
if ( chooseOK && numformats != 0 )
{
if ( SetPixelFormat( dc, formats[0], &pfd ) )
{
rc = wglCreateContext( dc );
wglMakeCurrent( dc, rc );
if ( wglSwapIntervalEXT )
wglSwapIntervalEXT( xoGlobal()->EnableVSync ? 1 : 0 );
allGood = CreateShaders();
wglMakeCurrent( NULL, NULL );
}
else
{
XOTRACE( "SetPixelFormat failed: %d\n", GetLastError() );
}
}

ReleaseDC( wnd.SysWnd, dc );

if ( !allGood )
{
if ( rc )
wglDeleteContext( rc );
rc = NULL;
}

GLRC = rc;
return GLRC != NULL;
}
#elif XO_PLATFORM_ANDROID
bool xoRenderGL::InitializeDevice( xoSysWnd& wnd )
{
if ( !CreateShaders() )
return false;
return true;
}
#elif XO_PLATFORM_LINUX_DESKTOP
bool xoRenderGL::InitializeDevice( xoSysWnd& wnd )
{
int oglLoad = ogl_LoadFunctions();
int glxLoad = glx_LoadFunctions( wnd.XDisplay, 0 );
XOTRACE( "oglload: %d\n", oglLoad );
XOTRACE( "glxload: %d\n", glxLoad );
if ( !CreateShaders() )
return false;
XOTRACE( "Shaders created\n" );
return true;
}
#else
XOTODO_STATIC
#endif

void xoRenderGL::CheckExtensions()
{
const char* ver = (const char*) glGetString( GL_VERSION );
const char* ext = (const char*) glGetString( GL_EXTENSIONS );
auto hasExtension = [ext]( const char* name ) -> bool
{
const char* pos = ext;
while ( true )
{
size_t len = strlen( name );
pos = strstr( pos, name );
if ( pos != NULL && (pos[len] == ' ' || pos[len] == 0) )
return true;
else if ( pos == NULL )
return false;
}
};

XOTRACE( "Checking OpenGL extensions\n" );
// On my desktop Nvidia I get "4.3.0"

int dot = (int) (strstr(ver, ".") - ver);
int major = ver[dot - 1] - '0';
int minor = ver[dot + 1] - '0';
int version = major * 10 + minor;

XOTRACE( "OpenGL version: %s\n", ver );
XOTRACE( "OpenGL extensions: %s\n", ext );

if ( strstr(ver, "OpenGL ES") )
{
XOTRACE( "OpenGL ES\n" );
Have_Unpack_RowLength = version >= 30 || hasExtension( "GL_EXT_unpack_subimage" );
Have_sRGB_Framebuffer = version >= 30 || hasExtension( "GL_EXT_sRGB" );
}
else
{
XOTRACE( "OpenGL Regular (non-ES)\n" );
Have_Unpack_RowLength = true;
Have_sRGB_Framebuffer = version >= 40 || hasExtension( "ARB_framebuffer_sRGB" ) || hasExtension( "GL_EXT_framebuffer_sRGB" );
}

Have_BlendFuncExtended = hasExtension( "GL_ARB_blend_func_extended" );
XOTRACE( "OpenGL Extensions ("
"UNPACK_SUBIMAGE=%d, "
"sRGB_FrameBuffer=%d, "
"blend_func_extended=%d"
")\n",
Have_Unpack_RowLength ? 1 : 0,
Have_sRGB_Framebuffer ? 1 : 0,
Have_BlendFuncExtended ? 1 : 0);
}

bool xoRenderGL::CreateShaders()
{
Check();

CheckExtensions();

Check();

for ( int i = 0; i < NumProgs; i++ )
{
if ( AllProgs[i]->UseOnThisPlatform() )
{
if ( !LoadProgram( *AllProgs[i] ) )
return false;
if ( !AllProgs[i]->LoadVariablePositions() )
return false;
}
}

Check();

return true;
}

void xoRenderGL::DeleteShadersAndTextures()
{
for ( int i = xoMaxTextureUnits - 1; i >= 0; i-- )
{
glActiveTexture( GL_TEXTURE0 + i );
glBindTexture( GL_TEXTURE_2D, 0 );
}

podvec<GLuint> textures;
for ( intp i = 0; i < TexIDToNative.size(); i++ )
textures += GetTextureDeviceHandleInt( FirstTextureID() + (xoTextureID) i );

glDeleteTextures( (GLsizei) textures.size(), &textures[0] );

glUseProgram( 0 );

for ( int i = 0; i < NumProgs; i++ )
DeleteProgram( *AllProgs[i] );
}

xoProgBase* xoRenderGL::GetShader( xoShaders shader )
{
switch ( shader )
{
case xoShaderFill:		return &PFill;
case xoShaderFillTex:	return &PFillTex;
case xoShaderRect:		return &PRect;
case xoShaderTextRGB:	return &PTextRGB;
case xoShaderTextWhole:	return &PTextWhole;
default:
XOASSERT(false);
return NULL;
}
}

void xoRenderGL::ActivateShader( xoShaders shader )
{
if ( ActiveShader == shader )
return;
xoGLProg* p = (xoGLProg*) GetShader( shader );
ActiveShader = shader;
XOASSERT( p->Prog != 0 );
XOTRACE_RENDER( "Activate shader %s\n", p->Name() );
glUseProgram( p->Prog );
if ( ActiveShader == xoShaderTextRGB )
{
// outputColor0 = vec4(color.r, color.g, color.b, avgA);
// outputColor1 = vec4(aR, aG, aB, avgA);
if ( Have_BlendFuncExtended )
glBlendFuncSeparate( GL_SRC1_COLOR, GL_ONE_MINUS_SRC1_COLOR, GL_ONE, GL_ONE_MINUS_SRC_ALPHA );
// else we are screwed!
// there might be a solution that is better than simply ignoring the problem, but I
// haven't bothered yet. On my Sandy Bridge (i7-2600K) with 2014-04-15 Intel drivers,
// the DirectX drivers correctly expose this functionality, but the OpenGL drivers do
// not support GL_ARB_blend_func_extended, so it's very simple - we just use DirectX.
// I can't think of a device/OS combination where you'd want OpenGL+Subpixel text,
// so sticking with DirectX 11 there is hopefully fine. Hmm.. actually desktop linux
// is indeed such a combination. We'll have to wait and see.
}
else
{
glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );	// this is for non-premultiplied
//glBlendFunc( GL_ONE, GL_ONE_MINUS_SRC_ALPHA );			// this is premultiplied
}
Check();
}

void xoRenderGL::DestroyDevice( xoSysWnd& wnd )
{
#if XO_PLATFORM_WIN_DESKTOP
if ( GLRC != NULL )
{
DC = GetDC( wnd.SysWnd );
wglMakeCurrent( DC, GLRC );
DeleteShadersAndTextures();
wglMakeCurrent( NULL, NULL );
wglDeleteContext( GLRC );
ReleaseDC( wnd.SysWnd, DC );
DC = NULL;
GLRC = NULL;
}
#endif
}

void xoRenderGL::SurfaceLost()
{
Reset();
SurfaceLost_ForgetTextures();
CreateShaders();
}

bool xoRenderGL::BeginRender( xoSysWnd& wnd )
{
auto rect = wnd.GetRelativeClientRect();
FBWidth = rect.Width();
FBHeight = rect.Height();
XOTRACE_RENDER( "BeginRender %d x %d\n", FBWidth, FBHeight );
#if XO_PLATFORM_WIN_DESKTOP
if ( GLRC )
{
DC = GetDC( wnd.SysWnd );
if ( DC )
{
wglMakeCurrent( DC, GLRC );
return true;
}
}
return false;
#elif XO_PLATFORM_ANDROID
return true
#elif XO_PLATFORM_LINUX_DESKTOP
glXMakeCurrent( wnd.XDisplay, wnd.XWindow, wnd.GLContext );
#else
return true;
#endif
}

void xoRenderGL::EndRender( xoSysWnd& wnd )
{
#if XO_PLATFORM_WIN_DESKTOP
XOTRACE_LATENCY( "SwapBuffers (begin)\n" );
SwapBuffers( DC );
wglMakeCurrent( NULL, NULL );
ReleaseDC( wnd.SysWnd, DC );
DC = NULL;
XOTRACE_LATENCY( "SwapBuffers (done)\n" );
#elif XO_PLATFORM_ANDROID
#elif XO_PLATFORM_LINUX_DESKTOP
XOTRACE_LATENCY( "SwapBuffers (begin)\n" );
glXSwapBuffers( wnd.XDisplay, wnd.XWindow );
glXMakeCurrent( wnd.XDisplay, None, NULL );
XOTRACE_LATENCY( "SwapBuffers (done)\n" );
#endif
}

void xoRenderGL::PreRender()
{
Check();

XOTRACE_RENDER( "PreRender %d %d\n", FBWidth, FBHeight );
Check();

glViewport( 0, 0, FBWidth, FBHeight );

auto clear = xoGlobal()->ClearColor;

if ( xoGlobal()->EnableSRGBFramebuffer && Have_sRGB_Framebuffer )
{
glEnable( GL_FRAMEBUFFER_SRGB );
glClearColor( xoSRGB2Linear(clear.r), xoSRGB2Linear(clear.g), xoSRGB2Linear(clear.b), clear.a / 255.0f );
}
else
{
glClearColor( clear.r / 255.0f, clear.g / 255.0f, clear.b / 255.0f, clear.a / 255.0f );
}

//glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ACCUM_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );
glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT );

XOTRACE_RENDER( "PreRender 2\n" );
Check();

// Enable CULL_FACE because it will make sure that we are consistent about vertex orientation
glEnable( GL_CULL_FACE );
glFrontFace( GL_CCW );
glDisable( GL_DEPTH_TEST );
glEnable( GL_BLEND );
glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );

XOTRACE_RENDER( "PreRender 3\n" );
Check();

SetShaderFrameUniforms();

XOTRACE_RENDER( "PreRender done\n" );
}

void xoRenderGL::SetShaderFrameUniforms()
{
XOTRACE_RENDER( "FB %d x %d\n", FBWidth, FBHeight );
xoMat4f mvproj;
mvproj.Identity();
Ortho( mvproj, 0, FBWidth, FBHeight, 0, 1, 0 );
xoMat4f mvprojT = mvproj.Transposed();

if ( SetMVProj( xoShaderRect, PRect, mvprojT ) )
glUniform2f( PRect.v_vport_hsize, FBWidth / 2.0f, FBHeight / 2.0f );

SetMVProj( xoShaderFill, PFill, mvprojT );
SetMVProj( xoShaderFillTex, PFillTex, mvprojT );
SetMVProj( xoShaderTextRGB, PTextRGB, mvprojT );
SetMVProj( xoShaderTextWhole, PTextWhole, mvprojT );
}

void xoRenderGL::SetShaderObjectUniforms()
{
if ( ActiveShader == xoShaderRect )
{
glUniform4fv( PRect.v_box, 1, &ShaderPerObject.Box.x );
glUniform4fv( PRect.v_border, 1, &ShaderPerObject.Border.x );
glUniform4fv( PRect.v_border_color, 1, &ShaderPerObject.BorderColor.x );
glUniform1f( PRect.v_radius, ShaderPerObject.Radius );
}
}

template<typename TProg>
bool xoRenderGL::SetMVProj( xoShaders shader, TProg& prog, const Mat4f& mvprojTransposed )
{
if ( prog.Prog == 0 )
{
XOTRACE_RENDER( "SetMVProj skipping %s, because not compiled\n", (const char*) prog.Name() );
return false;
}
else
{
XOTRACE_RENDER( "SetMVProj %s (%d)\n", (const char*) prog.Name(), prog.v_mvproj );
ActivateShader( shader );
Check();
// GLES doesn't support TRANSPOSE = TRUE
glUniformMatrix4fv( prog.v_mvproj, 1, false, &mvprojTransposed.row[0].x );
return true;
}
}

void xoRenderGL::PostRenderCleanup()
{
glUseProgram( 0 );
ActiveShader = xoShaderInvalid;
}

void xoRenderGL::DrawQuad( const void* v )
{
XOTRACE_RENDER( "DrawQuad\n" );

SetShaderObjectUniforms();

int stride = sizeof(xoVx_PTC);
const byte* vbyte = (const byte*) v;

GLint varvpos = 0;
GLint varvcol = 0;
GLint varvtex0 = 0;
GLint varvtexClamp = 0;
GLint vartexUnit0 = 0;
switch ( ActiveShader )
{
case xoShaderRect:
varvpos = PRect.v_vpos;
varvcol = PRect.v_vcolor;
break;
case xoShaderFill:
varvpos = PFill.v_vpos;
varvcol = PFill.v_vcolor;
XOTRACE_RENDER( "vv %d %d\n", varvpos, varvcol );
break;
case xoShaderFillTex:
varvpos = PFillTex.v_vpos;
varvcol = PFillTex.v_vcolor;
varvtex0 = PFillTex.v_vtexuv0;
vartexUnit0 = PFillTex.v_tex0;
break;
case xoShaderTextRGB:
stride = sizeof(xoVx_PTCV4);
varvpos = PTextRGB.v_vpos;
varvcol = PTextRGB.v_vcolor;
varvtex0 = PTextRGB.v_vtexuv0;
varvtexClamp = PTextRGB.v_vtexClamp;
vartexUnit0 = PTextRGB.v_tex0;
break;
case xoShaderTextWhole:
varvpos = PTextWhole.v_vpos;
varvcol = PTextWhole.v_vcolor;
varvtex0 = PTextWhole.v_vtexuv0;
vartexUnit0 = PTextWhole.v_tex0;
break;
}

// We assume here that xoVx_PTC and xoVx_PTCV4 share the same base layout
glVertexAttribPointer( varvpos, 3, GL_FLOAT, false, stride, vbyte );
glEnableVertexAttribArray( varvpos );

glVertexAttribPointer( varvcol, 4, GL_UNSIGNED_BYTE, true, stride, vbyte + offsetof(xoVx_PTC, Color) );
glEnableVertexAttribArray( varvcol );

if ( varvtex0 != 0 )
{
glUniform1i( vartexUnit0, 0 );
glVertexAttribPointer( varvtex0, 2, GL_FLOAT, true, stride, vbyte + offsetof(xoVx_PTC, UV) );
glEnableVertexAttribArray( varvtex0 );
}
if ( varvtexClamp != 0 )
{
glVertexAttribPointer( varvtexClamp, 4, GL_FLOAT, true, stride, vbyte + offsetof(xoVx_PTCV4, V4) );
glEnableVertexAttribArray( varvtexClamp );
}

uint16 indices[4];
indices[0] = 0;
indices[1] = 1;
indices[2] = 3;
indices[3] = 2;
glDrawElements( GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_SHORT, indices );

//auto vx = (xoVx_PTC*) vbyte;
//XOTRACE_RENDER( "DrawQuad done (%f,%f) (%f,%f) (%f,%f) (%f,%f)\n", vx[0].Pos.x, vx[0].Pos.y, vx[1].Pos.x, vx[1].Pos.y, vx[2].Pos.x, vx[2].Pos.y, vx[3].Pos.x, vx[3].Pos.y );

Check();
}

/*
void xoRenderGL::DrawTriangles( int nvert, const void* v, const uint16* indices )
{
int stride = sizeof(xoVx_PTC);
const byte* vbyte = (const byte*) v;
glDrawElements( GL_TRIANGLES, nvert, GL_UNSIGNED_SHORT, indices );
Check();
}
*/

bool xoRenderGL::LoadTexture( xoTexture* tex, int texUnit )
{
EnsureTextureProperlyDefined( tex, texUnit );

if ( !IsTextureValid( tex->TexID ) )
{
GLuint t;
glGenTextures( 1, &t );
tex->TexID = RegisterTextureInt( t );
tex->TexInvalidate();
}

GLuint glTexID = GetTextureDeviceHandleInt( tex->TexID );
if ( BoundTextures[texUnit] != glTexID )
{
glActiveTexture( GL_TEXTURE0 + texUnit );
glBindTexture( GL_TEXTURE_2D, glTexID );
BoundTextures[texUnit] = glTexID;
}

// If the texture has not been updated, then we are done
xoBox invRect = tex->TexInvalidRect;
xoBox fullRect = xoBox(0, 0, tex->TexWidth, tex->TexHeight);
invRect.ClampTo( fullRect );
if ( invRect.IsAreaZero() )
return true;

int format = 0;
switch ( tex->TexFormat )
{
case xoTexFormatGrey8: format = GL_RED; break;	// was luminance
//case : format = GL_RG;
//case : format = GL_RGB;
case xoTexFormatRGBA8: format = GL_RGBA; break;
default:
XOTODO;
}
int iformat = format;

if ( Have_Unpack_RowLength )
glPixelStorei( GL_UNPACK_ROW_LENGTH, tex->TexStride );

if ( !Have_Unpack_RowLength || invRect == fullRect )
{
glTexImage2D( GL_TEXTURE_2D, 0, iformat, tex->TexWidth, tex->TexHeight, 0, format, GL_UNSIGNED_BYTE, tex->TexData );

// all assuming this is for a glyph atlas
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
// Clamping should have no effect for RGB text, since we clamp inside our fragment shader.
// Also, when rendering 'whole pixel' glyphs, we shouldn't need clamping either, because
// our UV coordinates are exact, and we always have a 1:1 texel:pixel ratio.
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
}
else
{
glTexSubImage2D( GL_TEXTURE_2D, 0, invRect.Left, invRect.Top, invRect.Width(), invRect.Height(), format, GL_UNSIGNED_BYTE, tex->TexDataAt(invRect.Left, invRect.Top) );
}

if ( Have_Unpack_RowLength )
glPixelStorei( GL_UNPACK_ROW_LENGTH, 0 );

return true;
}

bool xoRenderGL::ReadBackbuffer( xoImage& image )
{
image.Alloc( xoTexFormatRGBA8, FBWidth, FBHeight );
if ( Have_Unpack_RowLength )
glPixelStorei( GL_UNPACK_ROW_LENGTH, image.TexStride / 4 );

glReadPixels( 0, 0, FBWidth, FBHeight, GL_RGBA, GL_UNSIGNED_BYTE, image.TexDataAtLine(0) );

// our image is top-down
// glReadPixels is bottom-up
image.FlipVertical();

if ( Have_Unpack_RowLength )
glPixelStorei( GL_UNPACK_ROW_LENGTH, 0 );

return true;
}

void xoRenderGL::PreparePreprocessor()
{
if ( BaseShader.size() != 0 )
return;

#if XO_PLATFORM_WIN_DESKTOP
BaseShader.append( "#define XO_PLATFORM_WIN_DESKTOP\n" );
#elif XO_PLATFORM_ANDROID
BaseShader.append( "#define XO_PLATFORM_ANDROID\n" );
#elif XO_PLATFORM_LINUX_DESKTOP
BaseShader.append( "#define XO_PLATFORM_LINUX_DESKTOP\n" );
#else
#ifdef _MSC_VER
#pragma error( "Unknown xoDom platform" )
#else
#error Unknown xoDom platform
#endif
#endif

BaseShader.append( CommonShaderDefines() );
if ( xoGlobal()->EnableSRGBFramebuffer && Have_sRGB_Framebuffer )
BaseShader.append( "#define XO_SRGB_FRAMEBUFFER\n" );

BaseShader += nu_GLSLPrefix;

/*
if ( Preprocessor.MacroCount() != 0 )
return;

Preprocessor.SetMacro( "XO_GLYPH_ATLAS_SIZE", fmt("%v", xoGlyphAtlasSize).Z );

if ( xoGlobal()->EnableSRGBFramebuffer )
Preprocessor.SetMacro( "XO_SRGB_FRAMEBUFFER", "" );
*/

//if ( xoGlobal()->EnableSRGBFramebuffer && xoGlobal()->EmulateGammaBlending )
//	Preprocessor.SetMacro( "XO_EMULATE_GAMMA_BLENDING", "" );
}

void xoRenderGL::DeleteProgram( xoGLProg& prog )
{
if ( prog.Prog ) glDeleteShader( prog.Prog );
if ( prog.Vert ) glDeleteShader( prog.Vert );
if ( prog.Frag ) glDeleteShader( prog.Frag );
prog = xoGLProg();
}

bool xoRenderGL::LoadProgram( xoGLProg& prog )
{
return LoadProgram( prog.Vert, prog.Frag, prog.Prog, prog.Name(), prog.VertSrc(), prog.FragSrc() );
}

bool xoRenderGL::LoadProgram( xoGLProg& prog, const char* name, const char* vsrc, const char* fsrc )
{
return LoadProgram( prog.Vert, prog.Frag, prog.Prog, name, vsrc, fsrc );
}

bool xoRenderGL::LoadProgram( GLuint& vshade, GLuint& fshade, GLuint& prog, const char* name, const char* vsrc, const char* fsrc )
{
XOTRACE("Loading shader %s\n", name);
XOASSERT(glGetError() == GL_NO_ERROR);

bool isTextRGB = strcmp(name, "TextRGB") == 0;

if ( !LoadShader( GL_VERTEX_SHADER, vshade, name, vsrc ) ) return false;
if ( !LoadShader( GL_FRAGMENT_SHADER, fshade, name, fsrc ) ) return false;

prog = glCreateProgram();

glAttachShader( prog, vshade );
glAttachShader( prog, fshade );
if ( isTextRGB )
{
// NOTE: The following DOES WORK. It is unnecessary however, on the NVidia hardware that I have tested on.
// BUT: It is necessary on Linux, Haswell Intel drivers
glBindFragDataLocationIndexed( prog, 0, 0, "outputColor0" );
glBindFragDataLocationIndexed( prog, 0, 1, "outputColor1" );
}
glLinkProgram( prog );

int ilen;
const int maxBuff = 8000;
GLchar ibuff[maxBuff];

GLint linkStat;
glGetProgramiv( prog, GL_LINK_STATUS, &linkStat );
glGetProgramInfoLog( prog, maxBuff, &ilen, ibuff );
if ( ibuff[0] != 0 )
{
XOTRACE( "Shader: %s\n", name );
XOTRACE( ibuff );
XOTRACE( "\n" );
}
bool ok = linkStat != 0 && glGetError() == GL_NO_ERROR;
if ( !ok )
XOTRACE( "Failed to load shader %s: glGetError = %d, linkStat = %d\n", name, glGetError(), linkStat );
return ok;
}

bool xoRenderGL::LoadShader( GLenum shaderType, GLuint& shader, const char* name, const char* raw_src )
{
XOASSERT(glGetError() == GL_NO_ERROR);

shader = glCreateShader( shaderType );

std::string raw_prefix = "";
std::string raw_other = raw_src;
// #version must be on the first line
if ( strstr(raw_src, "#version") == raw_src )
{
size_t firstLine = strstr(raw_src, "\n") - raw_src;
raw_prefix = raw_other.substr( 0, firstLine + 1 );
raw_other = raw_other.substr( firstLine + 1 );
}

PreparePreprocessor();
std::string processed = raw_prefix + BaseShader + raw_other;
//xoString processed = Preprocessor.Run( raw_src );
//xoString processed(raw_src);
//processed.ReplaceAll( "XO_GLYPH_ATLAS_SIZE", fmt("%v", xoGlyphAtlasSize).Z );
//fputs( processed.c_str(), stderr );

GLchar* vstring[1];
vstring[0] = (GLchar*) processed.c_str();

glShaderSource( shader, 1, (const GLchar**) vstring, NULL );

int ilen;
const int maxBuff = 8000;
GLchar ibuff[maxBuff];

GLint compileStat;
glCompileShader( shader );
glGetShaderiv( shader, GL_COMPILE_STATUS, &compileStat );
glGetShaderInfoLog( shader, maxBuff, &ilen, ibuff );
//glGetInfoLogARB( shader, maxBuff, &ilen, ibuff );
if ( ibuff[0] != 0 )
{
XOTRACE( "Shader %s (%s)\n", name, shaderType == GL_FRAGMENT_SHADER ? "frag" : "vert" );
XOTRACE( ibuff );
}
if ( compileStat == 0 )
return false;

return glGetError() == GL_NO_ERROR;
}

void xoRenderGL::Check()
{
int e = glGetError();
if ( e != GL_NO_ERROR )
{
XOTRACE( "glError = %d\n", e );
}
//XOASSERT( glGetError() == GL_NO_ERROR );
}

#endif

#if XO_BUILD_OPENGL

xoGLProg::xoGLProg()
{
ResetBase();
}

xoGLProg::~xoGLProg()
{
}

void			xoGLProg::Reset()					{ ResetBase(); }
const char*		xoGLProg::VertSrc()					{ return NULL; }
const char*		xoGLProg::FragSrc()					{ return NULL; }
const char*		xoGLProg::Name()					{ return "<unnamed shader>"; }
void			xoGLProg::ResetBase()				{ Vert = Frag = Prog = 0; }
bool			xoGLProg::LoadVariablePositions()	{ return false; }
uint32			xoGLProg::PlatformMask()			{ return xoPlatform_All; }
xoVertexType	xoGLProg::VertexType()				{ return xoVertexType_NULL; }

#endif


xoRenderDoc::xoRenderDoc()
{
WindowWidth = 0;
WindowHeight = 0;
RenderRoot.SetPool( &RenderPool );
}

xoRenderDoc::~xoRenderDoc()
{
}

void xoRenderDoc::ResetRenderData()
{
RenderRoot.Discard();
RenderPool.FreeAll();
RenderRoot.InternalID = Doc.Root.GetInternalID();
}

xoRenderResult xoRenderDoc::Render( xoRenderBase* driver )
{
XOTRACE_RENDER( "RenderDoc: Reset\n" );
ResetRenderData();

XOTRACE_RENDER( "RenderDoc: Layout\n" );
xoLayout2 lay;
lay.Layout( Doc, WindowWidth, WindowHeight, RenderRoot, &RenderPool );

XOTRACE_RENDER( "RenderDoc: Render\n" );
xoRenderer rend;
xoRenderResult res = rend.Render( &ClonedImages, &Doc.Strings, driver, &RenderRoot, WindowWidth, WindowHeight );

return res;
}

void xoRenderDoc::CopyFromCanonical( const xoDoc& canonical, xoRenderStats& stats )
{
// Find nodes that have changed, so that we can apply transitions
//ModifiedNodeIDs.clear();
//FindAlteredNodes( &Doc, &canonical, ModifiedNodeIDs );

canonical.CloneSlowInto( Doc, 0, stats );

// TODO: Don't do this dumb copying.
//ClonedStrings.CloneFrom( canonical.Strings );
ClonedImages.CloneFrom( canonical.Images );
}

/*
xoInternalID xoRenderDoc::FindElement( const xoRenderDomEl& el, xoPoint pos )
{
if ( el.Children.size() == 0 )
return el.InternalID;

for ( intp i = 0; i < el.Children.size(); i++ )
{
if ( el.Children[i]->Pos.IsInsideMe( pos ) )
{
xoInternalID id = FindElement( *el.Children[i], pos );
if ( id != xoInternalIDNull )
return id;
}
}

return xoInternalIDNull;
}
*/

/*
void xoRenderDoc::FindAlteredNodes( const xoDoc* original, const xoDoc* modified, podvec<xoInternalID>& alteredNodeIDs )
{
int top = (int) min( original->ChildByInternalIDListSize(), modified->ChildByInternalIDListSize() );
const xoDomEl** org = original->ChildByInternalIDList();
const xoDomEl** mod = modified->ChildByInternalIDList();
for ( int i = 0; i < top; i++ )
{
if (	(org[i] && mod[i]) &&
(org[i]->GetVersion() != mod[i]->GetVersion()) )
{
alteredNodeIDs += i;
}
}
}
*/


xoRenderDomEl::xoRenderDomEl( xoInternalID id, xoTag tag ) : InternalID(id), Tag(tag)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoRenderDomNode::xoRenderDomNode( xoInternalID id, xoTag tag, xoPool* pool ) : xoRenderDomEl(id, tag)
{
SetPool( pool );
}

void xoRenderDomNode::Discard()
{
InternalID = 0;
Children.clear();
}

void xoRenderDomNode::SetStyle( xoRenderStack& stack )
{
auto bgColor = stack.Get( xoCatBackground );
auto bgImage = stack.Get( xoCatBackgroundImage );
if ( !bgColor.IsNull() ) Style.BackgroundColor = bgColor.GetColor();
if ( !bgImage.IsNull() ) Style.BackgroundImageID = bgImage.GetStringID();
}

void xoRenderDomNode::SetPool( xoPool* pool )
{
Children.Pool = pool;
}

xoBox xoRenderDomNode::BorderBox() const
{
xoBox box = Pos;
box.Left -= Style.BorderSize.Left;
box.Top -= Style.BorderSize.Top;
box.Right += Style.BorderSize.Right;
box.Bottom += Style.BorderSize.Bottom;
return box;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoRenderDomText::xoRenderDomText( xoInternalID id, xoPool* pool ) : xoRenderDomEl( id, xoTagText )
{
Text.Pool = pool;
FontID = xoFontIDNull;
Char = 0;
FontSizePx = 0;
Flags = 0;
}

void xoRenderDomText::SetStyle( xoRenderStack& stack )
{
Color = stack.Get( xoCatColor ).GetColor();
}


void xoRenderStackEl::Reset()
{
Styles.Reset();
Pool = NULL;
}

xoRenderStackEl& xoRenderStackEl::operator=( const xoRenderStackEl& b )
{
memcpy( this, &b, sizeof(*this) );
return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoRenderStack::xoRenderStack()
{
}

xoRenderStack::~xoRenderStack()
{
delete_all( Stack_Pools );
}

void xoRenderStack::Initialize( const xoDoc* doc, xoPool* pool )
{
Doc = doc;
Pool = pool;
Stack.Pool = pool;

memset( Defaults, 0, sizeof(Defaults) );
Defaults[xoCatColor].SetColor( xoCatColor, xoColor::RGBA(0,0,0,255) );
Defaults[xoCatDisplay].SetDisplay( xoDisplayInline );
Defaults[xoCatBackground].SetColor( xoCatBackground, xoColor::RGBA(0,0,0,0) );
//Defaults[xoCatBackgroundImage]
Defaults[xoCatText_Align_Vertical].SetTextAlignVertical( xoTextAlignVerticalBaseline );
//Defaults[xoCatDummy2_UseMe]
//Defaults[xoCatDummy3_UseMe]
Defaults[xoCatMargin_Left].SetSize( xoCatMargin_Left, xoSize::Zero() );
Defaults[xoCatMargin_Top].SetSize( xoCatMargin_Top, xoSize::Zero() );
Defaults[xoCatMargin_Right].SetSize( xoCatMargin_Right, xoSize::Zero() );
Defaults[xoCatMargin_Bottom].SetSize( xoCatMargin_Bottom, xoSize::Zero() );

Defaults[xoCatPadding_Left].SetSize( xoCatPadding_Left, xoSize::Zero() );
Defaults[xoCatPadding_Top].SetSize( xoCatPadding_Top, xoSize::Zero() );
Defaults[xoCatPadding_Right].SetSize( xoCatPadding_Right, xoSize::Zero() );
Defaults[xoCatPadding_Bottom].SetSize( xoCatPadding_Bottom, xoSize::Zero() );

Defaults[xoCatBorder_Left].SetSize( xoCatBorder_Left, xoSize::Zero() );
Defaults[xoCatBorder_Top].SetSize( xoCatBorder_Top, xoSize::Zero() );
Defaults[xoCatBorder_Right].SetSize( xoCatBorder_Right, xoSize::Zero() );
Defaults[xoCatBorder_Bottom].SetSize( xoCatBorder_Bottom, xoSize::Zero() );

Defaults[xoCatBorderColor_Left].SetColor( xoCatBorderColor_Left, xoColor::RGBA(0,0,0,255) );
Defaults[xoCatBorderColor_Top].SetColor( xoCatBorderColor_Top, xoColor::RGBA(0,0,0,255) );
Defaults[xoCatBorderColor_Right].SetColor( xoCatBorderColor_Right, xoColor::RGBA(0,0,0,255) );
Defaults[xoCatBorderColor_Bottom].SetColor( xoCatBorderColor_Bottom, xoColor::RGBA(0,0,0,255) );

Defaults[xoCatWidth].SetSize( xoCatWidth, xoSize::Null() );
Defaults[xoCatHeight].SetSize( xoCatHeight, xoSize::Null() );
//Defaults[xoCatTop].SetTop( xoVerticalBindingNULL ); -- do we need to? We don't.
//Defaults[xoCatLeft]
//Defaults[xoCatRight]
//Defaults[xoCatBottom]
Defaults[xoCatFontSize].SetSize( xoCatFontSize, xoSize::Pixels(12) );
// Font should inherit from body. xoDoc initializes the default font for xoTagBody
//Defaults[xoCatFontFamily].SetFont( doc->TagStyles[xoTagBody].Get().GetFont( doc ).Z, doc );
Defaults[xoCatBorderRadius].SetSize( xoCatBorderRadius, xoSize::Zero() );
Defaults[xoCatPosition].SetPosition( xoPositionStatic );
Defaults[xoCatBoxSizing].SetBoxSizing( xoBoxSizeBorder );	// HTML default is Content
//XY(END)
}

void xoRenderStack::Reset()
{
delete_all( Stack_Pools );
Stack.clear();
}

xoStyleAttrib xoRenderStack::Get( xoStyleCategories cat ) const
{
xoStyleAttrib v = Stack.back().Styles.Get( cat );
if ( v.IsNull() )
return Defaults[cat];
else
return v;
}

void xoRenderStack::GetBox( xoStyleCategories cat, xoStyleBox& box ) const
{
xoStyleCategories base = xoCatMakeBaseBox(cat);
box.Left = Get( (xoStyleCategories) (base + 0) ).GetSize();
box.Top = Get( (xoStyleCategories) (base + 1) ).GetSize();
box.Right = Get( (xoStyleCategories) (base + 2) ).GetSize();
box.Bottom = Get( (xoStyleCategories) (base + 3) ).GetSize();
}

void xoRenderStack::StackPop()
{
// Stack_Pools never gets downsized
Stack_Pools.back()->FreeAllExceptOne();
Stack.pop();
}

xoRenderStackEl& xoRenderStack::StackPush()
{
xoRenderStackEl& el = Stack.add();
while ( Stack_Pools.size() < Stack.size() )
{
Stack_Pools += new xoPool();
Stack_Pools.back()->SetChunkSize( 8 * 1024 ); // this is mentioned in xoRenderStack docs, so keep that up to date if you change this
}
el.Pool = Stack_Pools[Stack.size() - 1];
return el;
}


void xoStyleResolver::ResolveAndPush( xoRenderStack& stack, const xoDomNode* node )
{
xoRenderStackEl& result = stack.StackPush();

// 1. Inherited by default
for ( int i = 0; i < xoNumInheritedStyleCategories; i++ )
SetInherited( stack, node, xoInheritedStyleCategories[i] );

// 2. Tag style
Set( stack, node, stack.Doc->TagStyles[node->GetTag()] );

// 3. Classes
const podvec<xoStyleID>& classes = node->GetClasses();
for ( intp i = 0; i < classes.size(); i++ )
Set( stack, node, *stack.Doc->ClassStyles.GetByID( classes[i] ) );

// 4. Node Styles
Set( stack, node, node->GetStyle() );
}

void xoStyleResolver::Set( xoRenderStack& stack, const xoDomEl* node, const xoStyle& style )
{
Set( stack, node, style.Attribs.size(), &style.Attribs[0] );
}

void xoStyleResolver::Set( xoRenderStack& stack, const xoDomEl* node, intp n, const xoStyleAttrib* vals )
{
xoRenderStackEl& result = stack.StackBack();

for ( intp i = 0; i < n; i++ )
{
if ( vals[i].IsInherit() )
SetInherited( stack, node, vals[i].GetCategory() );
else
result.Styles.Set( vals[i], result.Pool );
}
}

void xoStyleResolver::SetInherited( xoRenderStack& stack, const xoDomEl* node, xoStyleCategories cat )
{
xoRenderStackEl& result = stack.StackBack();
intp stackSize = stack.StackSize();

for ( intp j = stackSize - 2; j >= 0; j-- )
{
xoStyleAttrib attrib = stack.StackAt(j).Styles.Get( cat );
if ( !attrib.IsNull() )
{
result.Styles.Set( attrib, result.Pool );
break;
}
}
}


xoTextureAtlas::xoTextureAtlas()
{
memset( this, 0, sizeof(*this) );
}

xoTextureAtlas::~xoTextureAtlas()
{
}

void xoTextureAtlas::Initialize( uint width, uint height, xoTexFormat format, uint padding )
{
TexWidth = width;
TexHeight = height;
Padding = padding;
TexFormat = format;
TexStride = (int) (width * xoTexFormatBytesPerPixel(format));
size_t nbytes = height * TexStride;
TexData = (byte*) xoMallocOrDie( nbytes );
PosTop = Padding;
PosBottom = Padding;
PosRight = Padding;
}

void xoTextureAtlas::Zero()
{
memset( TexData, 0, std::abs(TexStride) * TexHeight );
}

void xoTextureAtlas::Free()
{
free(TexData);
memset( this, 0, sizeof(*this) );
TexID = xoTextureIDNull;
}

bool xoTextureAtlas::Alloc( uint16 width, uint16 height, uint16& x, uint16& y )
{
if ( width > TexWidth )
return false;
if ( PosRight + width > TexWidth )
{
// move onto next line
PosTop = PosBottom;
PosRight = 0;
}
// can't fit vertically
if ( PosTop + height + Padding > TexHeight )
return false;
x = PosRight;
y = PosTop;
PosRight += width + Padding;
PosBottom = std::max(PosBottom, PosTop + height + Padding);
TexInvalidRect.ExpandToFit( xoBox(x, y, x + width, y + height) );
return true;
}


XOAPI size_t xoVertexSize( xoVertexType t )
{
switch ( t )
{
case xoVertexType_NULL:		return 0;
case xoVertexType_PTC:		return sizeof(xoVx_PTC);
case xoVertexType_PTCV4:	return sizeof(xoVx_PTCV4);
default:
XOTODO;
return 0;
}
}


static const int ManifestVersion = 1;
static const char UnitSeparator = 31;

xoFontTableImmutable::xoFontTableImmutable()
{
}

xoFontTableImmutable::~xoFontTableImmutable()
{
}

void xoFontTableImmutable::Initialize( const pvect<xoFont*>& fonts )
{
Fonts = fonts;
}

const xoFont* xoFontTableImmutable::GetByFontID( xoFontID fontID ) const
{
XOASSERT( fontID != xoFontIDNull && fontID < Fonts.size() );
return Fonts[fontID];
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

xoFontStore::xoFontStore()
{
FTLibrary = NULL;
Fonts += NULL;
XOASSERT( Fonts[xoFontIDNull] == NULL );
IsFontTableLoaded = false;
AbcCriticalSectionInitialize( Lock );

#if XO_PLATFORM_WIN_DESKTOP
wchar_t* wpath;
if ( SUCCEEDED(SHGetKnownFolderPath( FOLDERID_Fonts, 0, NULL, &wpath )) )
Directories += ConvertWideToUTF8( wpath ).c_str();
#elif XO_PLATFORM_LINUX_DESKTOP
Directories += "/usr/share/fonts/truetype";
Directories += "/usr/share/fonts/truetype/msttcorefonts";
#elif XO_PLATFORM_ANDROID
Directories += "/system/fonts";
#else
XOTODO_STATIC
#endif
}

xoFontStore::~xoFontStore()
{
AbcCriticalSectionDestroy( Lock );
}

void xoFontStore::Clear()
{
TakeCriticalSection lock(Lock);
for ( intp i = xoFontIDNull + 1; i < Fonts.size(); i++ )
{
FT_Done_Face( Fonts[i]->FTFace );
Fonts[i]->FTFace = NULL;
}
delete_all( Fonts );
FacenameToFontID.clear();
}

void xoFontStore::InitializeFreetype()
{
FT_Init_FreeType( &FTLibrary );
}

void xoFontStore::ShutdownFreetype()
{
FT_Done_FreeType( FTLibrary );
FTLibrary = NULL;
}

const xoFont* xoFontStore::GetByFontID( xoFontID fontID )
{
XOASSERT( fontID != xoFontIDNull && fontID < Fonts.size() );
TakeCriticalSection lock(Lock);
return Fonts[fontID];
}

const xoFont* xoFontStore::GetByFacename( const char* facename )
{
TakeCriticalSection lock(Lock);
return GetByFacename_Internal( facename );
}

xoFontID xoFontStore::Insert( const xoFont& font )
{
XOASSERT( font.ID == xoFontIDNull );
XOASSERT( font.Facename.Length() != 0 );
TakeCriticalSection lock(Lock);

const xoFont* existing = GetByFacename_Internal( font.Facename.Z );
if ( existing )
return existing->ID;

return Insert_Internal( font );
}

xoFontID xoFontStore::InsertByFacename( const char* facename )
{
TakeCriticalSection lock(Lock);

const xoFont* existing = GetByFacename_Internal( facename );
if ( existing )
return existing->ID;

xoFont font;
font.Facename = facename;
const char* filename = GetFilenameFromFacename( facename );

if ( filename == nullptr )
{
XOTRACE( "Failed to load font (facename=%s) (font not found)\n", facename );
return xoFontIDNull;
}

FT_Error e = FT_New_Face( FTLibrary, filename, 0, &font.FTFace );
if ( e != 0 )
{
XOTRACE( "Failed to load font (facename=%s) (filename=%s)\n", facename, filename );
return xoFontIDNull;
}

return Insert_Internal( font );
}

xoFontID xoFontStore::GetFallbackFontID()
{
xoFontID fid = xoFontIDNull;
#if XO_PLATFORM_WIN_DESKTOP
fid = InsertByFacename( "Arial" );
#elif XO_PLATFORM_ANDROID
fid = InsertByFacename( "Droid Sans" );
#elif XO_PLATFORM_LINUX_DESKTOP
fid = InsertByFacename( "Arial" );
#else
XOTODO_STATIC;
#endif
XOASSERT( fid != xoFontIDNull );
return fid;
}

xoFontTableImmutable xoFontStore::GetImmutableTable()
{
TakeCriticalSection lock(Lock);
xoFontTableImmutable t;
t.Initialize( Fonts );
return t;
}

void xoFontStore::AddFontDirectory( const char* dir )
{
Directories += dir;
IsFontTableLoaded = false;
}

const xoFont* xoFontStore::GetByFacename_Internal( const char* facename ) const
{
xoFontID id;
if ( FacenameToFontID.get( xoTempString(facename), id ) )
return Fonts[id];
else
return NULL;
}

xoFontID xoFontStore::Insert_Internal( const xoFont& font )
{
xoFont* copy = new xoFont();
*copy = font;
copy->ID = (xoFontID) Fonts.size();
Fonts += copy;
FacenameToFontID.insert( copy->Facename, copy->ID );
LoadFontConstants( *copy );
LoadFontTweaks( *copy );
return copy->ID;
}

#define EM_TO_256(x) ((int32) ((x) * 256 / font.FTFace->units_per_EM))

void xoFontStore::LoadFontConstants( xoFont& font )
{
uint ftflags = FT_LOAD_LINEAR_DESIGN;
FT_UInt iFTGlyph = FT_Get_Char_Index( font.FTFace, 32 );
FT_Error e = FT_Set_Pixel_Sizes( font.FTFace, 100, 100 );
XOASSERT( e == 0 );
e = FT_Load_Glyph( font.FTFace, iFTGlyph, ftflags );
if ( e != 0 )
{
XOTRACE( "Failed to load glyph for character %d (%d)\n", 32, iFTGlyph );
font.LinearHoriAdvance_Space_x256 = 0;
}
else
{
font.LinearHoriAdvance_Space_x256 = EM_TO_256(font.FTFace->glyph->linearHoriAdvance);
}
font.LineHeight_x256 = EM_TO_256(font.FTFace->height);
font.Ascender_x256 = EM_TO_256(font.FTFace->ascender);
font.Descender_x256 = EM_TO_256(font.FTFace->descender);
}

void xoFontStore::LoadFontTweaks( xoFont& font )
{
// The default of 15 is a number taken from observations of a bunch of different fonts
// The auto hinter fails to produce clean horizontal stems when the text gets larger
// Times New Roman seems to look better at all sub-pixel sizes using the auto hinter.
// The Sans Serif fonts like Segoe UI seem to look better with the TT hinter at larger sizes.

if ( font.Facename == "Times New Roman" )
font.MaxAutoHinterSize = 30;

if ( font.Facename == "Microsoft Sans Serif" )
font.MaxAutoHinterSize = 14;

// This always looks better with the TT hinter
if ( font.Facename == "Segoe UI" )
font.MaxAutoHinterSize = 0;

// This always looks better with the TT hinter
//if ( font.Facename == "Audiowide" )
//	font.MaxAutoHinterSize = 50;
}

const char* xoFontStore::GetFilenameFromFacename( const char* facename )
{
if ( !IsFontTableLoaded )
{
if ( !LoadFontTable() )
BuildAndSaveFontTable();
}

xoString name = facename;
xoString* fn = FacenameToFilename.getp( name );
if ( fn != nullptr )
return fn->Z;

name += " Regular";
fn = FacenameToFilename.getp( name );
if ( fn != nullptr )
return fn->Z;

return nullptr;

/*
// We need to build a cache here and save it to disk.
xoTempString name( facename );
#if XO_PLATFORM_WIN_DESKTOP
if ( name == "Arial" ) return "c:\\Windows\\Fonts\\arial.ttf";
if ( name == "Times New Roman" ) return "c:\\Windows\\Fonts\\times.ttf";
if ( name == "Consolas" ) return "c:\\Windows\\Fonts\\consola.ttf";
if ( name == "Microsoft Sans Serif" ) return "c:\\Windows\\Fonts\\micross.ttf";
if ( name == "Verdana" ) return "c:\\Windows\\Fonts\\verdana.ttf";
if ( name == "Tahoma" ) return "c:\\Windows\\Fonts\\tahoma.ttf";
if ( name == "Segoe UI" ) return "c:\\Windows\\Fonts\\segoeui.ttf";
return "c:\\Windows\\Fonts\\arial.ttf";
#elif XO_PLATFORM_LINUX_DESKTOP
if ( name == "Arial" ) return "/usr/share/fonts/truetype/msttcorefonts/arial.ttf";
if ( name == "Times New Roman" ) return "/usr/share/fonts/truetype/msttcorefonts/times.ttf";
return "/usr/share/fonts/truetype/msttcorefonts/arial.ttf";
#else
if ( name == "Droid Sans" ) return "/system/fonts/DroidSans.ttf";
if ( name == "Droid Sans Mono" ) return "/system/fonts/DroidSansMono.ttf";
return "/system/fonts/DroidSans.ttf";
#endif
*/
}

void xoFontStore::BuildAndSaveFontTable()
{
podvec<xoString> files;
for ( intp i = 0; i < Directories.size(); i++ )
{
auto cb = [&]( const AbcFilesystemItem& item ) -> bool
{
if ( IsFontFilename(item.Name) )
files += xoString(item.Root) + ABC_DIR_SEP_STR + item.Name;
return true;
};

AbcFilesystemFindFiles( Directories[i].Z, cb );
}

FILE* manifest = fopen( (xoCacheDir() + ABC_DIR_SEP_STR + "fonts").Z, "wb" );
fprintf( manifest, "%d\n", ManifestVersion );
fprintf( manifest, "%llu\n", (long long unsigned) ComputeFontDirHash() );

for ( intp i = 0; i < files.size(); i++ )
{
FT_Face face;
FT_Error e = FT_New_Face( FTLibrary, files[i].Z, 0, &face );
if ( e == 0 )
{
xoString facename = face->family_name;
xoString style = face->style_name;
xoString fullFacename = facename + " " + style;
fprintf( manifest, "%s%c%s\n", files[i].Z, UnitSeparator, fullFacename.Z );
FT_Done_Face( face );
}
else
{
XOTRACE( "Failed to load font (filename=%s)\n", files[i].Z );
}
}

fclose( manifest );

LoadFontTable();
}

bool xoFontStore::LoadFontTable()
{
FacenameToFilename.clear();
FILE* manifest = fopen( (xoCacheDir() + ABC_DIR_SEP_STR + "fonts").Z, "rb" );
if ( manifest == nullptr )
return false;

int version = 0;
uint64 hash = 0;
bool ok = true;
ok = ok && 1 == fscanf( manifest, "%d\n", &version );
ok = ok && 1 == fscanf( manifest, "%llu\n", (long long unsigned*) &hash );
if ( version != ManifestVersion || hash != ComputeFontDirHash() )
{
fclose( manifest );
return false;
}

// Read the rest of the file into one buffer
podvec<char> remain;
{
char buf[1024];
size_t nbytes = 0;
while ( (nbytes = fread( buf, 1, sizeof(buf), manifest )) != 0 )
remain.addn( buf, nbytes );
}

fclose ( manifest );

// Parse the contents out line by line, using character 31 as a field separator
const char* buf = &remain[0];
intp lineStart = 0;
intp term1 = 0;
for ( intp i = 0; true; i++ )
{
if ( i == remain.size() || buf[i] == '\n' )
{
if ( i - term1 > 1 )
{
xoString path, facename;
path.Set( buf + lineStart, term1 - lineStart );
facename.Set( buf + term1 + 1, i - term1 - 1 );
FacenameToFilename.insert( facename, path );
}
lineStart = i + 1;
term1 = lineStart;
}
if ( i == remain.size() )
break;
if ( buf[i] == UnitSeparator )
term1 = i;
}

IsFontTableLoaded = true;

return true;
}

uint64 xoFontStore::ComputeFontDirHash()
{
void* hstate = XXH64_init( 0 );

auto cb = [&]( const AbcFilesystemItem& item ) -> bool
{
if ( IsFontFilename(item.Name) )
{
XXH64_update( hstate, item.Root, (int) strlen(item.Root) );
XXH64_update( hstate, item.Name, (int) strlen(item.Name) );
XXH64_update( hstate, &item.TimeModify, sizeof(item.TimeModify) );
}
return true;
};

for ( intp i = 0; i < Directories.size(); i++ )
AbcFilesystemFindFiles( Directories[i].Z, cb );

return (uint64) XXH64_digest( hstate );
}

bool xoFontStore::IsFontFilename( const char* filename )
{
return	strstr(filename, ".ttf") != nullptr ||
strstr(filename, ".ttc ") != nullptr;
}


// Remember that our horizontal expansion is not only there to clobber the horizontal
// hinting. It also serves to give us more accurate glyph metrics, in particular MetricLeftx256,
// which is also called horiBearingX by Freetype.
// An alternative would be to separately load just the glyph metrics without performing glyph
// rendering. That would give us perfect metrics. This only affects the horizontal spacing of
// glyphs, and I think it's unlikely that one would be able to tell the difference there.
static const uint32 xoSubPixelHintKillShift = 0;
static const uint32 xoSubPixelHintKillMultiplier = (1 << xoSubPixelHintKillShift);

// GCC 4.6 for Android forces us to set the value of this constant in the .cpp file, not in the .h file.
const uint xoGlyphCache::NullGlyphIndex = 0;	// Our first element in 'Glyphs' is always the null glyph

xoGlyphCache::xoGlyphCache()
{
Initialize();
}

xoGlyphCache::~xoGlyphCache()
{
}

void xoGlyphCache::Clear()
{
for ( intp i = 0; i < Atlasses.size(); i++ )
Atlasses[i]->Free();
delete_all(Atlasses);
Glyphs.clear();
Table.clear();
Initialize();
}

void xoGlyphCache::Initialize()
{
NullGlyph.SetNull();
Glyphs += xoGlyph();
Glyphs.back().SetNull();
}

/*
bool xoGlyphCache::GetGlyphFromChar( const xoString& facename, int ch, uint8 size, uint8 flags, xoGlyph& glyph )
{
xoFontID fontID = xoFontIDNull;
const xoFont* font = xoGlobal()->FontStore->GetByFacename( facename );
if ( font == NULL )
{
fontID = xoGlobal()->FontStore->InsertByFacename( facename );
XOASSERT( fontID != xoFontIDNull );
}
else
fontID = font->ID;

return GetGlyphFromChar( fontID, ch, size, flags, glyph );
}

bool xoGlyphCache::GetGlyphFromChar( xoFontID fontID, int ch, uint8 size, uint8 flags, xoGlyph& glyph )
{
// TODO: This needs a better threading model. Perhaps you render with fonts in read-only mode,
// and then collect all cache misses, then before next render you fill in all cache misses.

xoGlyphCacheKey key( fontID, ch, size, flags );
uint pos;
if ( !Table.get( key, pos ) )
{
const xoFont* font = xoGlobal()->FontStore->GetByFontID( fontID );
pos = RenderGlyph( key );
if ( pos == -1 )
return false;
}
glyph = Glyphs[pos];

return true;
}
*/

const xoGlyph* xoGlyphCache::GetGlyph( const xoGlyphCacheKey& key ) const
{
uint pos;
if ( Table.get( key, pos ) )
return &Glyphs[pos];
else
return NULL;
}

uint xoGlyphCache::RenderGlyph( const xoGlyphCacheKey& key )
{
XOASSERT( key.Size != 0 );
const xoFont* font = xoGlobal()->FontStore->GetByFontID( key.FontID );

FT_UInt iFTGlyph = FT_Get_Char_Index( font->FTFace, key.Char );

bool isSubPixel = xoGlyphFlag_IsSubPixel(key.Flags);
bool useFTSubpixel = isSubPixel && xoGlobal()->SnapSubpixelHorzText;

uint32 pixSize = key.Size;
int32 combinedHorzMultiplier = 1;
if ( isSubPixel )
combinedHorzMultiplier = xoSubPixelHintKillMultiplier * (useFTSubpixel ? 1 : 3);

FT_Error e = FT_Set_Pixel_Sizes( font->FTFace, combinedHorzMultiplier * pixSize, pixSize );
XOASSERT( e == 0 );

uint ftflags = FT_LOAD_RENDER | FT_LOAD_LINEAR_DESIGN;
// See xoFontStore::LoadFontTweaks for details of why we have this "MaxAutoHinterSize"
//if ( isSubPixel && pixSize <= font->MaxAutoHinterSize )
//	ftflags |= FT_LOAD_FORCE_AUTOHINT;

if ( useFTSubpixel )
ftflags |= FT_LOAD_TARGET_LCD;

e = FT_Load_Glyph( font->FTFace, iFTGlyph, ftflags );
if ( e != 0 )
{
XOTRACE( "Failed to load glyph for character %d (%d)\n", key.Char, iFTGlyph );
Table.insert( key, NullGlyphIndex );
return NullGlyphIndex;
}

int width = font->FTFace->glyph->bitmap.width;
int height = font->FTFace->glyph->bitmap.rows;
int naturalWidth = width;
int horzPad = 0;
bool isEmpty = (width | height) == 0;
if ( isSubPixel && !isEmpty )
{
// Note that Freetype's rasterized width is not necessarily divisible by xoSubPixelHintKillMultiplier.
// We need to round our resulting width up so that is is divisible by xoSubPixelHintKillMultiplier,
// otherwise we miss the last sub-samples. Note that we don't care if our eventual size is not
// divisible by 3. Our fragment shader clamps all filter taps, so we would just read zero off the
// right edge, where our sub-pixel samples are undefined.
naturalWidth = (width + xoSubPixelHintKillMultiplier - 1) / xoSubPixelHintKillMultiplier;
// We need to pad our texture on either side with black lines. Our fragment shader will clamp its UV
// coordinates to the absolute texel bounds of our glyph. The fragment shader will read over the edges
// of our absolute texel bounds, and when it does so, it must read pure black.
horzPad = 1;
}
uint16 atlasX = 0;
uint16 atlasY = 0;
xoTextureAtlas* atlas = NULL;

// Sub-pixel shader does its own clamping, but the whole pixel shader is naive, and
// each glyph needs 3 pixels of padding around it.
int glyphPadding = isSubPixel ? 0 : 3;

for ( int pass = 0; true; pass++ )
{
if ( Atlasses.size() == 0 || pass != 0 )
{
xoTextureAtlas* newAtlas = new xoTextureAtlas();
newAtlas->Initialize( xoGlyphAtlasSize, xoGlyphAtlasSize, xoTexFormatGrey8, glyphPadding );
newAtlas->Zero();
Atlasses += newAtlas;
}
atlas = Atlasses.back();
XOASSERT( naturalWidth + horzPad * 2 <= xoGlyphAtlasSize );
if ( atlas->Alloc( naturalWidth + horzPad * 2, height, atlasX, atlasY ) )
break;
}

if ( isSubPixel )
FilterAndCopyBitmap( font, atlas->TexDataAt(atlasX, atlasY), atlas->GetStride() );
else
CopyBitmap( font, atlas->TexDataAt(atlasX, atlasY), atlas->GetStride() );

if ( key.Char == '1' )
int abc = 123;

xoGlyph g;
g.FTGlyphIndex = iFTGlyph;
g.Width = isEmpty ? 0 : naturalWidth + horzPad * 2;
g.Height = height;
g.X = atlasX;
g.Y = atlasY;
g.AtlasID = (uint) Atlasses.find( atlas );
g.MetricLeft = font->FTFace->glyph->bitmap_left / combinedHorzMultiplier;
g.MetricLeftx256 = font->FTFace->glyph->bitmap_left * 256 / combinedHorzMultiplier;
g.MetricTop = font->FTFace->glyph->bitmap_top;
g.MetricHoriAdvance = font->FTFace->glyph->advance.x / (64 * combinedHorzMultiplier);
g.MetricLinearHoriAdvance = (font->FTFace->glyph->linearHoriAdvance * (int32) pixSize) / (float) font->FTFace->units_per_EM;
Table.insert( key, (uint) Glyphs.size() );
Glyphs += g;
return (uint) (Glyphs.size() - 1);
}

void xoGlyphCache::FilterAndCopyBitmap( const xoFont* font, void* target, int target_stride )
{
uint32 width = font->FTFace->glyph->bitmap.width;
uint32 height = font->FTFace->glyph->bitmap.rows;

float gamma = xoGlobal()->SubPixelTextGamma;

for ( int py = 0; py < (int) height; py++ )
{
uint8* src = (uint8*) font->FTFace->glyph->bitmap.buffer + py * font->FTFace->glyph->bitmap.pitch;
uint8* dst = (uint8*) target + py * target_stride;
// single padding sample on the left side
*dst++ = 0;
// first N - 1 texels
uint32 px = 0;
for ( ; px < width - xoSubPixelHintKillMultiplier; px += xoSubPixelHintKillMultiplier )
{
uint32 accum = 0;
for ( int i = 0; i < xoSubPixelHintKillMultiplier; i++, src++ )
accum += *src;
accum = accum >> xoSubPixelHintKillShift;
if ( gamma != 1 )
accum = (uint32) (pow(accum / 255.0f, gamma) * 255.0f);
*dst++ = accum;
}
// last texel, which may not have the full 'xoSubPixelHintKillMultiplier' number of samples
uint32 accum = 0;
for ( ; px < width; px++, src++ )
accum += *src;
accum = accum >> xoSubPixelHintKillShift;
if ( gamma != 1 )
accum = (uint32) (pow(accum / 255.0f, gamma) * 255.0f);
*dst++ = accum;
// single padding sample on the right side
*dst++ = 0;
}
}

void xoGlyphCache::CopyBitmap( const xoFont* font, void* target, int target_stride )
{
uint32 width = font->FTFace->glyph->bitmap.width;
uint32 height = font->FTFace->glyph->bitmap.rows;

float gamma = xoGlobal()->WholePixelTextGamma;

for ( int py = 0; py < (int) height; py++ )
{
uint8* src = (uint8*) font->FTFace->glyph->bitmap.buffer + py * font->FTFace->glyph->bitmap.pitch;
uint8* dst = (uint8*) target + py * target_stride;
if ( gamma == 1 )
memcpy( dst, src, width );
else
{
for ( uint32 x = 0; x < width; x++ )
{
float v = src[x] / 255.0f;
v = pow(v, gamma) * 255.0f;
v = std::min(v, 255.0f);
v = std::max(v, 0.0f);
dst[x] = (uint8) v;
}
}
}
}


xoFont::xoFont()
{
ID = xoFontIDNull;
FTFace = NULL;
LinearHoriAdvance_Space_x256 = 0;
LineHeight_x256 = 0;
Ascender_x256 = 0;
Descender_x256 = 0;
// See xoFontStore::LoadFontTweaks for more details
MaxAutoHinterSize = 15;
}

xoFont::~xoFont()
{
}


xoDoc::xoDoc() : Root( this, xoTagDiv )
{
IsReadOnly = false;
Version = 0;
ClassStyles.AddDummyStyleZero();
Root.SetDoc( this );
Root.SetDocRoot();
ResetInternalIDs();
InitializeDefaultTagStyles();
}

xoDoc::~xoDoc()
{
// TODO: Ensure that all of your events in the process-wide event queue have been dealt with,
// because the event processor is going to try to access this doc.
Reset();
}

void xoDoc::IncVersion()
{
Version++;
}

void xoDoc::ResetModifiedBitmap()
{
if ( ChildIsModified.Size() > 0 )
ChildIsModified.Fill( 0, ChildIsModified.Size() - 1, false );
}

void xoDoc::MakeFreeIDsUsable()
{
UsableIDs += FreeIDs;
FreeIDs.clear();
}

/*
void xoDoc::CloneFastInto( xoDoc& c, uint cloneFlags, xoRenderStats& stats ) const
{
// this code path died...
XOASSERT(false);

//c.Reset();

if ( c.ChildByInternalID.size() != ChildByInternalID.size() )
c.ChildByInternalID.resize( ChildByInternalID.size() );
c.ChildByInternalID.nullfill();
Root.CloneFastInto( c.Root, &c.Pool, cloneFlags );

ClassStyles.CloneFastInto( c.ClassStyles, &c.Pool );
xoCloneStaticArrayWithCloneFastInto( c.TagStyles, TagStyles, &c.Pool );
}
*/

// This clones only the objects that are marked as modified.
void xoDoc::CloneSlowInto( xoDoc& c, uint cloneFlags, xoRenderStats& stats ) const
{
c.IsReadOnly = true;

// Make sure the destination is large enough to hold all of our children
while ( c.ChildByInternalID.size() < ChildByInternalID.size() )
c.ChildByInternalID += nullptr;

// Although it would be trivial to parallelize the following two passes, I think it is unlikely to be worth it,
// since I suspect these passes will be bandwidth limited.

// Pass 1: Ensure that all objects that are present in the source document have a valid pointer in the target document
for ( int i = 0; i < ChildIsModified.Size(); i++ )
{
if ( ChildIsModified.Get(i) )
{
stats.Clone_NumEls++;
const xoDomEl* src = GetChildByInternalID( i );
xoDomEl* dst = c.GetChildByInternalIDMutable( i );
if ( src && !dst )
{
// create in destination
xoDomEl* newChild = c.AllocChild( src->GetTag() );
newChild->SetDoc( &c );
c.ChildByInternalID[i] = newChild;
}
else if ( !src && dst )
{
// destroy destination. Make it forget its children, because this loop takes care of all elements.
dst->ForgetChildren();
c.FreeChild( dst );
c.ChildByInternalID[i] = nullptr;
}
}
}

// Pass 2: Clone the contents of all our modified objects into our target
for ( int i = 0; i < ChildIsModified.Size(); i++ )
{
if ( ChildIsModified.Get(i) )
{
const xoDomEl* src = GetChildByInternalID( i );
xoDomEl* dst = c.GetChildByInternalIDMutable( i );
if ( src )
src->CloneSlowInto( *dst, cloneFlags );
}
}

ClassStyles.CloneSlowInto( c.ClassStyles );
xoCloneStaticArrayWithCloneSlowInto( c.TagStyles, TagStyles );

c.Strings.CloneFrom_Incremental( Strings );

c.Version = Version;
}

bool xoDoc::ClassParse( const char* klass, const char* style )
{
xoStyle* s = ClassStyles.GetOrCreate( klass );
s->Attribs.clear();
return s->Parse( style, this );
}

xoDomEl* xoDoc::AllocChild( xoTag tag )
{
XOASSERT(tag != xoTagNULL);

// we may want to use a more specialized heap in future, so we keep this allocation path strict
if ( tag == xoTagText )
return new xoDomText( this, tag );
else
return new xoDomNode( this, tag );
}

void xoDoc::FreeChild( const xoDomEl* el )
{
// we may want to use a more specialized heap in future, so we keep this allocation path strict
delete el;
}

xoString xoDoc::Parse( const char* src )
{
return Root.Parse( src );
}

void xoDoc::ChildAdded( xoDomEl* el )
{
XOASSERT(el->GetDoc() == this);
XOASSERT(el->GetInternalID() == 0);
if ( UsableIDs.size() != 0 )
{
el->SetInternalID( UsableIDs.rpop() );
ChildByInternalID[el->GetInternalID()] = el;
}
else
{
el->SetInternalID( (xoInternalID) ChildByInternalID.size() );
ChildByInternalID += el;
}
SetChildModified( el->GetInternalID() );
}

void xoDoc::ChildAddedFromDocumentClone( xoDomEl* el )
{
xoInternalID elID = el->GetInternalID();
XOASSERTDEBUG(elID != 0);
XOASSERTDEBUG(elID < ChildByInternalID.size());		// The clone should have resized ChildByInternalID before copying the DOM elements
ChildByInternalID[elID] = el;
}

void xoDoc::ChildRemoved( xoDomEl* el )
{
xoInternalID elID = el->GetInternalID();
XOASSERT(elID != 0);
XOASSERT(el->GetDoc() == this);
IncVersion();
SetChildModified( elID );
ChildByInternalID[elID] = NULL;
el->SetDoc( NULL );
el->SetInternalID( xoInternalIDNull );
FreeIDs += elID;
}

void xoDoc::SetChildModified( xoInternalID id )
{
ChildIsModified.SetAutoGrow( id, true, false );
IncVersion();
}

void xoDoc::Reset()
{
/*
if ( IsReadOnly )
{
Root.Discard();
ClassStyles.Discard();
}
*/
IncVersion();
Pool.FreeAll();
Root.SetInternalID( xoInternalIDNull );	// Root will be assigned xoInternalIDRoot when we call ChildAdded() on it.
ChildIsModified.Clear();
ResetInternalIDs();
}

void xoDoc::ResetInternalIDs()
{
FreeIDs.clear();
UsableIDs.clear();
ChildByInternalID.clear();
ChildByInternalID += NULL;	// zero is NULL
ChildAdded( &Root );
XOASSERT( Root.GetInternalID() == xoInternalIDRoot );
}

void xoDoc::InitializeDefaultTagStyles()
{
#if XO_PLATFORM_WIN_DESKTOP
//const char* font = "Trebuchet MS";
//const char* font = "Microsoft Sans Serif";
//const char* font = "Consolas";
//const char* font = "Times New Roman";
//const char* font = "Verdana";
//const char* font = "Tahoma";
const char* font = "Segoe UI";
//const char* font = "Arial";
#elif XO_PLATFORM_ANDROID
const char* font = "Droid Sans";
#else
const char* font = "Helvetica";
#endif
xoStyleAttrib afont;
afont.SetFont( xoGlobal()->FontStore->InsertByFacename(font) );

// Other defaults are set inside xoRenderStack::Initialize()

TagStyles[xoTagBody].Parse( "background: #fff; width: 100%; height: 100%; box-sizing: margin;", this );
TagStyles[xoTagBody].Set( afont );
//TagStyles[xoTagBody].Parse( "background: #000; width: 100%; height: 100%;", this );
//TagStyles[xoTagDiv].Parse( "display: block;", this );
// Hack to give text some size
//TagStyles[xoTagText].Parse( "width: 70px; height: 30px;", this );
//TagStyles[xoTagLab]...

static_assert(xoTagLab == xoTagEND - 1, "add default style for new tag");
}

#if XO_BUILD_OPENGL

xoGLProg_Curve::xoGLProg_Curve()
{
Reset();
}

void xoGLProg_Curve::Reset()
{
ResetBase();

}

const char* xoGLProg_Curve::VertSrc()
{
return
"varying vec4 pos;\n"
"varying vec2 texuv0;\n"
"void main()\n"
"{\n"
"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"	gl_FrontColor = gl_Color;\n"
"	pos = gl_Position;\n"
"	texuv0 = gl_MultiTexCoord0.xy;\n"
"}\n"
"\n"
;
}

const char* xoGLProg_Curve::FragSrc()
{
return
"// This is from Jim Blinn and Charles Loop's paper \"Resolution Independent Curve Rendering using Programmable Graphics Hardware\"\n"
"// We don't need this complexity here.. and if I recall correctly, this technique aliases under minification faster than\n"
"// our simpler rounded-rectangle alternative.\n"
"varying vec4 pos;\n"
"varying vec2 texuv0;\n"
"\n"
"void main()\n"
"{\n"
"	vec2 p = texuv0;\n"
"\n"
"	// Gradients\n"
"	vec2 px = dFdx(p);\n"
"	vec2 py = dFdy(p);\n"
"\n"
"	// Chain rule\n"
"	float fx = (2 * p.x) * px.x - px.y;\n"
"	float fy = (2 * p.x) * py.x - py.y;\n"
"\n"
"	// Signed distance\n"
"	float sd = (p.x * p.x - p.y) / sqrt(fx * fx + fy * fy);\n"
"\n"
"	// Linear alpha\n"
"	float alpha = 0.5 - sd;\n"
"\n"
"	gl_FragColor = gl_Color;\n"
"\n"
"	if ( alpha > 1 )\n"
"		gl_FragColor.a = 1;\n"
"	else if ( alpha < 0 )\n"
"		discard;\n"
"	else\n"
"		gl_FragColor.a = alpha;\n"
"}\n"
"\n"
;
}

const char* xoGLProg_Curve::Name()
{
return "Curve";
}


bool xoGLProg_Curve::LoadVariablePositions()
{
int nfail = 0;

if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader Curve\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_Curve::PlatformMask()
{
return xoPlatform_WinDesktop | xoPlatform_LinuxDesktop;
}

xoVertexType xoGLProg_Curve::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL

xoGLProg_Fill::xoGLProg_Fill()
{
Reset();
}

void xoGLProg_Fill::Reset()
{
ResetBase();
v_mvproj = -1;
v_vpos = -1;
v_vcolor = -1;
}

const char* xoGLProg_Fill::VertSrc()
{
return
"uniform		mat4	mvproj;\n"
"attribute	vec4	vpos;\n"
"attribute	vec4	vcolor;\n"
"varying		vec4	color;\n"
"void main()\n"
"{\n"
"	gl_Position = mvproj * vpos;\n"
"	color = vec4(pow(vcolor.rgb, vec3(2.2, 2.2, 2.2)), vcolor.a);\n"
"}\n"
;
}

const char* xoGLProg_Fill::FragSrc()
{
return
"#ifdef XO_PLATFORM_ANDROID\n"
"precision mediump float;\n"
"#endif\n"
"varying vec4	color;\n"
"void main()\n"
"{\n"
"	gl_FragColor = color;\n"
"}\n"
;
}

const char* xoGLProg_Fill::Name()
{
return "Fill";
}


bool xoGLProg_Fill::LoadVariablePositions()
{
int nfail = 0;

nfail += (v_mvproj = glGetUniformLocation( Prog, "mvproj" )) == -1;
nfail += (v_vpos = glGetAttribLocation( Prog, "vpos" )) == -1;
nfail += (v_vcolor = glGetAttribLocation( Prog, "vcolor" )) == -1;
if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader Fill\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_Fill::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoGLProg_Fill::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL

xoGLProg_FillTex::xoGLProg_FillTex()
{
Reset();
}

void xoGLProg_FillTex::Reset()
{
ResetBase();
v_mvproj = -1;
v_vpos = -1;
v_vcolor = -1;
v_vtexuv0 = -1;
v_tex0 = -1;
}

const char* xoGLProg_FillTex::VertSrc()
{
return
"uniform		mat4	mvproj;\n"
"attribute	vec4	vpos;\n"
"attribute	vec4	vcolor;\n"
"attribute	vec2	vtexuv0;\n"
"varying		vec4	color;\n"
"varying		vec2	texuv0;\n"
"void main()\n"
"{\n"
"	gl_Position = mvproj * vpos;\n"
"	texuv0 = vtexuv0;\n"
"	color = vec4(pow(vcolor.rgb, vec3(2.2, 2.2, 2.2)), vcolor.a);\n"
"}\n"
;
}

const char* xoGLProg_FillTex::FragSrc()
{
return
"#ifdef XO_PLATFORM_ANDROID\n"
"precision mediump float;\n"
"#endif\n"
"uniform sampler2D	tex0;\n"
"varying vec4		color;\n"
"varying vec2		texuv0;\n"
"void main()\n"
"{\n"
"	gl_FragColor = color * texture2D(tex0, texuv0.st);\n"
"}\n"
;
}

const char* xoGLProg_FillTex::Name()
{
return "FillTex";
}


bool xoGLProg_FillTex::LoadVariablePositions()
{
int nfail = 0;

nfail += (v_mvproj = glGetUniformLocation( Prog, "mvproj" )) == -1;
nfail += (v_vpos = glGetAttribLocation( Prog, "vpos" )) == -1;
nfail += (v_vcolor = glGetAttribLocation( Prog, "vcolor" )) == -1;
nfail += (v_vtexuv0 = glGetAttribLocation( Prog, "vtexuv0" )) == -1;
nfail += (v_tex0 = glGetUniformLocation( Prog, "tex0" )) == -1;
if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader FillTex\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_FillTex::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoGLProg_FillTex::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL

xoGLProg_Rect::xoGLProg_Rect()
{
Reset();
}

void xoGLProg_Rect::Reset()
{
ResetBase();
v_mvproj = -1;
v_vpos = -1;
v_vcolor = -1;
v_radius = -1;
v_box = -1;
v_border = -1;
v_border_color = -1;
v_vport_hsize = -1;
}

const char* xoGLProg_Rect::VertSrc()
{
return
"uniform		mat4	mvproj;\n"
"attribute	vec4	vpos;\n"
"attribute	vec4	vcolor;\n"
"varying		vec4	pos;\n"
"varying		vec4	color;\n"
"void main()\n"
"{\n"
"	pos = mvproj * vpos;\n"
"	gl_Position = pos;\n"
"	color = fromSRGB(vcolor);\n"
"}\n"
;
}

const char* xoGLProg_Rect::FragSrc()
{
return
"#ifdef XO_PLATFORM_ANDROID\n"
"precision mediump float;\n"
"#endif\n"
"varying vec4	pos;\n"
"varying vec4	color;\n"
"uniform float	radius;\n"
"uniform vec4	box;\n"
"uniform vec4	border;\n"
"uniform vec4	border_color;\n"
"uniform vec2	vport_hsize;\n"
"\n"
"vec2 to_screen( vec2 unit_pt )\n"
"{\n"
"	return (vec2(unit_pt.x, -unit_pt.y) + vec2(1,1)) * vport_hsize;\n"
"}\n"
"\n"
"#define LEFT x\n"
"#define TOP y\n"
"#define RIGHT z\n"
"#define BOTTOM w\n"
"\n"
"void main()\n"
"{\n"
"	vec2 screenxy = to_screen(pos.xy);\n"
"	float radius_in = max(border.x, radius);\n"
"	float radius_out = radius;\n"
"	vec4 out_box = box + vec4(radius, radius, -radius, -radius);\n"
"	vec4 in_box = box + vec4(max(border.LEFT, radius), max(border.TOP, radius), -max(border.RIGHT, radius), -max(border.BOTTOM, radius));\n"
"\n"
"	vec2 cent_in = screenxy;\n"
"	vec2 cent_out = screenxy;\n"
"	cent_in.x = clamp(cent_in.x, in_box.LEFT, in_box.RIGHT);\n"
"	cent_in.y = clamp(cent_in.y, in_box.TOP, in_box.BOTTOM);\n"
"	cent_out.x = clamp(cent_out.x, out_box.LEFT, out_box.RIGHT);\n"
"	cent_out.y = clamp(cent_out.y, out_box.TOP, out_box.BOTTOM);\n"
"\n"
"	// If you draw the pixels out on paper, and take cognisance of the fact that\n"
"	// our samples are at pixel centers, then this -0.5 offset makes perfect sense.\n"
"	// This offset is correct regardless of whether you're blending linearly or in gamma space.\n"
"	// UPDATE: This is more subtle than it seems. By using a 0.5 offset here, and an additional 0.5 offset\n"
"	// that is fed into the shader's \"radius\" uniform, we effectively get rectangles to be sharp\n"
"	// when they are aligned to an integer grid. I haven't thought this through carefully enough,\n"
"	// but it does feel right.\n"
"	float dist_out = length(screenxy - cent_out) - 0.5;\n"
"\n"
"	float dist_in = length(screenxy - cent_in) - (radius_in - border.x);\n"
"\n"
"	vec4 outcolor = color;\n"
"\n"
"	float borderWidthX = max(border.x, border.z);\n"
"	float borderWidthY = max(border.y, border.w);\n"
"	float borderWidth = max(borderWidthX, borderWidthY);\n"
"	float borderMix = clamp(dist_in, 0.0, 1.0);\n"
"	if (borderWidth > 0.5)\n"
"		outcolor = mix(outcolor, border_color, borderMix);\n"
"\n"
"	outcolor.a *= clamp(radius_out - dist_out, 0.0, 1.0);\n"
"\n"
"#ifdef XO_SRGB_FRAMEBUFFER\n"
"	gl_FragColor = outcolor;\n"
"#else\n"
"	float igamma = 1.0/2.2;\n"
"	gl_FragColor.rgb = pow(outcolor.rgb, vec3(igamma, igamma, igamma));\n"
"	gl_FragColor.a = outcolor.a;\n"
"#endif\n"
"}\n"
;
}

const char* xoGLProg_Rect::Name()
{
return "Rect";
}


bool xoGLProg_Rect::LoadVariablePositions()
{
int nfail = 0;

nfail += (v_mvproj = glGetUniformLocation( Prog, "mvproj" )) == -1;
nfail += (v_vpos = glGetAttribLocation( Prog, "vpos" )) == -1;
nfail += (v_vcolor = glGetAttribLocation( Prog, "vcolor" )) == -1;
nfail += (v_radius = glGetUniformLocation( Prog, "radius" )) == -1;
nfail += (v_box = glGetUniformLocation( Prog, "box" )) == -1;
nfail += (v_border = glGetUniformLocation( Prog, "border" )) == -1;
nfail += (v_border_color = glGetUniformLocation( Prog, "border_color" )) == -1;
nfail += (v_vport_hsize = glGetUniformLocation( Prog, "vport_hsize" )) == -1;
if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader Rect\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_Rect::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoGLProg_Rect::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL

xoGLProg_TextRGB::xoGLProg_TextRGB()
{
Reset();
}

void xoGLProg_TextRGB::Reset()
{
ResetBase();
v_mvproj = -1;
v_vpos = -1;
v_vcolor = -1;
v_vtexuv0 = -1;
v_vtexClamp = -1;
v_tex0 = -1;
}

const char* xoGLProg_TextRGB::VertSrc()
{
return
"uniform		mat4	mvproj;\n"
"attribute	vec4	vpos;\n"
"attribute	vec4	vcolor;\n"
"attribute	vec2	vtexuv0;\n"
"attribute	vec4	vtexClamp;\n"
"varying		vec4	color;\n"
"varying		vec2	texuv0;\n"
"varying		vec4	texClamp;\n"
"void main()\n"
"{\n"
"	gl_Position = mvproj * vpos;\n"
"	texuv0 = vtexuv0;\n"
"	texClamp = vtexClamp;\n"
"	color = vec4(pow(vcolor.rgb, vec3(2.2, 2.2, 2.2)), vcolor.a);\n"
"}\n"
;
}

const char* xoGLProg_TextRGB::FragSrc()
{
return
"#version 130\n"
"\n"
"#ifdef XO_PLATFORM_ANDROID\n"
"precision mediump float;\n"
"#endif\n"
"\n"
"// This looks absolutely terrible without sRGB blending, so we simply don't even try subpixel text\n"
"// on those platforms. As it turns out, there is great correlation between low res screen (Windows)\n"
"// and a GPU capable of sRGB blending.\n"
"\n"
"uniform sampler2D	tex0;\n"
"varying vec4		color;\n"
"varying vec2		texuv0;\n"
"varying vec4		texClamp;\n"
"//layout(location = 0, index = 0) out vec4 outputColor0;\n"
"//layout(location = 0, index = 1) out vec4 outputColor1;\n"
"// On NVidia (9.18.13.3165 (10-23-2013), R331.65 (branch: r331_00-146)),\n"
"// one doesn't need the layout qualification, nor glBindFragDataLocationIndexed. The order in which you\n"
"// declare the output variables is sufficient to make an affinity with \"color0\" or \"color1\".\n"
"out		vec4		outputColor0;\n"
"out		vec4		outputColor1;\n"
"void main()\n"
"{\n"
"	float offset = 1.0 / XO_GLYPH_ATLAS_SIZE;\n"
"	vec2 uv = texuv0;\n"
"\n"
"	float tap0 = texture2D(tex0, vec2(clamp(uv.s - offset * 3.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap1 = texture2D(tex0, vec2(clamp(uv.s - offset * 2.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap2 = texture2D(tex0, vec2(clamp(uv.s - offset * 1.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap3 = texture2D(tex0, vec2(clamp(uv.s             ,   texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap4 = texture2D(tex0, vec2(clamp(uv.s + offset * 1.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap5 = texture2D(tex0, vec2(clamp(uv.s + offset * 2.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"	float tap6 = texture2D(tex0, vec2(clamp(uv.s + offset * 3.0, texClamp.x, texClamp.z), uv.t)).r;\n"
"\n"
"	float w0 = 0.56;\n"
"	float w1 = 0.28;\n"
"	float w2 = 0.16;\n"
"	//float w0 = 0.60;\n"
"	//float w1 = 0.28;\n"
"	//float w2 = 0.12;\n"
"	//float w0 = 0.98;\n"
"	//float w1 = 0.01;\n"
"	//float w2 = 0.01;\n"
"\n"
"	float r = (w2 * tap0 + w1 * tap1 + w0 * tap2 + w1 * tap3 + w2 * tap4);\n"
"	float g = (w2 * tap1 + w1 * tap2 + w0 * tap3 + w1 * tap4 + w2 * tap5);\n"
"	float b = (w2 * tap2 + w1 * tap3 + w0 * tap4 + w1 * tap5 + w2 * tap6);\n"
"	float aR = r * color.a;\n"
"	float aG = g * color.a;\n"
"	float aB = b * color.a;\n"
"	float avgA = (r + g + b) / 3.0;\n"
"	//float minA = min(r,g,min(g,b));\n"
"	// ONE MINUS SRC COLOR\n"
"	//float alpha = min(min(red, green), blue);\n"
"	//gl_FragColor = vec4(aR, aG, aB, avgA);\n"
"\n"
"	outputColor0 = vec4(color.rgb, avgA);\n"
"	outputColor1 = vec4(aR, aG, aB, avgA);\n"
"}\n"
;
}

const char* xoGLProg_TextRGB::Name()
{
return "TextRGB";
}


bool xoGLProg_TextRGB::LoadVariablePositions()
{
int nfail = 0;

nfail += (v_mvproj = glGetUniformLocation( Prog, "mvproj" )) == -1;
nfail += (v_vpos = glGetAttribLocation( Prog, "vpos" )) == -1;
nfail += (v_vcolor = glGetAttribLocation( Prog, "vcolor" )) == -1;
nfail += (v_vtexuv0 = glGetAttribLocation( Prog, "vtexuv0" )) == -1;
nfail += (v_vtexClamp = glGetAttribLocation( Prog, "vtexClamp" )) == -1;
nfail += (v_tex0 = glGetUniformLocation( Prog, "tex0" )) == -1;
if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader TextRGB\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_TextRGB::PlatformMask()
{
return xoPlatform_WinDesktop | xoPlatform_LinuxDesktop;
}

xoVertexType xoGLProg_TextRGB::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_OPENGL

xoGLProg_TextWhole::xoGLProg_TextWhole()
{
Reset();
}

void xoGLProg_TextWhole::Reset()
{
ResetBase();
v_mvproj = -1;
v_vpos = -1;
v_vcolor = -1;
v_vtexuv0 = -1;
v_tex0 = -1;
}

const char* xoGLProg_TextWhole::VertSrc()
{
return
"uniform		mat4	mvproj;\n"
"attribute	vec4	vpos;\n"
"attribute	vec4	vcolor;\n"
"attribute	vec2	vtexuv0;\n"
"varying		vec4	color;\n"
"varying		vec2	texuv0;\n"
"void main()\n"
"{\n"
"	gl_Position = mvproj * vpos;\n"
"	texuv0 = vtexuv0;\n"
"	color = vec4(pow(vcolor.rgb, vec3(2.2, 2.2, 2.2)), vcolor.a);\n"
"}\n"
;
}

const char* xoGLProg_TextWhole::FragSrc()
{
return
"#ifdef XO_PLATFORM_ANDROID\n"
"precision mediump float;\n"
"#endif\n"
"uniform sampler2D	tex0;\n"
"varying vec4		color;\n"
"varying vec2		texuv0;\n"
"void main()\n"
"{\n"
"	vec4 texCol = texture2D(tex0, texuv0.st);\n"
"	gl_FragColor = color * vec4(1,1,1, texCol.r);\n"
"}\n"
"\n"
;
}

const char* xoGLProg_TextWhole::Name()
{
return "TextWhole";
}


bool xoGLProg_TextWhole::LoadVariablePositions()
{
int nfail = 0;

nfail += (v_mvproj = glGetUniformLocation( Prog, "mvproj" )) == -1;
nfail += (v_vpos = glGetAttribLocation( Prog, "vpos" )) == -1;
nfail += (v_vcolor = glGetAttribLocation( Prog, "vcolor" )) == -1;
nfail += (v_vtexuv0 = glGetAttribLocation( Prog, "vtexuv0" )) == -1;
nfail += (v_tex0 = glGetUniformLocation( Prog, "tex0" )) == -1;
if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader TextWhole\n", nfail );

return nfail == 0;
}

uint32 xoGLProg_TextWhole::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoGLProg_TextWhole::VertexType()
{
return xoVertexType_NULL;
}

#endif // XO_BUILD_OPENGL


#if XO_BUILD_DIRECTX

xoDXProg_Fill::xoDXProg_Fill()
{
Reset();
}

void xoDXProg_Fill::Reset()
{
ResetBase();

}

const char* xoDXProg_Fill::VertSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"VSOutput main(VertexType_PTC vertex)\n"
"{\n"
"	VSOutput output;\n"
"	output.pos = mul(mvproj, vertex.pos);\n"
"	output.color = fromSRGB(vertex.color);\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_Fill::FragSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"float4 main(VSOutput input) : SV_Target\n"
"{\n"
"    return input.color;\n"
"}\n"
;
}

const char* xoDXProg_Fill::Name()
{
return "Fill";
}


bool xoDXProg_Fill::LoadVariablePositions()
{
int nfail = 0;

if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader Fill\n", nfail );

return nfail == 0;
}

uint32 xoDXProg_Fill::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoDXProg_Fill::VertexType()
{
return xoVertexType_PTC;
}

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX

xoDXProg_Rect::xoDXProg_Rect()
{
Reset();
}

void xoDXProg_Rect::Reset()
{
ResetBase();

}

const char* xoDXProg_Rect::VertSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"VSOutput main(VertexType_PTC vertex)\n"
"{\n"
"	VSOutput output;\n"
"	output.pos = mul(mvproj, vertex.pos);\n"
"	output.color = fromSRGB(vertex.color);\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_Rect::FragSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"#define LEFT x\n"
"#define TOP y\n"
"#define RIGHT z\n"
"#define BOTTOM w\n"
"\n"
"// NOTE: This is a stupid way of doing rectangles.\n"
"// Instead of rendering one big rectangle, we should be rendering it as 4 quadrants.\n"
"// This \"one big rectangle\" approach forces you to evaluate all 4 corners for every pixel.\n"
"// NOTE ALSO: This is broken, in the sense that it assumes a uniform border width.\n"
"float4 main(VSOutput input) : SV_Target\n"
"{\n"
"	float2 screenxy = frag_to_screen(input.pos.xy);\n"
"	float radius_out = radius;\n"
"	float4 mybox = box;\n"
"	float4 mycolor = input.color;\n"
"	float radius_in = max(border.x, radius); // This is why different border widths screw up.. because we're bound to border.left\n"
"	float4 out_box = mybox + float4(radius_out, radius_out, -radius_out, -radius_out);\n"
"	float4 in_box = mybox + float4(max(border.LEFT, radius), max(border.TOP, radius), -max(border.RIGHT, radius), -max(border.BOTTOM, radius));\n"
"\n"
"	float2 cent_in = screenxy;\n"
"	float2 cent_out = screenxy;\n"
"	cent_in.x = clamp(cent_in.x, in_box.LEFT, in_box.RIGHT);\n"
"	cent_in.y = clamp(cent_in.y, in_box.TOP, in_box.BOTTOM);\n"
"	cent_out.x = clamp(cent_out.x, out_box.LEFT, out_box.RIGHT);\n"
"	cent_out.y = clamp(cent_out.y, out_box.TOP, out_box.BOTTOM);\n"
"\n"
"	// If you draw the pixels out on paper, and take cognisance of the fact that\n"
"	// our samples are at pixel centers, then this -0.5 offset makes perfect sense.\n"
"	// This offset is correct regardless of whether you're blending linearly or in gamma space.\n"
"	// UPDATE: This is more subtle than it seems. By using a 0.5 offset here, and an additional 0.5 offset\n"
"	// that is fed into the shader's \"radius\" uniform, we effectively get rectangles to be sharp\n"
"	// when they are aligned to an integer grid. I haven't thought this through carefully enough,\n"
"	// but it does feel right.\n"
"	float dist_out = length(screenxy - cent_out) - 0.5f;\n"
"\n"
"	float dist_in = length(screenxy - cent_in) - (radius_in - border.x);\n"
"\n"
"	// I don't like this \"if (borderWidth > 0.5f)\". I feel like I'm doing something\n"
"	// wrong here, but I haven't drawn it out carefully enough to know what that something is.\n"
"	// When you rewrite this function to render quadrants, then perhaps fix this up too.\n"
"	float borderWidthX = max(border.x, border.z);\n"
"	float borderWidthY = max(border.y, border.w);\n"
"	float borderWidth = max(borderWidthX, borderWidthY);\n"
"	float borderMix = clamp(dist_in, 0.0f, 1.0f);\n"
"	if (borderWidth > 0.5f)\n"
"		mycolor = lerp(mycolor, border_color, borderMix);\n"
"\n"
"	float4 output;\n"
"	output.rgb = mycolor.rgb;\n"
"	output.a = mycolor.a * clamp(radius_out - dist_out, 0.0f, 1.0f);\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_Rect::Name()
{
return "Rect";
}


bool xoDXProg_Rect::LoadVariablePositions()
{
int nfail = 0;

if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader Rect\n", nfail );

return nfail == 0;
}

uint32 xoDXProg_Rect::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoDXProg_Rect::VertexType()
{
return xoVertexType_PTC;
}

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX

xoDXProg_TextRGB::xoDXProg_TextRGB()
{
Reset();
}

void xoDXProg_TextRGB::Reset()
{
ResetBase();

}

const char* xoDXProg_TextRGB::VertSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 uvClamp	: TEXCOORD1;\n"
"};\n"
"\n"
"VSOutput main(VertexType_PTCV4 vertex)\n"
"{\n"
"	VSOutput output;\n"
"	output.pos = mul(mvproj, vertex.pos);\n"
"	output.color = fromSRGB(vertex.color);\n"
"	output.uv = vertex.uv;\n"
"	output.uvClamp = vertex.v4;\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_TextRGB::FragSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 uvClamp	: TEXCOORD1;\n"
"};\n"
"\n"
"struct PSOutput\n"
"{\n"
"	float4 color0	: SV_Target0;\n"
"	float4 color1	: SV_Target1;\n"
"};\n"
"\n"
"PSOutput main(VSOutput input)\n"
"{\n"
"	//float4 col;\n"
"	//col = input.color * float4(1,1,1, shader_texture.Sample(sample_type, input.texuv0).r);\n"
"    //return col;\n"
"\n"
"	float offset = 1.0 / XO_GLYPH_ATLAS_SIZE;\n"
"	float2 uv = input.uv;\n"
"	float4 clamps = input.uvClamp;\n"
"\n"
"	float tap0 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 3.0, clamps.x, clamps.z), uv.y)).r;\n"
"	float tap1 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 2.0, clamps.x, clamps.z), uv.y)).r;\n"
"	float tap2 = shader_texture.Sample(sample_type, float2(clamp(uv.x - offset * 1.0, clamps.x, clamps.z), uv.y)).r;\n"
"	float tap3 = shader_texture.Sample(sample_type, float2(clamp(uv.x             ,   clamps.x, clamps.z), uv.y)).r;\n"
"	float tap4 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 1.0, clamps.x, clamps.z), uv.y)).r;\n"
"	float tap5 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 2.0, clamps.x, clamps.z), uv.y)).r;\n"
"	float tap6 = shader_texture.Sample(sample_type, float2(clamp(uv.x + offset * 3.0, clamps.x, clamps.z), uv.y)).r;\n"
"\n"
"	float w0 = 0.56;\n"
"	float w1 = 0.28;\n"
"	float w2 = 0.16;\n"
"	//float w0 = 0.60;\n"
"	//float w1 = 0.28;\n"
"	//float w2 = 0.12;\n"
"	//float w0 = 0.98;\n"
"	//float w1 = 0.01;\n"
"	//float w2 = 0.01;\n"
"\n"
"	float r = (w2 * tap0 + w1 * tap1 + w0 * tap2 + w1 * tap3 + w2 * tap4);\n"
"	float g = (w2 * tap1 + w1 * tap2 + w0 * tap3 + w1 * tap4 + w2 * tap5);\n"
"	float b = (w2 * tap2 + w1 * tap3 + w0 * tap4 + w1 * tap5 + w2 * tap6);\n"
"	float aR = r * input.color.a;\n"
"	float aG = g * input.color.a;\n"
"	float aB = b * input.color.a;\n"
"	float avgA = (r + g + b) / 3.0;\n"
"	//float minA = min(r,g,min(g,b));\n"
"	// ONE MINUS SRC COLOR\n"
"	//float alpha = min(min(red, green), blue);\n"
"	//gl_FragColor = vec4(aR, aG, aB, avgA);\n"
"\n"
"	PSOutput output;\n"
"	output.color0 = float4(input.color.rgb, avgA);\n"
"	output.color1 = float4(aR, aG, aB, avgA);\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_TextRGB::Name()
{
return "TextRGB";
}


bool xoDXProg_TextRGB::LoadVariablePositions()
{
int nfail = 0;

if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader TextRGB\n", nfail );

return nfail == 0;
}

uint32 xoDXProg_TextRGB::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoDXProg_TextRGB::VertexType()
{
return xoVertexType_PTCV4;
}

#endif // XO_BUILD_DIRECTX


#if XO_BUILD_DIRECTX

xoDXProg_TextWhole::xoDXProg_TextWhole()
{
Reset();
}

void xoDXProg_TextWhole::Reset()
{
ResetBase();

}

const char* xoDXProg_TextWhole::VertSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"	float2 texuv0	: TEXCOORD0;\n"
"};\n"
"\n"
"VSOutput main(VertexType_PTC vertex)\n"
"{\n"
"	VSOutput output;\n"
"	output.pos = mul(mvproj, vertex.pos);\n"
"	output.color = fromSRGB(vertex.color);\n"
"	output.texuv0 = vertex.uv;\n"
"	return output;\n"
"}\n"
;
}

const char* xoDXProg_TextWhole::FragSrc()
{
return
"\n"
"cbuffer PerFrame : register(b0)\n"
"{\n"
"	float4x4		mvproj;\n"
"	float2			vport_hsize;\n"
"\n"
"	Texture2D		shader_texture;\n"
"	SamplerState	sample_type;\n"
"};\n"
"\n"
"cbuffer PerObject : register(b1)\n"
"{\n"
"	float4		box;\n"
"	float4		border;\n"
"	float4		border_color;\n"
"	float		radius;\n"
"};\n"
"\n"
"struct VertexType_PTC\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD0;\n"
"	float4 color	: COLOR;\n"
"};\n"
"\n"
"struct VertexType_PTCV4\n"
"{\n"
"	float4 pos		: POSITION;\n"
"	float2 uv		: TEXCOORD1;\n"
"	float4 color	: COLOR;\n"
"	float4 v4		: TEXCOORD2;\n"
"};\n"
"\n"
"float fromSRGB_Component(float srgb)\n"
"{\n"
"	float sRGB_Low	= 0.0031308;\n"
"	float sRGB_a	= 0.055;\n"
"\n"
"	if (srgb <= 0.04045)\n"
"		return srgb / 12.92;\n"
"	else\n"
"		return pow(abs((srgb + sRGB_a) / (1.0 + sRGB_a)), 2.4);\n"
"}\n"
"\n"
"float4 fromSRGB(float4 c)\n"
"{\n"
"	float4 linear_c;\n"
"	linear_c.r = fromSRGB_Component(c.r);\n"
"	linear_c.g = fromSRGB_Component(c.g);\n"
"	linear_c.b = fromSRGB_Component(c.b);\n"
"	linear_c.a = c.a;\n"
"	return linear_c;\n"
"}\n"
"\n"
"// SV_Position is in screen space, but in GLSL it is in normalized device space\n"
"float2 frag_to_screen(float2 unit_pt)\n"
"{\n"
"	return unit_pt;\n"
"}\n"
"\n"
"struct VSOutput\n"
"{\n"
"	float4 pos		: SV_Position;\n"
"	float4 color	: COLOR;\n"
"	float2 texuv0	: TEXCOORD0;\n"
"};\n"
"\n"
"float4 main(VSOutput input) : SV_Target\n"
"{\n"
"	float4 col;\n"
"	col = input.color * float4(1,1,1, shader_texture.Sample(sample_type, input.texuv0).r);\n"
"    return col;\n"
"}\n"
;
}

const char* xoDXProg_TextWhole::Name()
{
return "TextWhole";
}


bool xoDXProg_TextWhole::LoadVariablePositions()
{
int nfail = 0;

if ( nfail != 0 )
XOTRACE( "Failed to bind %d variables of shader TextWhole\n", nfail );

return nfail == 0;
}

uint32 xoDXProg_TextWhole::PlatformMask()
{
return xoPlatform_All;
}

xoVertexType xoDXProg_TextWhole::VertexType()
{
return xoVertexType_PTC;
}

#endif // XO_BUILD_DIRECTX



AbcQueue::AbcQueue()
{
//mtlog_open();
Tail = 0;
Head = 0;
RingSize = 0;
ItemSize = 0;
Buffer = NULL;
HaveSemaphore = false;
AbcCriticalSectionInitialize( Lock, 4000 );
}

AbcQueue::~AbcQueue()
{
free(Buffer);
if ( HaveSemaphore ) AbcSemaphoreDestroy( Semaphore );
AbcCriticalSectionDestroy( Lock );
}

void AbcQueue::Initialize( bool useSemaphore, size_t itemSize )
{
AbcAssert( SizeInternal() == 0 );
if ( itemSize != this->ItemSize )
{
AbcAssert( this->ItemSize == 0 );
AbcAssert( itemSize > 0 );
AbcAssert( itemSize < 0xffff );		// sanity
ItemSize = (u32) itemSize;
}
AbcAssert( !HaveSemaphore );
if ( useSemaphore )
{
HaveSemaphore = true;
AbcSemaphoreInitialize( Semaphore );
}
}

void AbcQueue::Add( const void* item )
{
TakeCriticalSection lock(Lock);

if ( SizeInternal() >= (int32) RingSize - 1 )
Grow();

memcpy( Slot(Head), item, ItemSize );
Increment( Head );

if ( HaveSemaphore )
AbcSemaphoreRelease( Semaphore, 1 );
}

bool AbcQueue::PopTail( void* item )
{
TakeCriticalSection lock(Lock);
if ( SizeInternal() == 0 ) return false;
memcpy( item, Slot(Tail), ItemSize );
//mtlog( "pop %d:%d", (int) Tail, (int) *((u64*) item) );
Increment( Tail );
return true;
}

bool AbcQueue::PeekTail( void* item )
{
TakeCriticalSection lock(Lock);
if ( SizeInternal() == 0 ) return false;
memcpy( item, Slot(Tail), ItemSize );
return true;
}

void AbcQueue::Grow()
{
u32 newsize = std::max(RingSize * 2, (u32) 2);
void* nb = realloc( Buffer, (size_t) ItemSize * newsize );
AbcAssert(nb != NULL);
Buffer = nb;
// If head is behind tail, then we need to copy the later items in front of the earlier ones.
if ( Head < Tail )
{
//mtlog( "Grow + swap (%d - %d)\n", (int) RingSize, (int) newsize );
memcpy( Slot(RingSize), Slot(0), (size_t) ItemSize * Head );
Head = RingSize + Head;
}
else
{
//mtlog( "Grow straight (%d - %d)\n", (int) RingSize, (int) newsize );
}
RingSize = newsize;
}

int32 AbcQueue::Size()
{
TakeCriticalSection lock(Lock);
return SizeInternal();
}

#ifndef _WIN32
#endif

#ifdef _WIN32
PAPI void			AbcMachineInformationGet( AbcMachineInformation& info )
{
memset( &info, 0, sizeof(info) );

SYSTEM_INFO inf;
GetSystemInfo( &inf );
info.LogicalCoreCount = inf.dwNumberOfProcessors;
info.PhysicalCoreCount = inf.dwNumberOfProcessors;

SYSTEM_LOGICAL_PROCESSOR_INFORMATION log[256];
DWORD logSize = sizeof(log);
if ( GetLogicalProcessorInformation( log, &logSize ) )
{
info.PhysicalCoreCount = 0;
for ( uint i = 0; i < logSize / sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); i++ )
{
if ( log[i].Relationship == RelationProcessorCore )
info.PhysicalCoreCount++;
}
}

MEMORYSTATUSEX stat;
stat.dwLength = sizeof(stat);
if ( GlobalMemoryStatusEx( &stat ) == TRUE )
info.PhysicalMemory = stat.ullTotalPhys;
}
#else
PAPI void			AbcMachineInformationGet( AbcMachineInformation& info )
{
memset( &info, 0, sizeof(info) );
info.LogicalCoreCount = sysconf( _SC_NPROCESSORS_ONLN );
info.PhysicalCoreCount = sysconf( _SC_NPROCESSORS_ONLN );
uint64 ps = sysconf( _SC_PAGESIZE );
uint64 pn = sysconf( _SC_PHYS_PAGES );
info.PhysicalMemory = ps * pn;
}
#endif

PAPI uint64			AbcPhysicalMemory()
{
AbcMachineInformation inf;
AbcMachineInformationGet( inf );
return inf.PhysicalMemory;
}


static bool AllowGUI = true;

PAPI int AbcPanicMsg(const char* file, int line, const char* msg)
{
char buf[1024];
if ( msg )	sprintf( buf, "Critical Error: %s(%d)\n%s", file, line, msg);
else		sprintf( buf, "Critical Error: %s(%d)", file, line);
buf[arraysize(buf) - 1] = 0;
bool showGui = AllowGUI;
#if !defined(MessageBox)
showGui = false;
#endif

if ( showGui )
{
#if defined(MessageBox)
MessageBoxA( NULL, buf, "Error", MB_OK | MB_ICONERROR );
#endif
}
else
{
fputs( "AbcPanicMsg: ", stdout );
fputs( buf, stdout );
fflush( stdout );
}
return 0;
}

PAPI NORETURN void AbcDie()
{
#ifdef _MSC_VER
__debugbreak();
#endif
exit(1);
}

PAPI void* AbcReallocOrDie( void* p, size_t bytes )
{
void* buf = realloc( p, bytes );
AbcCheckAlloc(buf);
return buf;
}

PAPI void* AbcMallocOrDie( size_t bytes )
{
void* buf = malloc(bytes);
AbcCheckAlloc(buf);
return buf;
}

PAPI bool AbcAllowGUI()
{
return AllowGUI;
}

PAPI void AbcSetAllowGUI( bool allowGUI )
{
AllowGUI = allowGUI;
}



#ifdef _WIN32
#endif

#ifndef _WIN32
#endif

#ifdef _WIN32

#if XSTRING_DEFINED
PAPI bool			AbcProcessCreate( const char* cmd, AbcForkedProcessHandle* handle, AbcProcessID* pid )
{
XStringW c = cmd;
STARTUPINFO si;
PROCESS_INFORMATION pi;
memset(&si, 0, sizeof(si));
memset(&pi, 0, sizeof(pi));
si.cb = sizeof(si);
if ( !CreateProcess( NULL, c.GetRawBuffer(), NULL, NULL, false, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi ) )
return false;
CloseHandle( pi.hThread );
if ( handle )
*handle = pi.hProcess;
else
CloseHandle( pi.hProcess );
if ( pid )
*pid = pi.dwProcessId;
return true;
}
#endif
PAPI bool			AbcProcessWait( AbcForkedProcessHandle handle, int* exitCode )
{
if ( WaitForSingleObject( handle, INFINITE ) == WAIT_OBJECT_0 )
{
if ( exitCode )
{
DWORD code = 0;
GetExitCodeProcess( handle, &code );
*exitCode = code;
}
return true;
}
return false;
}
PAPI void 			AbcProcessCloseHandle( AbcForkedProcessHandle handle )
{
CloseHandle( handle );
}
PAPI AbcProcessID	AbcProcessGetPID()
{
return GetCurrentProcessId();
}
PAPI void			AbcProcessGetPath( char* path, size_t maxPath )
{
wchar_t* tmp = new wchar_t[maxPath];
GetModuleFileNameW( NULL, tmp, (DWORD) maxPath );
tmp[maxPath - 1] = 0;
ConvertWideToUTF8( tmp, -1, path, maxPath );
delete[] tmp;
}
#if XSTRING_DEFINED
PAPI XString		AbcProcessGetPath()
{
wchar_t p[MAX_PATH];
GetModuleFileNameW( NULL, p, (DWORD) arraysize(p) );
p[MAX_PATH - 1] = 0;
return p;
}
#endif
PAPI void			AbcProcessesEnum( podvec<AbcProcessID>& pids )
{
DWORD id_static[1024];
DWORD* id = id_static;
DWORD id_size = sizeof(id_static);
DWORD id_used = 0;
while ( true )
{
id_used = 0;
EnumProcesses( id, id_size, &id_used );
if ( id_used == id_size )
{
// likely need more space
if ( id == id_static )
id = (DWORD*) AbcMallocOrDie( id_size );
else
id = (DWORD*) AbcReallocOrDie( id, id_size );
}
else
{
break;
}
}
pids.resize_uninitialized( id_used / sizeof(DWORD) );
memcpy( &pids[0], id, id_used );
if ( id != id_static )
free(id);
}
PAPI void			AbcProcessGetStatistics( AbcProcessStatistics& stats )
{
memset( &stats, 0, sizeof(stats) );
PROCESS_MEMORY_COUNTERS_EX p;
GetProcessMemoryInfo( GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS*) &p, sizeof(p) );
stats.WorkingSetBytes = p.WorkingSetSize;
stats.MaxWorkingSetBytes = p.PeakWorkingSetSize;

MEMORYSTATUSEX stat;
stat.dwLength = sizeof(stat);
if ( GlobalMemoryStatusEx( &stat ) == TRUE )
{
uint64 tot = stat.ullTotalVirtual;
uint64 avail = stat.ullAvailVirtual;
stats.AddressSpaceCommittedBytes = (size_t) (tot - avail);
}

FILETIME create, exit, kernel, user;
GetProcessTimes( GetCurrentProcess(), &create, &exit, &kernel, &user );

stats.KernelCpuTimeMicroseconds = AbcFileTimeToMicroseconds( kernel );
stats.UserCpuTimeMicroseconds = AbcFileTimeToMicroseconds( user );
}

#else
// linux

PAPI bool			AbcProcessCreate( const char* cmd, AbcForkedProcessHandle* handle, AbcProcessID* pid )
{
AbcAssert(false);
}
PAPI bool			AbcProcessWait( AbcForkedProcessHandle handle, int* exitCode )
{
AbcAssert(false);
}
PAPI void			AbcProcessCloseHandle( AbcForkedProcessHandle handle )
{
AbcAssert(false);
}
PAPI AbcProcessID	AbcProcessGetPID()
{
return getpid();
}
PAPI void			AbcProcessGetPath( char* path, size_t maxPath )
{
AbcAssert(false); // untested code
if ( maxPath == 0 )
return;
path[0] = 0;
size_t r = readlink( "/proc/self/exe", path, maxPath - 1 );
if ( r == -1 )
return;
path[r] = 0;
}
#if XSTRING_DEFINED
PAPI XString		AbcProcessGetPath()
{
// arbitrary thumbsuck constant
char p[2048];
AbcProcessGetPath( p, sizeof(p) );
p[sizeof(p) - 1] = 0;
return XString::FromUtf8(p);
}
#endif
PAPI void			AbcProcessesEnum( podvec<AbcProcessID>& pids )
{
AbcAssert(false);
}
PAPI void			AbcProcessGetStatistics( AbcProcessStatistics& stats )
{
memset( &stats, 0, sizeof(stats) );
rusage r;
getrusage( RUSAGE_SELF, &r );
stats.MaxWorkingSetBytes = (u64) r.ru_maxrss * 1024;
stats.WorkingSetBytes = stats.MaxWorkingSetBytes;
stats.AddressSpaceCommittedBytes = 0;
stats.UserCpuTimeMicroseconds = r.ru_utime.tv_sec * 1000000 + r.ru_utime.tv_usec;
stats.KernelCpuTimeMicroseconds = r.ru_stime.tv_sec * 1000000 + r.ru_stime.tv_usec;

}
#endif

PAPI uint64			AbcProcessWorkingSetBytes()
{
AbcProcessStatistics stats;
AbcProcessGetStatistics( stats );
return stats.WorkingSetBytes;
}

PAPI uint64			AbcProcessMaxWorkingSetBytes()
{
AbcProcessStatistics stats;
AbcProcessGetStatistics( stats );
return stats.MaxWorkingSetBytes;
}

PAPI uint64			AbcProcessVirtualCommittedBytes()
{
AbcProcessStatistics stats;
AbcProcessGetStatistics( stats );
return stats.AddressSpaceCommittedBytes;
}


#ifndef _WIN32
#endif

bool AbcFilesystemFindFiles( const char* _dir, std::function<bool(const AbcFilesystemItem& item)> callback )
{
size_t dirLen = strlen(_dir);
if ( dirLen == 0 )
return false;

#ifdef _WIN32
std::string fixed = _dir;
if ( _dir[dirLen - 1] == '\\' )
fixed.pop_back();

WIN32_FIND_DATAA fd;
HANDLE handle = FindFirstFileA( (fixed + "\\*").c_str(), &fd );
AbcFilesystemItem item;
item.Root = fixed.c_str();
while ( handle != INVALID_HANDLE_VALUE )
{
bool ignore =	(fd.cFileName[0] == '.' && fd.cFileName[1] == 0) ||
(fd.cFileName[0] == '.' && fd.cFileName[1] == '.' && fd.cFileName[2] == 0);
if ( !ignore )
{
item.IsDir = !!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
item.Name = fd.cFileName;
item.TimeModify = AbcFileTimeToUnixSeconds( fd.ftLastWriteTime );
bool res = callback( item );
if ( item.IsDir )
{
if ( res )
AbcFilesystemFindFiles( (fixed + "\\" + item.Name).c_str(), callback );
}
else
{
if ( !res )
break;
}
}
if ( FALSE == FindNextFileA( handle, &fd ) )
break;
}
bool ok = handle != INVALID_HANDLE_VALUE || GetLastError() == ERROR_FILE_NOT_FOUND;
if ( handle != INVALID_HANDLE_VALUE )
FindClose( handle );
return ok;
#else
std::string fixed = _dir;
if ( _dir[dirLen - 1] == '/' )
fixed.pop_back();

DIR* d = opendir( fixed.c_str() );
if ( d )
{
AbcFilesystemItem item;
item.Root = fixed.c_str();
struct dirent block;
struct dirent* iter = nullptr;
while ( readdir_r(d, &block, &iter) == 0 && iter != nullptr )
{
if ( strcmp(iter->d_name, ".") == 0 ) continue;
if ( strcmp(iter->d_name, "..") == 0 ) continue;
item.IsDir = iter->d_type == DT_DIR;
item.Name = iter->d_name;
struct stat st;
if ( stat( (fixed + "/" + iter->d_name).c_str(), &st ) != 0 )
continue;
item.TimeModify = st.st_mtim.tv_sec + st.st_mtim.tv_nsec * (1.0 / 1000000000);
bool res = callback( item );
if ( item.IsDir )
{
if ( res )
AbcFilesystemFindFiles( (fixed + "/" + item.Name).c_str(), callback );
}
else
{
if ( !res )
break;
}
}
closedir( d );
}
#endif
}


#ifdef _WIN32
#define open _open
#define close _close
#define lseek _lseek
#else
#endif

// In linux you can use named semaphores for ipc mutex.
// Android doesn't support named semaphores though.
#ifdef _WIN32
PAPI void			AbcMutexCreate( AbcMutex& mutex, const char* name )
{
mutex = CreateMutexA( NULL, false, name );
}
PAPI void			AbcMutexDestroy( AbcMutex& mutex )
{
CloseHandle( mutex );
}
PAPI bool			AbcMutexWait( AbcMutex& mutex, DWORD waitMS )
{
return WaitForSingleObject( mutex, waitMS ) == WAIT_OBJECT_0;
}
PAPI void			AbcMutexRelease( AbcMutex& mutex )
{
ReleaseMutex( mutex );
}

PAPI void			AbcCriticalSectionInitialize( AbcCriticalSection& cs, unsigned int spinCount )
{
if ( spinCount != 0 )	AbcVerify( InitializeCriticalSectionAndSpinCount( &cs, spinCount ) );
else					InitializeCriticalSection( &cs );
}
PAPI void			AbcCriticalSectionDestroy( AbcCriticalSection& cs )
{
DeleteCriticalSection( &cs );
}
PAPI bool			AbcCriticalSectionTryEnter( AbcCriticalSection& cs )
{
return !!TryEnterCriticalSection( &cs );
}
PAPI void			AbcCriticalSectionEnter( AbcCriticalSection& cs )
{
EnterCriticalSection( &cs );
}
PAPI void			AbcCriticalSectionLeave( AbcCriticalSection& cs )
{
LeaveCriticalSection( &cs );
}

PAPI void			AbcSemaphoreInitialize( AbcSemaphore& sem )
{
sem = CreateSemaphore( NULL, 0, 0x7fffffff, NULL );
}
PAPI void			AbcSemaphoreDestroy( AbcSemaphore& sem )
{
CloseHandle( sem );
sem = NULL;
}
PAPI bool			AbcSemaphoreWait( AbcSemaphore& sem, DWORD waitMS )
{
return WaitForSingleObject( sem, waitMS ) == WAIT_OBJECT_0;
}
PAPI void			AbcSemaphoreRelease( AbcSemaphore& sem, DWORD count )
{
ReleaseSemaphore( sem, (LONG) count, NULL );
}

PAPI void			AbcSleep( int milliseconds )
{
YieldProcessor();
Sleep( milliseconds );
}

#else // End Win32

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Linux
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void MillisecondsToAbsTimespec( DWORD ms, timespec& t )
{
clock_gettime( CLOCK_REALTIME, &t );
t.tv_sec += ms / 1000;
t.tv_nsec += (ms % 1000) * 1000;
if ( t.tv_nsec >= 1000000 )
{
t.tv_sec += 1;
t.tv_nsec -= 1000000;
}
}

// Android (at ndk-r9) does not have pthread_mutex_timedlock.
// This is an absolutely horrible workaround.
static bool pthread_mutex_timedlock_emulate_ms( AbcMutex& mutex, DWORD waitMS )
{
AbcAssert( waitMS > 0 );
for ( DWORD ms = 0; ms < waitMS; ms++ )
{
if ( 0 == pthread_mutex_trylock( &mutex ) )
return true;
AbcSleep( 1 );
}
return false;
}

PAPI void			AbcMutexCreate( AbcMutex& mutex, const char* name )
{
AbcAssert( name == NULL || name[0] == 0 );
AbcVerify( 0 == pthread_mutex_init( &mutex, NULL ) );
}
PAPI void			AbcMutexDestroy( AbcMutex& mutex )
{
AbcVerify( 0 == pthread_mutex_destroy( &mutex ) );
}
PAPI bool			AbcMutexWait( AbcMutex& mutex, DWORD waitMS )
{
if ( waitMS == 0 )
return 0 == pthread_mutex_trylock( &mutex );
else if ( waitMS == AbcINFINITE )
return 0 == pthread_mutex_lock( &mutex );
else
{
#ifdef ANDROID
return pthread_mutex_timedlock_emulate_ms( mutex, waitMS );
#else
timespec t;
MillisecondsToAbsTimespec( waitMS, t );
return 0 == pthread_mutex_timedlock( &mutex, &t );
#endif
}
}
PAPI void			AbcMutexRelease( AbcMutex& mutex )
{
pthread_mutex_unlock( &mutex );
}

PAPI void			AbcCriticalSectionInitialize( AbcCriticalSection& cs, unsigned int spinCount )
{
AbcVerify( 0 == pthread_mutex_init( &cs, NULL ) );
}
PAPI void			AbcCriticalSectionDestroy( AbcCriticalSection& cs )
{
AbcVerify( 0 == pthread_mutex_destroy( &cs ) );
}
PAPI bool			AbcCriticalSectionTryEnter( AbcCriticalSection& cs )
{
return 0 == pthread_mutex_trylock( &cs );
}
PAPI void			AbcCriticalSectionEnter( AbcCriticalSection& cs )
{
pthread_mutex_lock( &cs );
}
PAPI void			AbcCriticalSectionLeave( AbcCriticalSection& cs )
{
pthread_mutex_unlock( &cs );
}

PAPI void			AbcSemaphoreInitialize( AbcSemaphore& sem )
{
AbcVerify( 0 == sem_init( &sem, 0, 0 ) );
}
PAPI void			AbcSemaphoreDestroy( AbcSemaphore& sem )
{
AbcVerify( 0 == sem_destroy( &sem ) );
}
PAPI bool			AbcSemaphoreWait( AbcSemaphore& sem, DWORD waitMS )
{
if ( waitMS == 0 )
return 0 == sem_trywait( &sem );
else if ( waitMS == AbcINFINITE )
return 0 == sem_wait( &sem );
else
{
timespec t;
MillisecondsToAbsTimespec( waitMS, t );
return 0 == sem_timedwait( &sem, &t );
}
}
PAPI void			AbcSemaphoreRelease( AbcSemaphore& sem, DWORD count )
{
for ( DWORD i = 0; i < count; i++ )
sem_post( &sem );
}


PAPI void			AbcSleep( int milliseconds )
{
int64 nano = milliseconds * (int64) 1000;
timespec t;
t.tv_nsec = nano % 1000000000;
t.tv_sec = (nano - t.tv_nsec) / 1000000000;
nanosleep( &t, NULL );
}

#endif

PAPI int			AbcLockFileLock( const char* path )
{
#ifdef _WIN32
int mode = _S_IREAD | _S_IWRITE;
#else
int mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
#endif

int f = open( path, O_CREAT | O_WRONLY, mode );
if ( f == -1 )
return -1;

#ifdef _WIN32
int lock = _locking( f, _LK_NBLCK, 1 );
#else
int lock = lockf( f, F_TLOCK, 1 );
#endif
if ( lock == -1 )
{
close( f );
return -1;
}

return f;
}

PAPI void			AbcLockFileRelease( int f )
{
if ( f == -1 )
return;

lseek( f, 0, SEEK_SET );
#ifdef _WIN32
_locking( f, _LK_UNLCK, 1 );
#else
lockf( f, F_ULOCK, 1 );
#endif
close( f );
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// Cross-platform helpers

PAPI void		AbcSpinLockWait( volatile unsigned int* p )
{
while ( AbcCmpXChg( p, 1, 0 ) != 0 )
{
}
}

PAPI void		AbcSpinLockRelease( volatile unsigned int* p )
{
AbcAssert( *p == 1 );
AbcInterlockedSet( p, 0 );
}

PAPI void		AbcCriticalSectionInitialize( AbcGuardedCriticalSection& cs, unsigned int spinCount )
{
AbcCriticalSectionInitialize( cs.CS, spinCount );
cs.ThreadID = 0;
}

PAPI void		AbcCriticalSectionDestroy( AbcGuardedCriticalSection& cs )
{
AbcAssert( cs.ThreadID == 0 );
AbcCriticalSectionDestroy( cs.CS );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

TakeCriticalSection::TakeCriticalSection( AbcCriticalSection& cs )
{
CS = reinterpret_cast<AbcGuardedCriticalSection*>(&cs);
UseGuard = false;
AbcCriticalSectionEnter( CS->CS );
}

TakeCriticalSection::TakeCriticalSection( AbcGuardedCriticalSection& cs )
{
CS = &cs;
UseGuard = true;
AbcCriticalSectionEnter( CS->CS );
// On ARM one would have to use mintomic here and do a proper acquire on ThreadID
AbcAssert( CS->ThreadID == 0 );
CS->ThreadID = AbcThreadCurrentID();
}

TakeCriticalSection::~TakeCriticalSection()
{
if ( UseGuard )
{
AbcAssert( CS->ThreadID == AbcThreadCurrentID() );
CS->ThreadID = 0;
// On ARM one would have to use mintomic here and do a proper release on ThreadID
}
AbcCriticalSectionLeave( CS->CS );
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _WIN32
AbcSyncEvent::AbcSyncEvent()
{
Persistent = false;
Initialized = false;
}
#endif

AbcSyncEvent::~AbcSyncEvent()
{
Destroy();
}

void AbcSyncEvent::Initialize( bool persistent )
{
#ifdef _WIN32
Event = CreateEvent( NULL, persistent, false, NULL );
#else
Persistent = persistent;
Initialized = true;
AbcSemaphoreInitialize( Sem );
#endif
}

void AbcSyncEvent::Destroy()
{
#ifdef _WIN32
if ( Event != NULL )
CloseHandle( Event );
Event = NULL;
#else
if ( Initialized )
AbcSemaphoreDestroy( Sem );
Initialized = false;
#endif
}

void AbcSyncEvent::Signal()
{
#ifdef _WIN32
AbcAssert( Event != NULL );
SetEvent( Event );
#else
AbcAssert( Initialized );
// When Persistent=true, this is racy (explained in the main comments)
AbcSemaphoreRelease( Sem, Persistent ? PersistentPostCount : 1 );
#endif
}

bool AbcSyncEvent::Wait( DWORD waitMS )
{
#ifdef _WIN32
return WaitForSingleObject( Event, waitMS ) == WAIT_OBJECT_0;
#else
if ( AbcSemaphoreWait( Sem, waitMS ) )
{
if ( Persistent )
{
// this is racy (explained in the main comments)
AbcSemaphoreRelease( Sem, 1 );
}
return true;
}
return false;
#endif
}

#ifdef _WIN32
#undef open
#undef close
#undef lseek
#endif


#ifdef _WIN32
static int32	CachedPerformanceFrequency_Set;
static double	CachedPerformanceFrequency_Inv;
#endif

#ifdef _WIN32
PAPI double AbcTimeAccurateRTSeconds()
{
if ( CachedPerformanceFrequency_Set == 0 )
{
LARGE_INTEGER tmp;
QueryPerformanceFrequency( &tmp );
CachedPerformanceFrequency_Inv = 1.0 / (double) tmp.QuadPart;
MemoryBarrier();
CachedPerformanceFrequency_Set = 1;
}
LARGE_INTEGER t;
QueryPerformanceCounter( &t );
return t.QuadPart * CachedPerformanceFrequency_Inv;
}
#else
PAPI double AbcTimeAccurateRTSeconds()
{
timespec t;
clock_gettime( CLOCK_MONOTONIC, &t );
return t.tv_sec + t.tv_nsec * (1.0 / 1000000000);
}
#endif


#ifdef _WIN32

PAPI bool			AbcThreadCreate( AbcThreadFunc threadfunc, void* context, AbcThreadHandle& handle )
{
handle = CreateThread( NULL, 0, threadfunc, context, 0, NULL );
return NULL != handle;
}
PAPI bool			AbcThreadJoin( AbcThreadHandle handle )
{
return WaitForSingleObject( handle, INFINITE ) == WAIT_OBJECT_0;
}
PAPI void			AbcThreadCloseHandle( AbcThreadHandle handle )
{
CloseHandle( handle );
}
PAPI AbcThreadHandle AbcThreadCurrent()
{
return GetCurrentThread();
}
PAPI AbcThreadID	AbcThreadCurrentID()
{
return GetCurrentThreadId();
}
PAPI bool AbcThreadIDEqual( AbcThreadID a, AbcThreadID b )
{
return a == b;
}
PAPI void			AbcThreadSetPriority( AbcThreadHandle handle, AbcThreadPriority priority )
{
DWORD p = THREAD_PRIORITY_NORMAL;
switch( priority )
{
case AbcThreadPriorityIdle:				p = THREAD_PRIORITY_IDLE; break;
case AbcThreadPriorityNormal:			p = THREAD_PRIORITY_NORMAL; break;
case AbcThreadPriorityHigh:				p = THREAD_PRIORITY_HIGHEST; break;
case AbcThreadPriorityBackgroundBegin:	p = THREAD_MODE_BACKGROUND_BEGIN; break;
case AbcThreadPriorityBackgroundEnd:	p = THREAD_MODE_BACKGROUND_END; break;
}
SetThreadPriority( handle, p );
}

#else
// linux

PAPI bool			AbcThreadCreate( AbcThreadFunc threadfunc, void* context, AbcThreadHandle& handle )
{
pthread_attr_t attr;
handle = 0;
AbcVerify( 0 == pthread_attr_init( &attr ) );
bool ok = pthread_create( &handle, &attr, threadfunc, context );
AbcVerify( 0 == pthread_attr_destroy( &attr ) );
return ok;
}
PAPI bool			AbcThreadJoin( AbcThreadHandle handle )
{
void* rval;
return 0 == pthread_join( handle, &rval );
}
PAPI void			AbcThreadCloseHandle( AbcThreadHandle handle )
{
// pthread has no equivalent/requirement of this
}
PAPI AbcThreadHandle AbcThreadCurrent()
{
return pthread_self();
}
PAPI AbcThreadID	AbcThreadCurrentID()
{
return pthread_self();
}
PAPI bool			AbcThreadIDEqual( AbcThreadID a, AbcThreadID b )
{
return !!pthread_equal( a, b );
}
PAPI void			AbcThreadSetPriority( AbcThreadHandle handle, AbcThreadPriority priority )
{
// On linux, pthread_setschedprio is only applicable to threads on the realtime scheduling policy
}

#endif

PAPI bool			AbcThreadJoinAndCloseHandle( AbcThreadHandle handle )
{
bool result = AbcThreadJoin( handle );
AbcThreadCloseHandle( handle );
return result;
}


/*
* Copyright 2001 Unicode, Inc.
*
* Disclaimer
*
* This source code is provided as is by Unicode, Inc. No claims are
* made as to fitness for any particular purpose. No warranties of any
* kind are expressed or implied. The recipient agrees to determine
* applicability of information provided. If this file has been
* purchased on magnetic or optical media from Unicode, Inc., the
* sole remedy for any claim will be exchange of defective media
* within 90 days of receipt.
*
* Limitations on Rights to Redistribute This Code
*
* Unicode, Inc. hereby grants the right to freely use the information
* supplied in this file in the creation of products supporting the
* Unicode Standard, and to make copies of this file in any form
* for internal or external distribution as long as this notice
* remains attached.
*/

/* ---------------------------------------------------------------------

Conversions between UTF32, UTF-16, and UTF-8. Source code file.
Author: Mark E. Davis, 1994.
Rev History: Rick McGowan, fixes & updates May 2001.
Sept 2001: fixed const & error conditions per
mods suggested by S. Parent & A. Lillich.

See the header file "ConvertUTF.h" for complete documentation.

------------------------------------------------------------------------ */



#ifdef CVTUTF_DEBUG
#endif

static const bool WideIs16 = sizeof(wchar_t) == 2;
static const bool WideIs32 = sizeof(wchar_t) == 4;

namespace Unicode
{

static const int halfShift	= 10; /* used for shifting by 10 bits */

static const UTF32 halfBase	= 0x0010000UL;
static const UTF32 halfMask	= 0x3FFUL;

#define UNI_SUR_HIGH_START		(UTF32) 0xD800
#define UNI_SUR_HIGH_END		(UTF32) 0xDBFF
#define UNI_SUR_LOW_START		(UTF32) 0xDC00
#define UNI_SUR_LOW_END			(UTF32) 0xDFFF

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF16 (
const UTF32** sourceStart, const UTF32* sourceEnd,
UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
ConversionResult result = ConversionOk;
const UTF32* source = *sourceStart;
UTF16* target = *targetStart;
while (source < sourceEnd) {
UTF32 ch;
if (target >= targetEnd) {
result = ConversionResultTargetExhausted; break;
}
ch = *source++;
if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
/* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
if (flags == ConversionStrict) {
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
} else {
*target++ = UNI_REPLACEMENT_CHAR;
}
} else {
*target++ = (UTF16)ch; /* normal case */
}
} else if (ch > UNI_MAX_LEGAL_UTF32) {
if (flags == ConversionStrict) {
result = ConversionResultSourceIllegal;
} else {
*target++ = UNI_REPLACEMENT_CHAR;
}
} else {
/* target is a character in range 0xFFFF - 0x10FFFF. */
if (target + 1 >= targetEnd) {
--source; /* Back up source pointer! */
result = ConversionResultTargetExhausted; break;
}
ch -= halfBase;
*target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
*target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
}
}
*sourceStart = source;
*targetStart = target;
return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF32 (
const UTF16** sourceStart, const UTF16* sourceEnd,
UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
ConversionResult result = ConversionOk;
const UTF16* source = *sourceStart;
UTF32* target = *targetStart;
UTF32 ch, ch2;
while (source < sourceEnd) {
const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
ch = *source++;
/* If we have a surrogate pair, convert to UTF32 first. */
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
/* If the 16 bits following the high surrogate are in the source buffer... */
if (source < sourceEnd) {
ch2 = *source;
/* If it's a low surrogate, convert to UTF32. */
if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+ (ch2 - UNI_SUR_LOW_START) + halfBase;
++source;
} else if (flags == ConversionStrict) { /* it's an unpaired high surrogate */
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
}
} else { /* We don't have the 16 bits following the high surrogate. */
--source; /* return to the high surrogate */
result = ConversionResultSourceExhausted;
break;
}
} else if (flags == ConversionStrict) {
/* UTF-16 surrogate values are illegal in UTF-32 */
if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
}
}
if (target >= targetEnd) {
source = oldSource; /* Back up source pointer! */
result = ConversionResultTargetExhausted; break;
}
*target++ = ch;
}
*sourceStart = source;
*targetStart = target;
#ifdef CVTUTF_DEBUG
if (result == ConversionResultSourceIllegal) {
fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
fflush(stderr);
}
#endif
return result;
}

/* --------------------------------------------------------------------- */

/*
* Index into the table below with the first byte of a UTF-8 sequence to
* get the number of trailing bytes that are supposed to follow it.
* Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
* left as-is for anyone who may want to do such conversion, which was
* allowed in earlier algorithms.
*/
static const char trailingBytesForUTF8[256] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
};

/*
* Magic values subtracted from a buffer value during UTF8 conversion.
* This table contains as many values as there might be trailing bytes
* in a UTF-8 sequence.
*/
static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
0x03C82080UL, 0xFA082080UL, 0x82082080UL };

/*
* Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
* into the first byte, depending on how many bytes follow.  There are
* as many entries in this table as there are UTF-8 sequence types.
* (I.e., one byte sequence, two byte... etc.). Remember that sequencs
* for *legal* UTF-8 will be 4 or fewer bytes total.
*/
static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

/* --------------------------------------------------------------------- */

/* The interface converts a whole buffer to avoid function-call overhead.
* Constants have been gathered. Loops & conditionals have been removed as
* much as possible for efficiency, in favor of drop-through switches.
* (See "Note A" at the bottom of the file for equivalent code.)
* If your compiler supports it, the "IsLegalUTF8" call can be turned
* into an inline function.
*/

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF8 (
const UTF16** sourceStart, const UTF16* sourceEnd,
UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
ConversionResult result = ConversionOk;
const UTF16* source = *sourceStart;
UTF8* target = *targetStart;
while (source < sourceEnd) {
UTF32 ch;
unsigned short bytesToWrite = 0;
const UTF32 byteMask = 0xBF;
const UTF32 byteMark = 0x80;
const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
ch = *source++;
/* If we have a surrogate pair, convert to UTF32 first. */
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
/* If the 16 bits following the high surrogate are in the source buffer... */
if (source < sourceEnd) {
UTF32 ch2 = *source;
/* If it's a low surrogate, convert to UTF32. */
if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+ (ch2 - UNI_SUR_LOW_START) + halfBase;
++source;
} else if (flags == ConversionStrict) { /* it's an unpaired high surrogate */
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
}
} else { /* We don't have the 16 bits following the high surrogate. */
--source; /* return to the high surrogate */
result = ConversionResultSourceExhausted;
break;
}
} else if (flags == ConversionStrict) {
/* UTF-16 surrogate values are illegal in UTF-32 */
if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
}
}
/* Figure out how many bytes the result will require */
if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
} else {			    bytesToWrite = 3;
ch = UNI_REPLACEMENT_CHAR;
}

target += bytesToWrite;
if (target > targetEnd) {
source = oldSource; /* Back up source pointer! */
target -= bytesToWrite; result = ConversionResultTargetExhausted; break;
}
switch (bytesToWrite) { /* note: everything falls through. */
case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
}
target += bytesToWrite;
}
*sourceStart = source;
*targetStart = target;
return result;
}

/* --------------------------------------------------------------------- */

/*
* Utility routine to tell whether a sequence of bytes is legal UTF-8.
* This must be called with the length pre-determined by the first byte.
* If not calling this from ConvertUTF8to*, then the length can be set by:
*  length = trailingBytesForUTF8[*source]+1;
* and the sequence is illegal right away if there aren't that many bytes
* available.
* If presented with a length > 4, this returns false.  The Unicode
* definition of UTF-8 goes up to 4-byte sequences.
*/

static bool IsLegalUTF8(const UTF8 *source, int length) {
UTF8 a;
const UTF8 *srcptr = source+length;
switch (length) {
default: return false;
/* Everything else falls through when "true"... */
case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
case 2: if ((a = (*--srcptr)) > 0xBF) return false;

switch (*source) {
/* no fall-through in this inner switch */
case 0xE0: if (a < 0xA0) return false; break;
case 0xED: if (a > 0x9F) return false; break;
case 0xF0: if (a < 0x90) return false; break;
case 0xF4: if (a > 0x8F) return false; break;
default:   if (a < 0x80) return false;
}

case 1: if (*source >= 0x80 && *source < 0xC2) return false;
}
if (*source > 0xF4) return false;
return true;
}

/* --------------------------------------------------------------------- */

/*
* Exported function to return whether a UTF-8 sequence is legal or not.
* This is not used here; it's just exported.
*/
bool IsLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
int length = trailingBytesForUTF8[*source]+1;
if (source+length > sourceEnd) {
return false;
}
return IsLegalUTF8(source, length);
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF16 (
const UTF8** sourceStart, const UTF8* sourceEnd,
UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags)
{
ConversionResult result = ConversionOk;
const UTF8* source = *sourceStart;
UTF16* target = *targetStart;
while (source < sourceEnd) {
UTF32 ch = 0;
unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
if (source + extraBytesToRead >= sourceEnd) {
result = ConversionResultSourceExhausted; break;
}
/* Do this check whether lenient or strict */
if (! IsLegalUTF8(source, extraBytesToRead+1)) {
result = ConversionResultSourceIllegal;
break;
}
/*
* The cases all fall through. See "Note A" below.
*/
switch (extraBytesToRead) {
case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
case 3: ch += *source++; ch <<= 6;
case 2: ch += *source++; ch <<= 6;
case 1: ch += *source++; ch <<= 6;
case 0: ch += *source++;
}
ch -= offsetsFromUTF8[extraBytesToRead];

if (target >= targetEnd) {
source -= (extraBytesToRead+1); /* Back up source pointer! */
result = ConversionResultTargetExhausted; break;
}
if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
/* UTF-16 surrogate values are illegal in UTF-32 */
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
if (flags == ConversionStrict) {
source -= (extraBytesToRead+1); /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
} else {
*target++ = UNI_REPLACEMENT_CHAR;
}
} else {
*target++ = (UTF16)ch; /* normal case */
}
} else if (ch > UNI_MAX_UTF16) {
if (flags == ConversionStrict) {
result = ConversionResultSourceIllegal;
source -= (extraBytesToRead+1); /* return to the start */
break; /* Bail out; shouldn't continue */
} else {
*target++ = UNI_REPLACEMENT_CHAR;
}
} else {
/* target is a character in range 0xFFFF - 0x10FFFF. */
if (target + 1 >= targetEnd) {
source -= (extraBytesToRead+1); /* Back up source pointer! */
result = ConversionResultTargetExhausted; break;
}
ch -= halfBase;
*target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
*target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
}
}
*sourceStart = source;
*targetStart = target;
return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF8 (
const UTF32** sourceStart, const UTF32* sourceEnd,
UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags)
{
ConversionResult result = ConversionOk;
const UTF32* source = *sourceStart;
UTF8* target = *targetStart;
while (source < sourceEnd) {
UTF32 ch;
unsigned short bytesToWrite = 0;
const UTF32 byteMask = 0xBF;
const UTF32 byteMark = 0x80;
ch = *source++;
if (flags == ConversionStrict ) {
/* UTF-16 surrogate values are illegal in UTF-32 */
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
--source; /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
}
}
/*
* Figure out how many bytes the result will require. Turn any
* illegally large UTF32 things (> Plane 17) into replacement chars.
*/
if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
} else {			    bytesToWrite = 3;
ch = UNI_REPLACEMENT_CHAR;
result = ConversionResultSourceIllegal;
}

target += bytesToWrite;
if (target > targetEnd) {
--source; /* Back up source pointer! */
target -= bytesToWrite; result = ConversionResultTargetExhausted; break;
}
switch (bytesToWrite) { /* note: everything falls through. */
case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
}
target += bytesToWrite;
}
*sourceStart = source;
*targetStart = target;
return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF32 (
const UTF8** sourceStart, const UTF8* sourceEnd,
UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags)
{
ConversionResult result = ConversionOk;
const UTF8* source = *sourceStart;
UTF32* target = *targetStart;
while (source < sourceEnd) {
UTF32 ch = 0;
unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
if (source + extraBytesToRead >= sourceEnd) {
result = ConversionResultSourceExhausted; break;
}
/* Do this check whether lenient or strict */
if (! IsLegalUTF8(source, extraBytesToRead+1)) {
result = ConversionResultSourceIllegal;
break;
}
/*
* The cases all fall through. See "Note A" below.
*/
switch (extraBytesToRead) {
case 5: ch += *source++; ch <<= 6;
case 4: ch += *source++; ch <<= 6;
case 3: ch += *source++; ch <<= 6;
case 2: ch += *source++; ch <<= 6;
case 1: ch += *source++; ch <<= 6;
case 0: ch += *source++;
}
ch -= offsetsFromUTF8[extraBytesToRead];

if (target >= targetEnd) {
source -= (extraBytesToRead+1); /* Back up the source pointer! */
result = ConversionResultTargetExhausted; break;
}
if (ch <= UNI_MAX_LEGAL_UTF32) {
/*
* UTF-16 surrogate values are illegal in UTF-32, and anything
* over Plane 17 (> 0x10FFFF) is illegal.
*/
if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
if (flags == ConversionStrict) {
source -= (extraBytesToRead+1); /* return to the illegal value itself */
result = ConversionResultSourceIllegal;
break;
} else {
*target++ = UNI_REPLACEMENT_CHAR;
}
} else {
*target++ = ch;
}
} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
result = ConversionResultSourceIllegal;
*target++ = UNI_REPLACEMENT_CHAR;
}
}
*sourceStart = source;
*targetStart = target;
return result;
}

/* ---------------------------------------------------------------------

Note A.
The fall-through switches in UTF-8 reading code save a
temp variable, some decrements & conditionals.  The switches
are equivalent to the following loop:
{
int tmpBytesToRead = extraBytesToRead+1;
do {
ch += *source++;
--tmpBytesToRead;
if (tmpBytesToRead) ch <<= 6;
} while (tmpBytesToRead > 0);
}
In UTF-8 writing code, the switches on "bytesToWrite" are
similarly unrolled loops.

--------------------------------------------------------------------- */

}

using namespace Unicode;

#ifdef XSTRING_DEFINED

XStringA ConvertHighAsciiToUTF8( const XStringA& src )
{
// check first if string needs no conversion
int len = src.Length();

bool needsUtf = false;
for ( int i = 0; i < len; i++ )
{
if ( (unsigned char) src[i] > 127 ) { needsUtf = true; break; }
}

if ( !needsUtf ) return src;

// convert to 16 bit then down to utf8.
UTF16* tempSrc = (UTF16*) malloc( (len + 1) * 2 );
if ( tempSrc == NULL ) { ASSERT(false); return ""; }

UTF8* tempDst = (UTF8*) malloc( (len + 1) * 2 );
if ( tempDst == NULL ) { ASSERT(false); free(tempSrc); return ""; }

for ( int i = 0; i < len; i++ )
tempSrc[i] = (unsigned char) src[i];

tempSrc[len] = 0;

const UTF16* srcPos = tempSrc;
UTF8* dstPos = tempDst;

ConversionResult res = ConvertUTF16toUTF8( &srcPos, tempSrc + len + 1, &dstPos, tempDst + (len + 1) * 2, ConversionStrict );
ASSERT( res == ConversionOk );

int dstLen = dstPos - tempDst;

XStringA sres( (char*) tempDst );

free( tempSrc );
free( tempDst );

return sres;
}

XStringA ConvertUTF8ToHighAscii( const XStringA& src )
{
// check first if string needs no conversion
int len = src.Length();

bool needsUtf = false;
for ( int i = 0; i < len; i++ )
{
if ( (unsigned char) src[i] > 127 ) { needsUtf = true; break; }
}

if ( !needsUtf ) return src;

const UTF8* srcPos = (const UTF8*) ( (LPCSTR) src );
const UTF8* srcEnd = srcPos + len + 1;

UTF16* tempDst = (UTF16*) malloc( 2 * (len + 1) );
if ( tempDst == NULL ) { ASSERT( false); return ""; }

UTF16* dstPos = tempDst;
UTF16* dstEnd = tempDst + len;

ConversionResult res = ConvertUTF8toUTF16( &srcPos, srcEnd, &dstPos, dstEnd, ConversionStrict );
ASSERT( res == ConversionOk );

int dstLen = dstPos - tempDst - 1;

XStringA sres;
char* buff = sres.GetBuffer( dstLen + 1 );
for ( int i = 0; i < dstLen; i++ )
buff[i] = (char) tempDst[i];

buff[dstLen] = 0;

sres.ReleaseBuffer();

free( tempDst );

return sres;
}

/*
Concepts embodied in the following 4 functions (ConvertUTF8ToWide, ConvertWideToUTF8):
* The low level functions do not write the null terminator. We always write it ourselves.
* If the conversion fails, return the string up to where it decoded successfully.
*/

XStringW ConvertUTF8ToWide( const XStringA& src )
{
XStringW dst;
size_t srcLen = (size_t) src.Length();
if ( srcLen != 0 )
{
const UTF8* srcPos	= (const UTF8*) ( (const char*) src );
const UTF8* srcEnd	= srcPos + srcLen;
size_t		dstLen	= MaximumWideFromUtf8( srcLen );
wchar_t*	tempDst	= dst.GetBuffer( (int) dstLen ); // dstLen excludes space for the null terminator
wchar_t*	dstPos	= tempDst;
wchar_t*	dstEnd	= tempDst + dstLen;
ConversionResult res = WideIs16 ?
ConvertUTF8toUTF16( &srcPos, srcEnd, (UTF16**) &dstPos, (UTF16*) dstEnd, ConversionStrict ) :
ConvertUTF8toUTF32( &srcPos, srcEnd, (UTF32**) &dstPos, (UTF32*) dstEnd, ConversionStrict );
ASSERT( res == ConversionOk );
tempDst[dstPos - tempDst] = 0;
dst.ReleaseBuffer();
}
return dst;
}

XStringA ConvertWideToUTF8( const XStringW& src )
{
XStringA dst;
size_t srcLen = src.Length();
if ( srcLen != 0 )
{
const wchar_t*	srcPos = (const wchar_t*) src;
const wchar_t*	srcEnd = srcPos + srcLen;
size_t			dstLen = MaximumUtf8FromWide( srcLen );
UTF8*			tempDst = (UTF8*) dst.GetBuffer( (int) dstLen ); // dstLen excludes space for the null terminator
UTF8*			dstPos = tempDst;
UTF8*			dstEnd = tempDst + dstLen;
ConversionResult res = WideIs16 ?
ConvertUTF16toUTF8( (const UTF16**) &srcPos, (const UTF16*) srcEnd, &dstPos, dstEnd, ConversionStrict ) :
ConvertUTF32toUTF8( (const UTF32**) &srcPos, (const UTF32*) srcEnd, &dstPos, dstEnd, ConversionStrict );
ASSERT( res == ConversionOk );
tempDst[dstPos - tempDst] = 0;
dst.ReleaseBuffer();
}
return dst;
}

#endif // XSTRING_DEFINED

std::wstring PAPI ConvertUTF8ToWide( const std::string& src )
{
std::wstring dst;
size_t srcLen = src.length();
if ( srcLen != 0 )
{
dst.resize( MaximumWideFromUtf8( srcLen ) );
const UTF8* srcPos	= (const UTF8*) src.c_str();
const UTF8* srcEnd	= srcPos + srcLen;
UTF16*		tempDst	= (UTF16*) const_cast<wchar_t*>(dst.c_str());	// this violates the std::string spec, but I cannot see how any implementation would not be OK with it.
UTF16*		dstPos	= tempDst;
UTF16*		dstEnd	= tempDst + dst.length();
ConversionResult res = WideIs16 ?
ConvertUTF8toUTF16( &srcPos, srcEnd, (UTF16**) &dstPos, (UTF16*) dstEnd, ConversionStrict ) :
ConvertUTF8toUTF32( &srcPos, srcEnd, (UTF32**) &dstPos, (UTF32*) dstEnd, ConversionStrict );
for ( size_t spare = dst.size() - (dstPos - tempDst); spare != 0; spare-- )
dst.pop_back();
dst.shrink_to_fit();
}
return dst;
}

std::string PAPI ConvertWideToUTF8( const std::wstring& src )
{
std::string dst;
size_t srcLen = src.length();
if ( srcLen != 0 )
{
dst.resize( MaximumUtf8FromWide( srcLen ) );
const wchar_t*	srcPos = src.c_str();
const wchar_t*	srcEnd = srcPos + srcLen;
UTF8*			tempDst	= (UINT8*) const_cast<char*>(dst.c_str());	// this violates the std::string spec, but I cannot see how any implementation would not be OK with it.
UTF8*			dstPos = tempDst;
UTF8*			dstEnd = tempDst + dst.length();
ConversionResult res = WideIs16 ?
ConvertUTF16toUTF8( (const UTF16**) &srcPos, (const UTF16*) srcEnd, &dstPos, dstEnd, ConversionStrict ) :
ConvertUTF32toUTF8( (const UTF32**) &srcPos, (const UTF32*) srcEnd, &dstPos, dstEnd, ConversionStrict );
for ( size_t spare = dst.size() - (dstPos - tempDst); spare != 0; spare-- )
dst.pop_back();
dst.shrink_to_fit();
}
return dst;
}

bool ConvertWideToUTF8( const wchar_t* src, size_t srcLen, char* dst, size_t& dstLen, bool relaxNullTerminator )
{
if ( dst ) *dst = 0;

if ( src == NULL )
{
if ( !relaxNullTerminator && dstLen == 0 )
return false;
dstLen = 0;
return true;
}

if ( srcLen == -1 )
srcLen = wcslen( src );

const wchar_t* srcPos = src;
const wchar_t* srcEnd = srcPos + srcLen;

UTF8* dstPos = (UTF8*) dst;
UTF8* dstEnd = (UTF8*) (dst + dstLen);

ConversionResult res = WideIs16 ?
ConvertUTF16toUTF8( (const UTF16**) &srcPos, (const UTF16*) srcEnd, &dstPos, dstEnd, ConversionStrict ) :
ConvertUTF32toUTF8( (const UTF32**) &srcPos, (const UTF32*) srcEnd, &dstPos, dstEnd, ConversionStrict );

if ( res == ConversionResultTargetExhausted )
return false;

bool result = res == ConversionOk;

size_t actualDstLen = dstPos - (UTF8*) dst;

if ( dstLen > actualDstLen )
dst[actualDstLen] = 0;
else if ( !relaxNullTerminator )
return false;

dstLen = actualDstLen;

return result;
}

bool ConvertUTF8ToWide( const char* src, size_t srcLen, wchar_t* dst, size_t& dstLen, bool relaxNullTerminator )
{
if ( dst ) *dst = 0;

if ( src == NULL )
{
if ( !relaxNullTerminator && dstLen == 0 )
return false;
dstLen = 0;
return true;
}

if ( srcLen == -1 )
srcLen = strlen( src );

const UTF8* srcPos = (const UTF8*) src;
const UTF8* srcEnd = srcPos + srcLen;

wchar_t* dstPos = dst;
wchar_t* dstEnd = dst + dstLen;

ConversionResult res = WideIs16 ?
ConvertUTF8toUTF16( &srcPos, srcEnd, (UTF16**) &dstPos, (UTF16*) dstEnd, ConversionStrict ) :
ConvertUTF8toUTF32( &srcPos, srcEnd, (UTF32**) &dstPos, (UTF32*) dstEnd, ConversionStrict );

if ( res == ConversionResultTargetExhausted )
return false;

bool result = res == ConversionOk;

size_t actualDstLen = dstPos - dst;

if ( dstLen > actualDstLen )
dst[actualDstLen] = 0;
else if ( !relaxNullTerminator )
return false;

dstLen = actualDstLen;

return result;
}



static inline void fmt_settype( char argbuf[128], intp pos, const char* width, char type )
{
if ( width != NULL )
{
// set the type and the width specifier
switch ( argbuf[pos - 1] )
{
case 'l':
case 'h':
case 'w':
pos--;
break;
}

for ( ; *width; width++, pos++ )
argbuf[pos] = *width;

argbuf[pos++] = type;
argbuf[pos++] = 0;
}
else
{
// only set the type, not the width specifier
argbuf[pos++] = type;
argbuf[pos++] = 0;
}
}

static inline int fmt_output_with_snprintf( char* outbuf, char fmt_type, char argbuf[128], intp argbufsize, intp outputSize, const fmtarg* arg )
{
#define				SETTYPE1(type)			fmt_settype( argbuf, argbufsize, NULL, type )
#define				SETTYPE2(width, type)	fmt_settype( argbuf, argbufsize, width, type )

#ifdef _WIN32
const char* i64Prefix = "I64";
const char* wcharPrefix = "";
const char wcharType = 'S';
#else
const char* i64Prefix = "ll";
const char* wcharPrefix = "l";
const char wcharType = 's';
#endif

bool tokenint = false;
bool tokenreal = false;

switch ( fmt_type )
{
case 'd':
case 'i':
case 'o':
case 'u':
case 'x':
case 'X':
tokenint = true;
}

switch ( fmt_type )
{
case 'e':
case 'E':
case 'f':
case 'g':
case 'G':
case 'a':
case 'A':
tokenreal = true;
}

switch ( arg->Type )
{
case fmtarg::TCStr:
SETTYPE2("", 's');
return fmt_snprintf( outbuf, outputSize, argbuf, arg->CStr );
case fmtarg::TWStr:
SETTYPE2(wcharPrefix, wcharType);
return fmt_snprintf( outbuf, outputSize, argbuf, arg->WStr );
case fmtarg::TI32:
if (tokenint)	{ SETTYPE2("", fmt_type); }
else			{ SETTYPE2("", 'd'); }
return fmt_snprintf( outbuf, outputSize, argbuf, arg->I32 );
case fmtarg::TU32:
if (tokenint)	{ SETTYPE2("", fmt_type); }
else			{ SETTYPE2("", 'u'); }
return fmt_snprintf( outbuf, outputSize, argbuf, arg->UI32 );
case fmtarg::TI64:
if (tokenint)	{ SETTYPE2(i64Prefix, fmt_type); }
else			{ SETTYPE2(i64Prefix, 'd'); }
return fmt_snprintf( outbuf, outputSize, argbuf, arg->I64 );
case fmtarg::TU64:
if (tokenint)	{ SETTYPE2(i64Prefix, fmt_type); }
else			{ SETTYPE2(i64Prefix, 'u'); }
return fmt_snprintf( outbuf, outputSize, argbuf, arg->UI64 );
case fmtarg::TDbl:
if (tokenreal)	{ SETTYPE1(fmt_type); }
else			{ SETTYPE1('g'); }
return fmt_snprintf( outbuf, outputSize, argbuf, arg->Dbl );
break;
}

#undef SETTYPE1
#undef SETTYPE2

return 0;
}

PAPI FMT_STRING fmt_core( const fmt_context& context, const char* fmt, intp nargs, const fmtarg** args )
{
intp tokenstart = -1;	// true if we have passed a %, and are looking for the end of the token
intp iarg = 0;
bool no_args_remaining;
bool spec_too_long;
bool disallowed;
const intp MaxOutputSize = 1 * 1024 * 1024;

char staticbuf[8192];
AbCore::StackBuffer output( staticbuf );

char argbuf[128];

// we can always safely look one ahead, because 'fmt' is by definition zero terminated
for ( intp i = 0; fmt[i]; i++ )
{
if ( tokenstart != -1 )
{
bool tokenint = false;
bool tokenreal = false;
bool is_q = fmt[i] == 'q';
bool is_Q = fmt[i] == 'Q';

switch ( fmt[i] )
{
case 'a':
case 'A':
case 'c':
case 'C':
case 'd':
case 'i':
case 'e':
case 'E':
case 'f':
case 'g':
case 'G':
case 'H':
case 'o':
case 's':
case 'S':
case 'u':
case 'x':
case 'X':
case 'p':
case 'n':
case 'v':
case 'q':
case 'Q':
no_args_remaining	= iarg >= nargs;								// more tokens than arguments
spec_too_long		= i - tokenstart >= arraysize(argbuf) - 1;		// %_____too much data____v
disallowed			= fmt[i] == 'n';

if ( is_q && context.Escape_q == NULL )
disallowed = true;

if ( is_Q && context.Escape_Q == NULL )
disallowed = true;

if ( no_args_remaining || spec_too_long || disallowed )
{
for ( intp j = tokenstart; j <= i; j++ )
output.AddItem( fmt[j] );
}
else
{
// prepare the single formatting token that we will send to snprintf
intp argbufsize = 0;
for ( intp j = tokenstart; j < i; j++ )
{
if ( fmt[j] == '*' ) continue;	// ignore
argbuf[argbufsize++] = fmt[j];
}

// grow output buffer size until we don't overflow
const fmtarg* arg = args[iarg];
iarg++;
intp outputSize = 1024;
while ( true )
{
char* outbuf = (char*) output.Add( outputSize );
bool done = false;
intp written = 0;
if ( is_q )			written = context.Escape_q( outbuf, outputSize, *arg );
else if ( is_Q )	written = context.Escape_Q( outbuf, outputSize, *arg );
else				written = fmt_output_with_snprintf( outbuf, fmt[i], argbuf, argbufsize, outputSize, arg );

if ( written >= 0 && written < outputSize )
{
output.MoveCurrentPos( written - outputSize );
break;
}
else if ( outputSize >= MaxOutputSize )
{
// give up. I first saw this on the Microsoft CRT when trying to write the "mu" symbol to an ascii string.
break;
}
// discard and try again with a larger buffer
output.MoveCurrentPos( -outputSize );
outputSize = outputSize * 2;
}
}
tokenstart = -1;
break;
case '%':
output.AddItem( '%' );
tokenstart = -1;
break;
default:
break;
}
}
else
{
switch ( fmt[i] )
{
case '%':
tokenstart = i;
break;
default:
output.AddItem( fmt[i] );
break;
}
}
}
output.AddItem( '\0' );
return FMT_STRING( (const char*) output.Buffer );
}

/*
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14, const fmtarg& a15, const fmtarg& a16 )
{
fmt_context cx;
int count = 0;
const fmtarg* args[16] = {0};
if ( a1.Type != fmtarg::TNull ) { count = 1; args[0] = &a1; }
if ( a1.Type == fmtarg::TNull ) count = 0; else args[0] = &a1;
if ( a2.Type == fmtarg::TNull ) { args[0] = &a1; count = 1; }
if ( a3.Type == fmtarg::TNull ) { args[1] = &a2; count = 2; }
if ( a4.Type == fmtarg::TNull ) { args[2] = &a3; count = 3; }
if ( a5.Type == fmtarg::TNull ) { args[3] = &a4; count = 4; }
if ( a6.Type == fmtarg::TNull ) { args[4] = &a5; count = 5; }
if ( a7.Type == fmtarg::TNull ) { args[5] = &a6; count = 6; }
if ( a8.Type == fmtarg::TNull ) { args[6] = &a7; count = 7; }
if ( a9.Type == fmtarg::TNull ) { args[7] = &a8; count = 8; }
if ( a10.Type == fmtarg::TNull ) { args[8] = &a9; count = 9; }
if ( a11.Type == fmtarg::TNull ) { args[9] = &a10; count = 10; }
if ( a12.Type == fmtarg::TNull ) { args[10] = &a11; count = 11; }
if ( a13.Type == fmtarg::TNull ) { args[11] = &a12; count = 12; }
if ( a14.Type == fmtarg::TNull ) { args[12] = &a13; count = 13; }
if ( a15.Type == fmtarg::TNull ) { args[13] = &a14; count = 14; }
if ( a16.Type == fmtarg::TNull ) { args[14] = &a15; count = 15; }
else									{ args[15] = &a16; count = 16; }
return fmt_core( cx, fs, count, args );
}
*/

PAPI FMT_STRING fmt( const char* fs )
{
fmt_context cx;
return fmt_core( cx, fs, 0, NULL );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1 )
{
fmt_context cx;
const fmtarg* args[1] = {&a1};
return fmt_core( cx, fs, 1, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2 )
{
fmt_context cx;
const fmtarg* args[2] = {&a1, &a2};
return fmt_core( cx, fs, 2, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3 )
{
fmt_context cx;
const fmtarg* args[3] = {&a1, &a2, &a3};
return fmt_core( cx, fs, 3, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4 )
{
fmt_context cx;
const fmtarg* args[4] = {&a1, &a2, &a3, &a4};
return fmt_core( cx, fs, 4, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5 )
{
fmt_context cx;
const fmtarg* args[5] = {&a1, &a2, &a3, &a4, &a5};
return fmt_core( cx, fs, 5, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6 )
{
fmt_context cx;
const fmtarg* args[6] = {&a1, &a2, &a3, &a4, &a5, &a6};
return fmt_core( cx, fs, 6, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7 )
{
fmt_context cx;
const fmtarg* args[7] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7};
return fmt_core( cx, fs, 7, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8 )
{
fmt_context cx;
const fmtarg* args[8] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8};
return fmt_core( cx, fs, 8, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9 )
{
fmt_context cx;
const fmtarg* args[9] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9};
return fmt_core( cx, fs, 9, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10 )
{
fmt_context cx;
const fmtarg* args[10] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10};
return fmt_core( cx, fs, 10, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11 )
{
fmt_context cx;
const fmtarg* args[11] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11};
return fmt_core( cx, fs, 11, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12 )
{
fmt_context cx;
const fmtarg* args[12] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12};
return fmt_core( cx, fs, 12, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13 )
{
fmt_context cx;
const fmtarg* args[13] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12, &a13};
return fmt_core( cx, fs, 13, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14 )
{
fmt_context cx;
const fmtarg* args[14] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12, &a13, &a14};
return fmt_core( cx, fs, 14, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14, const fmtarg& a15 )
{
fmt_context cx;
const fmtarg* args[15] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12, &a13, &a14, &a15};
return fmt_core( cx, fs, 15, args );
}
PAPI FMT_STRING fmt( const char* fs, const fmtarg& a1, const fmtarg& a2, const fmtarg& a3, const fmtarg& a4, const fmtarg& a5, const fmtarg& a6, const fmtarg& a7, const fmtarg& a8, const fmtarg& a9, const fmtarg& a10, const fmtarg& a11, const fmtarg& a12, const fmtarg& a13, const fmtarg& a14, const fmtarg& a15, const fmtarg& a16 )
{
fmt_context cx;
const fmtarg* args[16] = {&a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9, &a10, &a11, &a12, &a13, &a14, &a15, &a16};
return fmt_core( cx, fs, 16, args );
}

PAPI size_t fmt_write( FILE* file, const FMT_STRING& s )
{
return fwrite( FMT_STRING_BUF(s), 1, FMT_STRING_LEN(s), file );
}

static inline int fmt_translate_snprintf_return_value( int r, size_t count )
{
if ( r < 0 || (size_t) r >= count )
return -1;
else
return r;
}

PAPI int fmt_snprintf( char* destination, size_t count, const char* format_str, ... )
{
va_list va;
va_start( va, format_str );
int r = vsnprintf( destination, count, format_str, va );
va_end( va );
return fmt_translate_snprintf_return_value( r, count );
}

PAPI int fmt_swprintf( wchar_t* destination, size_t count, const wchar_t* format_str, ... )
{
va_list va;
va_start( va, format_str );
int r = vswprintf( destination, count, format_str, va );
va_end( va );
return fmt_translate_snprintf_return_value( r, count );
}

/*

-- lua script used to generate the functions

local api = "PAPI"
local maxargs = 16

function makefunc( decl, name, withbody, reps )
local str = decl .. " FMT_STRING " .. name .. "( const char* fs"
for i = 1, reps do
str = str .. ", const fmtarg& a" .. tostring(i)
end
str = str .. " )"
if withbody then
str = str .. "\n"
str = str .. "{\n"
if reps ~= 0 then
str = str .. "\tconst fmtarg* args[" .. tostring(reps) .. "] = {"
for i = 1, reps do
str = str .. "&a" .. tostring(i) .. ", "
end
str = str:sub(0, #str - 2)
str = str .. "};\n"
str = str .. "\treturn fmt_core( cx, fs, " .. tostring(reps) .. ", args );\n";
else
str = str .. "\treturn fmt_core( cx, fs, 0, NULL );\n";
end
str = str .. "}\n"
else
str = str .. ";\n"
end

return str
end

local body, header = "", ""
for lim = 0, maxargs do
body = body .. makefunc(api, "fmt", true, lim)
header = header .. makefunc(api, "fmt", false, lim)
end


print( header )
print( body )

*/


#ifdef _WIN32
#pragma warning( push )
#pragma warning( disable: 4244 ) // conversion from __int64 to int
#endif
/* stbi-1.33 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c
when you control the images you're loading
no warranty implied; use at your own risk

QUICK NOTES:
Primarily of interest to game developers and other people who can
avoid problematic images and only need the trivial interface

JPEG baseline (no JPEG progressive)
PNG 8-bit-per-channel only

TGA (not sure what subset, if a subset)
BMP non-1bpp, non-RLE
PSD (composited view only, no extra channels)

GIF (*comp always reports as 4-channel)
HDR (radiance rgbE format)
PIC (Softimage PIC)

- decode from memory or through FILE (define STBI_NO_STDIO to remove code)
- decode from arbitrary I/O callbacks
- overridable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)

Latest revisions:
1.33 (2011-07-14) minor fixes suggested by Dave Moore
1.32 (2011-07-13) info support for all filetypes (SpartanJ)
1.31 (2011-06-19) a few more leak fixes, bug in PNG handling (SpartanJ)
1.30 (2011-06-11) added ability to load files via io callbacks (Ben Wenger)
1.29 (2010-08-16) various warning fixes from Aurelien Pocheville
1.28 (2010-08-01) fix bug in GIF palette transparency (SpartanJ)
1.27 (2010-08-01) cast-to-uint8 to fix warnings (Laurent Gomila)
allow trailing 0s at end of image data (Laurent Gomila)
1.26 (2010-07-24) fix bug in file buffering for PNG reported by SpartanJ

See end of file for full revision history.

TODO:
stbi_info support for BMP,PSD,HDR,PIC


============================    Contributors    =========================

Image formats                                Optimizations & bugfixes
Sean Barrett (jpeg, png, bmp)                Fabian "ryg" Giesen
Nicolas Schulz (hdr, psd)
Jonathan Dummer (tga)                     Bug fixes & warning fixes
Jean-Marc Lienher (gif)                      Marc LeBlanc
Tom Seddon (pic)                             Christpher Lloyd
Thatcher Ulrich (psd)                        Dave Moore
Won Chun
the Horde3D community
Extensions, features                            Janez Zemva
Jetro Lauha (stbi_info)                      Jonathan Blow
James "moose2000" Brown (iPhone PNG)         Laurent Gomila
Ben "Disch" Wenger (io callbacks)            Aruelien Pocheville
Martin "SpartanJ" Golini                     Ryamond Barbiero
David Woo


If your name should be here but isn't, let Sean know.

*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// To get a header file for this, either cut and paste the header,
// or create stb_image.h, #define STBI_HEADER_FILE_ONLY, and
// then include stb_image.c from it.

////   begin header file  ////////////////////////////////////////////////////
//
// Limitations:
//    - no jpeg progressive support
//    - non-HDR formats support 8-bit samples only (jpeg, png)
//    - no delayed line count (jpeg) -- IJG doesn't support either
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to easily see if it's opaque.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB; nominally they
// would silently load as BGR, except the existing code should have just
// failed on such iPhone PNGs. But you can disable this conversion by
// by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through.
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).


#ifndef STBI_NO_STDIO

#if defined(_MSC_VER) && _MSC_VER >= 0x1400
#define _CRT_SECURE_NO_WARNINGS // suppress bogus warnings about fopen()
#endif

#endif

#define STBI_VERSION 1

enum
{
STBI_default = 0, // only used for req_comp

STBI_grey       = 1,
STBI_grey_alpha = 2,
STBI_rgb        = 3,
STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

extern stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

typedef struct
{
int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
void     (*skip)  (void *user,unsigned n);            // skip the next 'n' bytes
int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

extern stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_HDR
extern float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);
extern float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
#endif

extern float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

extern void   stbi_hdr_to_ldr_gamma(float gamma);
extern void   stbi_hdr_to_ldr_scale(float scale);

extern void   stbi_ldr_to_hdr_gamma(float gamma);
extern void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_HDR

// stbi_is_hdr is always defined
extern int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
extern int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
extern int      stbi_is_hdr          (char const *filename);
extern int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// NOT THREADSAFE
extern const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
extern void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
extern int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
extern int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
extern int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);

#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
extern void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
extern void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);


// ZLIB client - used by PNG, available for other purposes

extern char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
extern char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

extern char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
extern int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


// define faster low-level operations (typically SIMD support)
#ifdef STBI_SIMD
typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);
// compute an integer IDCT on "input"
//     input[x] = data[x] * dequantize[x]
//     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'
//                             CLAMP results to 0..255
typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);
// compute a conversion from YCbCr to RGB
//     'count' pixels
//     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B
//     y: Y input channel
//     cb: Cb input channel; scale/biased to be 0..255
//     cr: Cr input channel; scale/biased to be 0..255

extern void stbi_install_idct(stbi_idct_8x8 func);
extern void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);
#endif // STBI_SIMD


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifndef STBI_HEADER_FILE_ONLY

#ifndef STBI_NO_HDR
#endif

#ifndef STBI_NO_STDIO
#endif

#ifndef _MSC_VER
#ifdef __cplusplus
#define stbi_inline inline
#else
#define stbi_inline
#endif
#else
#define stbi_inline __forceinline
#endif


// implementation:
typedef unsigned char  uint8;
typedef unsigned short uint16;
typedef   signed short  int16;
typedef unsigned int   uint32;
typedef   signed int    int32;
typedef unsigned int   uint;

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(uint32)==4 ? 1 : -1];

#if defined(STBI_NO_STDIO) && !defined(STBI_NO_WRITE)
#define STBI_NO_WRITE
#endif

#define STBI_NOTUSED(v)  (void)sizeof(v)

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
#define stbi_lrot(x,y)  _lrotl(x,y)
#else
#define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

///////////////////////////////////////////////
//
//  stbi struct and start_xxx functions

// stbi structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
uint32 img_x, img_y;
int img_n, img_out_n;

stbi_io_callbacks io;
void *io_user_data;

int read_from_callbacks;
int buflen;
uint8 buffer_start[128];

uint8 *img_buffer, *img_buffer_end;
uint8 *img_buffer_original;
} stbi;


static void refill_buffer(stbi *s);

// initialize a memory-decode context
static void start_mem(stbi *s, uint8 const *buffer, int len)
{
s->io.read = NULL;
s->read_from_callbacks = 0;
s->img_buffer = s->img_buffer_original = (uint8 *) buffer;
s->img_buffer_end = (uint8 *) buffer+len;
}

// initialize a callback-based context
static void start_callbacks(stbi *s, stbi_io_callbacks *c, void *user)
{
s->io = *c;
s->io_user_data = user;
s->buflen = sizeof(s->buffer_start);
s->read_from_callbacks = 1;
s->img_buffer_original = s->buffer_start;
refill_buffer(s);
}

#ifndef STBI_NO_STDIO

static int stdio_read(void *user, char *data, int size)
{
return (int) fread(data,1,size,(FILE*) user);
}

static void stdio_skip(void *user, unsigned n)
{
fseek((FILE*) user, n, SEEK_CUR);
}

static int stdio_eof(void *user)
{
return feof((FILE*) user);
}

static stbi_io_callbacks stbi_stdio_callbacks =
{
stdio_read,
stdio_skip,
stdio_eof,
};

static void start_file(stbi *s, FILE *f)
{
start_callbacks(s, &stbi_stdio_callbacks, (void *) f);
}

//static void stop_file(stbi *s) { }

#endif // !STBI_NO_STDIO

static void stbi_rewind(stbi *s)
{
// conceptually rewind SHOULD rewind to the beginning of the stream,
// but we just rewind to the beginning of the initial buffer, because
// we only use it after doing 'test', which only ever looks at at most 92 bytes
s->img_buffer = s->img_buffer_original;
}

static int      stbi_jpeg_test(stbi *s);
static stbi_uc *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_jpeg_info(stbi *s, int *x, int *y, int *comp);
static int      stbi_png_test(stbi *s);
static stbi_uc *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_png_info(stbi *s, int *x, int *y, int *comp);
static int      stbi_bmp_test(stbi *s);
static stbi_uc *stbi_bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_tga_test(stbi *s);
static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_tga_info(stbi *s, int *x, int *y, int *comp);
static int      stbi_psd_test(stbi *s);
static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_hdr_test(stbi *s);
static float   *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_pic_test(stbi *s);
static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_gif_test(stbi *s);
static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp);
static int      stbi_gif_info(stbi *s, int *x, int *y, int *comp);


// this is not threadsafe
static const char *failure_reason;

const char *stbi_failure_reason(void)
{
return failure_reason;
}

static int e(const char *str)
{
failure_reason = str;
return 0;
}

// e - error
// epf - error returning pointer to float
// epuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
#define e(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
#define e(x,y)  e(y)
#else
#define e(x,y)  e(x)
#endif

#define epf(x,y)   ((float *) (e(x,y)?NULL:NULL))
#define epuc(x,y)  ((unsigned char *) (e(x,y)?NULL:NULL))

void stbi_image_free(void *retval_from_stbi_load)
{
free(retval_from_stbi_load);
}

#ifndef STBI_NO_HDR
static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static unsigned char *stbi_load_main(stbi *s, int *x, int *y, int *comp, int req_comp)
{
if (stbi_jpeg_test(s)) return stbi_jpeg_load(s,x,y,comp,req_comp);
if (stbi_png_test(s))  return stbi_png_load(s,x,y,comp,req_comp);
if (stbi_bmp_test(s))  return stbi_bmp_load(s,x,y,comp,req_comp);
if (stbi_gif_test(s))  return stbi_gif_load(s,x,y,comp,req_comp);
if (stbi_psd_test(s))  return stbi_psd_load(s,x,y,comp,req_comp);
if (stbi_pic_test(s))  return stbi_pic_load(s,x,y,comp,req_comp);

#ifndef STBI_NO_HDR
if (stbi_hdr_test(s)) {
float *hdr = stbi_hdr_load(s, x,y,comp,req_comp);
return hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
}
#endif

// test tga last because it's a crappy test!
if (stbi_tga_test(s))
return stbi_tga_load(s,x,y,comp,req_comp);
return epuc("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO
unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
FILE *f = fopen(filename, "rb");
unsigned char *result;
if (!f) return epuc("can't fopen", "Unable to open file");
result = stbi_load_from_file(f,x,y,comp,req_comp);
fclose(f);
return result;
}

unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_file(&s,f);
return stbi_load_main(&s,x,y,comp,req_comp);
}
#endif //!STBI_NO_STDIO

unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_mem(&s,buffer,len);
return stbi_load_main(&s,x,y,comp,req_comp);
}

unsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
return stbi_load_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_HDR

float *stbi_loadf_main(stbi *s, int *x, int *y, int *comp, int req_comp)
{
unsigned char *data;
#ifndef STBI_NO_HDR
if (stbi_hdr_test(s))
return stbi_hdr_load(s,x,y,comp,req_comp);
#endif
data = stbi_load_main(s, x, y, comp, req_comp);
if (data)
return ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
return epf("unknown image type", "Image not of any known type, or corrupt");
}

float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_mem(&s,buffer,len);
return stbi_loadf_main(&s,x,y,comp,req_comp);
}

float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
return stbi_loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
FILE *f = fopen(filename, "rb");
float *result;
if (!f) return epf("can't fopen", "Unable to open file");
result = stbi_loadf_from_file(f,x,y,comp,req_comp);
fclose(f);
return result;
}

float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
stbi s;
start_file(&s,f);
return stbi_loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_HDR

// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is
// defined, for API simplicity; if STBI_NO_HDR is defined, it always
// reports false!

int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
#ifndef STBI_NO_HDR
stbi s;
start_mem(&s,buffer,len);
return stbi_hdr_test(&s);
#else
STBI_NOTUSED(buffer);
STBI_NOTUSED(len);
return 0;
#endif
}

#ifndef STBI_NO_STDIO
extern int      stbi_is_hdr          (char const *filename)
{
FILE *f = fopen(filename, "rb");
int result=0;
if (f) {
result = stbi_is_hdr_from_file(f);
fclose(f);
}
return result;
}

extern int      stbi_is_hdr_from_file(FILE *f)
{
#ifndef STBI_NO_HDR
stbi s;
start_file(&s,f);
return stbi_hdr_test(&s);
#else
return 0;
#endif
}
#endif // !STBI_NO_STDIO

extern int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
#ifndef STBI_NO_HDR
stbi s;
start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
return stbi_hdr_test(&s);
#else
return 0;
#endif
}

#ifndef STBI_NO_HDR
static float h2l_gamma_i=1.0f/2.2f, h2l_scale_i=1.0f;
static float l2h_gamma=2.2f, l2h_scale=1.0f;

void   stbi_hdr_to_ldr_gamma(float gamma) { h2l_gamma_i = 1/gamma; }
void   stbi_hdr_to_ldr_scale(float scale) { h2l_scale_i = 1/scale; }

void   stbi_ldr_to_hdr_gamma(float gamma) { l2h_gamma = gamma; }
void   stbi_ldr_to_hdr_scale(float scale) { l2h_scale = scale; }
#endif


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
SCAN_load=0,
SCAN_type,
SCAN_header
};

static void refill_buffer(stbi *s)
{
int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
if (n == 0) {
// at end of file, treat same as if from memory
s->read_from_callbacks = 0;
s->img_buffer = s->img_buffer_end-1;
*s->img_buffer = 0;
} else {
s->img_buffer = s->buffer_start;
s->img_buffer_end = s->buffer_start + n;
}
}

stbi_inline static int get8(stbi *s)
{
if (s->img_buffer < s->img_buffer_end)
return *s->img_buffer++;
if (s->read_from_callbacks) {
refill_buffer(s);
return *s->img_buffer++;
}
return 0;
}

stbi_inline static int at_eof(stbi *s)
{
if (s->io.read) {
if (!(s->io.eof)(s->io_user_data)) return 0;
// if feof() is true, check if buffer = end
// special case: we've only got the special 0 character at the end
if (s->read_from_callbacks == 0) return 1;
}

return s->img_buffer >= s->img_buffer_end;
}

stbi_inline static uint8 get8u(stbi *s)
{
return (uint8) get8(s);
}

static void skip(stbi *s, int n)
{
if (s->io.read) {
int blen = s->img_buffer_end - s->img_buffer;
if (blen < n) {
s->img_buffer = s->img_buffer_end;
(s->io.skip)(s->io_user_data, n - blen);
return;
}
}
s->img_buffer += n;
}

static int getn(stbi *s, stbi_uc *buffer, int n)
{
if (s->io.read) {
int blen = s->img_buffer_end - s->img_buffer;
if (blen < n) {
int res, count;

memcpy(buffer, s->img_buffer, blen);

count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
res = (count == (n-blen));
s->img_buffer = s->img_buffer_end;
return res;
}
}

if (s->img_buffer+n <= s->img_buffer_end) {
memcpy(buffer, s->img_buffer, n);
s->img_buffer += n;
return 1;
} else
return 0;
}

static int get16(stbi *s)
{
int z = get8(s);
return (z << 8) + get8(s);
}

static uint32 get32(stbi *s)
{
uint32 z = get16(s);
return (z << 16) + get16(s);
}

static int get16le(stbi *s)
{
int z = get8(s);
return z + (get8(s) << 8);
}

static uint32 get32le(stbi *s)
{
uint32 z = get16le(s);
return z + (get16le(s) << 16);
}

//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static uint8 compute_y(int r, int g, int b)
{
return (uint8) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static unsigned char *convert_format(unsigned char *data, int img_n, int req_comp, uint x, uint y)
{
int i,j;
unsigned char *good;

if (req_comp == img_n) return data;
assert(req_comp >= 1 && req_comp <= 4);

good = (unsigned char *) malloc(req_comp * x * y);
if (good == NULL) {
free(data);
return epuc("outofmem", "Out of memory");
}

for (j=0; j < (int) y; ++j) {
unsigned char *src  = data + j * x * img_n   ;
unsigned char *dest = good + j * x * req_comp;

#define COMBO(a,b)  ((a)*8+(b))
#define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
// convert source image with img_n components to one with req_comp components;
// avoid switch per pixel, so use switch per scanline and massive macros
switch (COMBO(img_n, req_comp)) {
CASE(1,2) dest[0]=src[0], dest[1]=255; break;
CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
CASE(2,1) dest[0]=src[0]; break;
CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
CASE(3,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
CASE(3,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
CASE(4,1) dest[0]=compute_y(src[0],src[1],src[2]); break;
CASE(4,2) dest[0]=compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
default: assert(0);
}
#undef CASE
}

free(data);
return good;
}

#ifndef STBI_NO_HDR
static float   *ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
int i,k,n;
float *output = (float *) malloc(x * y * comp * sizeof(float));
if (output == NULL) { free(data); return epf("outofmem", "Out of memory"); }
// compute number of non-alpha components
if (comp & 1) n = comp; else n = comp-1;
for (i=0; i < x*y; ++i) {
for (k=0; k < n; ++k) {
output[i*comp + k] = (float) pow(data[i*comp+k]/255.0f, l2h_gamma) * l2h_scale;
}
if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
}
free(data);
return output;
}

#define float2int(x)   ((int) (x))
static stbi_uc *hdr_to_ldr(float   *data, int x, int y, int comp)
{
int i,k,n;
stbi_uc *output = (stbi_uc *) malloc(x * y * comp);
if (output == NULL) { free(data); return epuc("outofmem", "Out of memory"); }
// compute number of non-alpha components
if (comp & 1) n = comp; else n = comp-1;
for (i=0; i < x*y; ++i) {
for (k=0; k < n; ++k) {
float z = (float) pow(data[i*comp+k]*h2l_scale_i, h2l_gamma_i) * 255 + 0.5f;
if (z < 0) z = 0;
if (z > 255) z = 255;
output[i*comp + k] = (uint8) float2int(z);
}
if (k < comp) {
float z = data[i*comp+k] * 255 + 0.5f;
if (z < 0) z = 0;
if (z > 255) z = 255;
output[i*comp + k] = (uint8) float2int(z);
}
}
free(data);
return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder (not actually fully baseline implementation)
//
//    simple implementation
//      - channel subsampling of at most 2 in each dimension
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - uses a lot of intermediate memory, could cache poorly
//      - load http://nothings.org/remote/anemones.jpg 3 times on 2.8Ghz P4
//          stb_jpeg:   1.34 seconds (MSVC6, default release build)
//          stb_jpeg:   1.06 seconds (MSVC6, processor = Pentium Pro)
//          IJL11.dll:  1.08 seconds (compiled by intel)
//          IJG 1998:   0.98 seconds (MSVC6, makefile provided by IJG)
//          IJG 1998:   0.95 seconds (MSVC6, makefile + proc=PPro)

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
uint8  fast[1 << FAST_BITS];
// weirdly, repacking this into AoS is a 10% speed loss, instead of a win
uint16 code[256];
uint8  values[256];
uint8  size[257];
unsigned int maxcode[18];
int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} huffman;

typedef struct
{
#ifdef STBI_SIMD
unsigned short dequant2[4][64];
#endif
stbi *s;
huffman huff_dc[4];
huffman huff_ac[4];
uint8 dequant[4][64];

// sizes for components, interleaved MCUs
int img_h_max, img_v_max;
int img_mcu_x, img_mcu_y;
int img_mcu_w, img_mcu_h;

// definition of jpeg image component
struct
{
int id;
int h,v;
int tq;
int hd,ha;
int dc_pred;

int x,y,w2,h2;
uint8 *data;
void *raw_data;
uint8 *linebuf;
} img_comp[4];

uint32         code_buffer; // jpeg entropy-coded buffer
int            code_bits;   // number of valid bits
unsigned char  marker;      // marker seen while filling entropy buffer
int            nomore;      // flag if we saw a marker so must stop

int scan_n, order[4];
int restart_interval, todo;
} jpeg;

static int build_huffman(huffman *h, int *count)
{
int i,j,k=0,code;
// build size list for each symbol (from JPEG spec)
for (i=0; i < 16; ++i)
for (j=0; j < count[i]; ++j)
h->size[k++] = (uint8) (i+1);
h->size[k] = 0;

// compute actual symbols (from jpeg spec)
code = 0;
k = 0;
for(j=1; j <= 16; ++j) {
// compute delta to add to code to compute symbol id
h->delta[j] = k - code;
if (h->size[k] == j) {
while (h->size[k] == j)
h->code[k++] = (uint16) (code++);
if (code-1 >= (1 << j)) return e("bad code lengths","Corrupt JPEG");
}
// compute largest code + 1 for this size, preshifted as needed later
h->maxcode[j] = code << (16-j);
code <<= 1;
}
h->maxcode[j] = 0xffffffff;

// build non-spec acceleration table; 255 is flag for not-accelerated
memset(h->fast, 255, 1 << FAST_BITS);
for (i=0; i < k; ++i) {
int s = h->size[i];
if (s <= FAST_BITS) {
int c = h->code[i] << (FAST_BITS-s);
int m = 1 << (FAST_BITS-s);
for (j=0; j < m; ++j) {
h->fast[c+j] = (uint8) i;
}
}
}
return 1;
}

static void grow_buffer_unsafe(jpeg *j)
{
do {
int b = j->nomore ? 0 : get8(j->s);
if (b == 0xff) {
int c = get8(j->s);
if (c != 0) {
j->marker = (unsigned char) c;
j->nomore = 1;
return;
}
}
j->code_buffer |= b << (24 - j->code_bits);
j->code_bits += 8;
} while (j->code_bits <= 24);
}

// (1 << n) - 1
static uint32 bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int decode(jpeg *j, huffman *h)
{
unsigned int temp;
int c,k;

if (j->code_bits < 16) grow_buffer_unsafe(j);

// look at the top FAST_BITS and determine what symbol ID it is,
// if the code is <= FAST_BITS
c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
k = h->fast[c];
if (k < 255) {
int s = h->size[k];
if (s > j->code_bits)
return -1;
j->code_buffer <<= s;
j->code_bits -= s;
return h->values[k];
}

// naive test is to shift the code_buffer down so k bits are
// valid, then test against maxcode. To speed this up, we've
// preshifted maxcode left so that it has (16-k) 0s at the
// end; in other words, regardless of the number of bits, it
// wants to be compared against something shifted to have 16;
// that way we don't need to shift inside the loop.
temp = j->code_buffer >> 16;
for (k=FAST_BITS+1 ; ; ++k)
if (temp < h->maxcode[k])
break;
if (k == 17) {
// error! code not found
j->code_bits -= 16;
return -1;
}

if (k > j->code_bits)
return -1;

// convert the huffman code to the symbol id
c = ((j->code_buffer >> (32 - k)) & bmask[k]) + h->delta[k];
assert((((j->code_buffer) >> (32 - h->size[c])) & bmask[h->size[c]]) == h->code[c]);

// convert the id to a symbol
j->code_bits -= k;
j->code_buffer <<= k;
return h->values[c];
}

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int extend_receive(jpeg *j, int n)
{
unsigned int m = 1 << (n-1);
unsigned int k;
if (j->code_bits < n) grow_buffer_unsafe(j);

#if 1
k = stbi_lrot(j->code_buffer, n);
j->code_buffer = k & ~bmask[n];
k &= bmask[n];
j->code_bits -= n;
#else
k = (j->code_buffer >> (32 - n)) & bmask[n];
j->code_bits -= n;
j->code_buffer <<= n;
#endif
// the following test is probably a random branch that won't
// predict well. I tried to table accelerate it but failed.
// maybe it's compiling as a conditional move?
if (k < m)
return (-1 << n) + k + 1;
else
return k;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static uint8 dezigzag[64+15] =
{
0,  1,  8, 16,  9,  2,  3, 10,
17, 24, 32, 25, 18, 11,  4,  5,
12, 19, 26, 33, 40, 48, 41, 34,
27, 20, 13,  6,  7, 14, 21, 28,
35, 42, 49, 56, 57, 50, 43, 36,
29, 22, 15, 23, 30, 37, 44, 51,
58, 59, 52, 45, 38, 31, 39, 46,
53, 60, 61, 54, 47, 55, 62, 63,
// let corrupt input sample past end
63, 63, 63, 63, 63, 63, 63, 63,
63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int decode_block(jpeg *j, short data[64], huffman *hdc, huffman *hac, int b)
{
int diff,dc,k;
int t = decode(j, hdc);
if (t < 0) return e("bad huffman code","Corrupt JPEG");

// 0 all the ac values now so we can do it 32-bits at a time
memset(data,0,64*sizeof(data[0]));

diff = t ? extend_receive(j, t) : 0;
dc = j->img_comp[b].dc_pred + diff;
j->img_comp[b].dc_pred = dc;
data[0] = (short) dc;

// decode AC components, see JPEG spec
k = 1;
do {
int r,s;
int rs = decode(j, hac);
if (rs < 0) return e("bad huffman code","Corrupt JPEG");
s = rs & 15;
r = rs >> 4;
if (s == 0) {
if (rs != 0xf0) break; // end block
k += 16;
} else {
k += r;
// decode into unzigzag'd location
data[dezigzag[k++]] = (short) extend_receive(j,s);
}
} while (k < 64);
return 1;
}

// take a -128..127 value and clamp it and convert to 0..255
stbi_inline static uint8 clamp(int x)
{
// trick to use a single test to catch both cases
if ((unsigned int) x > 255) {
if (x < 0) return 0;
if (x > 255) return 255;
}
return (uint8) x;
}

#define f2f(x)  (int) (((x) * 4096 + 0.5))
#define fsh(x)  ((x) << 12)

// derived from jidctint -- DCT_ISLOW
#define IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \
int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
p2 = s2;                                    \
p3 = s6;                                    \
p1 = (p2+p3) * f2f(0.5411961f);             \
t2 = p1 + p3*f2f(-1.847759065f);            \
t3 = p1 + p2*f2f( 0.765366865f);            \
p2 = s0;                                    \
p3 = s4;                                    \
t0 = fsh(p2+p3);                            \
t1 = fsh(p2-p3);                            \
x0 = t0+t3;                                 \
x3 = t0-t3;                                 \
x1 = t1+t2;                                 \
x2 = t1-t2;                                 \
t0 = s7;                                    \
t1 = s5;                                    \
t2 = s3;                                    \
t3 = s1;                                    \
p3 = t0+t2;                                 \
p4 = t1+t3;                                 \
p1 = t0+t3;                                 \
p2 = t1+t2;                                 \
p5 = (p3+p4)*f2f( 1.175875602f);            \
t0 = t0*f2f( 0.298631336f);                 \
t1 = t1*f2f( 2.053119869f);                 \
t2 = t2*f2f( 3.072711026f);                 \
t3 = t3*f2f( 1.501321110f);                 \
p1 = p5 + p1*f2f(-0.899976223f);            \
p2 = p5 + p2*f2f(-2.562915447f);            \
p3 = p3*f2f(-1.961570560f);                 \
p4 = p4*f2f(-0.390180644f);                 \
t3 += p1+p4;                                \
t2 += p2+p3;                                \
t1 += p2+p4;                                \
t0 += p1+p3;

#ifdef STBI_SIMD
typedef unsigned short stbi_dequantize_t;
#else
typedef uint8 stbi_dequantize_t;
#endif

// .344 seconds on 3*anemones.jpg
static void idct_block(uint8 *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)
{
int i,val[64],*v=val;
stbi_dequantize_t *dq = dequantize;
uint8 *o;
short *d = data;

// columns
for (i=0; i < 8; ++i,++d,++dq, ++v) {
// if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
&& d[40]==0 && d[48]==0 && d[56]==0) {
//    no shortcut                 0     seconds
//    (1|2|3|4|5|6|7)==0          0     seconds
//    all separate               -0.047 seconds
//    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
int dcterm = d[0] * dq[0] << 2;
v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
} else {
IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],
d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])
// constants scaled things up by 1<<12; let's bring them back
// down, but keep 2 extra bits of precision
x0 += 512; x1 += 512; x2 += 512; x3 += 512;
v[ 0] = (x0+t3) >> 10;
v[56] = (x0-t3) >> 10;
v[ 8] = (x1+t2) >> 10;
v[48] = (x1-t2) >> 10;
v[16] = (x2+t1) >> 10;
v[40] = (x2-t1) >> 10;
v[24] = (x3+t0) >> 10;
v[32] = (x3-t0) >> 10;
}
}

for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
// no fast case since the first 1D IDCT spread components out
IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
// constants scaled things up by 1<<12, plus we had 1<<2 from first
// loop, plus horizontal and vertical each scale by sqrt(8) so together
// we've got an extra 1<<3, so 1<<17 total we need to remove.
// so we want to round that, which means adding 0.5 * 1<<17,
// aka 65536. Also, we'll end up with -128 to 127 that we want
// to encode as 0..255 by adding 128, so we'll add that before the shift
x0 += 65536 + (128<<17);
x1 += 65536 + (128<<17);
x2 += 65536 + (128<<17);
x3 += 65536 + (128<<17);
// tried computing the shifts into temps, or'ing the temps to see
// if any were out of range, but that was slower
o[0] = clamp((x0+t3) >> 17);
o[7] = clamp((x0-t3) >> 17);
o[1] = clamp((x1+t2) >> 17);
o[6] = clamp((x1-t2) >> 17);
o[2] = clamp((x2+t1) >> 17);
o[5] = clamp((x2-t1) >> 17);
o[3] = clamp((x3+t0) >> 17);
o[4] = clamp((x3-t0) >> 17);
}
}

#ifdef STBI_SIMD
static stbi_idct_8x8 stbi_idct_installed = idct_block;

void stbi_install_idct(stbi_idct_8x8 func)
{
stbi_idct_installed = func;
}
#endif

#define MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static uint8 get_marker(jpeg *j)
{
uint8 x;
if (j->marker != MARKER_none) { x = j->marker; j->marker = MARKER_none; return x; }
x = get8u(j->s);
if (x != 0xff) return MARKER_none;
while (x == 0xff)
x = get8u(j->s);
return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, reset the entropy decoder and
// the dc prediction
static void reset(jpeg *j)
{
j->code_bits = 0;
j->code_buffer = 0;
j->nomore = 0;
j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
j->marker = MARKER_none;
j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
// no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
// since we don't even allow 1<<30 pixels
}

static int parse_entropy_coded_data(jpeg *z)
{
reset(z);
if (z->scan_n == 1) {
int i,j;
#ifdef STBI_SIMD
__declspec(align(16))
#endif
short data[64];
int n = z->order[0];
// non-interleaved data, we just need to process one block at a time,
// in trivial scanline order
// number of blocks to do just depends on how many actual "pixels" this
// component has, independent of interleaved MCU blocking and such
int w = (z->img_comp[n].x+7) >> 3;
int h = (z->img_comp[n].y+7) >> 3;
for (j=0; j < h; ++j) {
for (i=0; i < w; ++i) {
if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
#ifdef STBI_SIMD
stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
#else
idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
#endif
// every data block is an MCU, so countdown the restart interval
if (--z->todo <= 0) {
if (z->code_bits < 24) grow_buffer_unsafe(z);
// if it's NOT a restart, then just bail, so we get corrupt data
// rather than no data
if (!RESTART(z->marker)) return 1;
reset(z);
}
}
}
} else { // interleaved!
int i,j,k,x,y;
short data[64];
for (j=0; j < z->img_mcu_y; ++j) {
for (i=0; i < z->img_mcu_x; ++i) {
// scan an interleaved mcu... process scan_n components in order
for (k=0; k < z->scan_n; ++k) {
int n = z->order[k];
// scan out an mcu's worth of this component; that's just determined
// by the basic H and V specified for the component
for (y=0; y < z->img_comp[n].v; ++y) {
for (x=0; x < z->img_comp[n].h; ++x) {
int x2 = (i*z->img_comp[n].h + x)*8;
int y2 = (j*z->img_comp[n].v + y)*8;
if (!decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;
#ifdef STBI_SIMD
stbi_idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);
#else
idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);
#endif
}
}
}
// after all interleaved components, that's an interleaved MCU,
// so now count down the restart interval
if (--z->todo <= 0) {
if (z->code_bits < 24) grow_buffer_unsafe(z);
// if it's NOT a restart, then just bail, so we get corrupt data
// rather than no data
if (!RESTART(z->marker)) return 1;
reset(z);
}
}
}
}
return 1;
}

static int process_marker(jpeg *z, int m)
{
int L;
switch (m) {
case MARKER_none: // no marker found
return e("expected marker","Corrupt JPEG");

case 0xC2: // SOF - progressive
return e("progressive jpeg","JPEG format not supported (progressive)");

case 0xDD: // DRI - specify restart interval
if (get16(z->s) != 4) return e("bad DRI len","Corrupt JPEG");
z->restart_interval = get16(z->s);
return 1;

case 0xDB: // DQT - define quantization table
L = get16(z->s)-2;
while (L > 0) {
int q = get8(z->s);
int p = q >> 4;
int t = q & 15,i;
if (p != 0) return e("bad DQT type","Corrupt JPEG");
if (t > 3) return e("bad DQT table","Corrupt JPEG");
for (i=0; i < 64; ++i)
z->dequant[t][dezigzag[i]] = get8u(z->s);
#ifdef STBI_SIMD
for (i=0; i < 64; ++i)
z->dequant2[t][i] = z->dequant[t][i];
#endif
L -= 65;
}
return L==0;

case 0xC4: // DHT - define huffman table
L = get16(z->s)-2;
while (L > 0) {
uint8 *v;
int sizes[16],i,m=0;
int q = get8(z->s);
int tc = q >> 4;
int th = q & 15;
if (tc > 1 || th > 3) return e("bad DHT header","Corrupt JPEG");
for (i=0; i < 16; ++i) {
sizes[i] = get8(z->s);
m += sizes[i];
}
L -= 17;
if (tc == 0) {
if (!build_huffman(z->huff_dc+th, sizes)) return 0;
v = z->huff_dc[th].values;
} else {
if (!build_huffman(z->huff_ac+th, sizes)) return 0;
v = z->huff_ac[th].values;
}
for (i=0; i < m; ++i)
v[i] = get8u(z->s);
L -= m;
}
return L==0;
}
// check for comment block or APP blocks
if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
skip(z->s, get16(z->s)-2);
return 1;
}
return 0;
}

// after we see SOS
static int process_scan_header(jpeg *z)
{
int i;
int Ls = get16(z->s);
z->scan_n = get8(z->s);
if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return e("bad SOS component count","Corrupt JPEG");
if (Ls != 6+2*z->scan_n) return e("bad SOS len","Corrupt JPEG");
for (i=0; i < z->scan_n; ++i) {
int id = get8(z->s), which;
int q = get8(z->s);
for (which = 0; which < z->s->img_n; ++which)
if (z->img_comp[which].id == id)
break;
if (which == z->s->img_n) return 0;
z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return e("bad DC huff","Corrupt JPEG");
z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return e("bad AC huff","Corrupt JPEG");
z->order[i] = which;
}
if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");
get8(z->s); // should be 63, but might be 0
if (get8(z->s) != 0) return e("bad SOS","Corrupt JPEG");

return 1;
}

static int process_frame_header(jpeg *z, int scan)
{
stbi *s = z->s;
int Lf,p,i,q, h_max=1,v_max=1,c;
Lf = get16(s);         if (Lf < 11) return e("bad SOF len","Corrupt JPEG"); // JPEG
p  = get8(s);          if (p != 8) return e("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
s->img_y = get16(s);   if (s->img_y == 0) return e("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
s->img_x = get16(s);   if (s->img_x == 0) return e("0 width","Corrupt JPEG"); // JPEG requires
c = get8(s);
if (c != 3 && c != 1) return e("bad component count","Corrupt JPEG");    // JFIF requires
s->img_n = c;
for (i=0; i < c; ++i) {
z->img_comp[i].data = NULL;
z->img_comp[i].linebuf = NULL;
}

if (Lf != 8+3*s->img_n) return e("bad SOF len","Corrupt JPEG");

for (i=0; i < s->img_n; ++i) {
z->img_comp[i].id = get8(s);
if (z->img_comp[i].id != i+1)   // JFIF requires
if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
return e("bad component ID","Corrupt JPEG");
q = get8(s);
z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return e("bad H","Corrupt JPEG");
z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return e("bad V","Corrupt JPEG");
z->img_comp[i].tq = get8(s);  if (z->img_comp[i].tq > 3) return e("bad TQ","Corrupt JPEG");
}

if (scan != SCAN_load) return 1;

if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");

for (i=0; i < s->img_n; ++i) {
if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
}

// compute interleaved mcu info
z->img_h_max = h_max;
z->img_v_max = v_max;
z->img_mcu_w = h_max * 8;
z->img_mcu_h = v_max * 8;
z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

for (i=0; i < s->img_n; ++i) {
// number of effective pixels (e.g. for non-interleaved MCU)
z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
// to simplify generation, we'll allocate enough memory to decode
// the bogus oversized data from using interleaved MCUs and their
// big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
// discard the extra data until colorspace conversion
z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
z->img_comp[i].raw_data = malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);
if (z->img_comp[i].raw_data == NULL) {
for(--i; i >= 0; --i) {
free(z->img_comp[i].raw_data);
z->img_comp[i].data = NULL;
}
return e("outofmem", "Out of memory");
}
// align blocks for installable-idct using mmx/sse
z->img_comp[i].data = (uint8*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
z->img_comp[i].linebuf = NULL;
}

return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define DNL(x)         ((x) == 0xdc)
#define SOI(x)         ((x) == 0xd8)
#define EOI(x)         ((x) == 0xd9)
#define SOF(x)         ((x) == 0xc0 || (x) == 0xc1)
#define SOS(x)         ((x) == 0xda)

static int decode_jpeg_header(jpeg *z, int scan)
{
int m;
z->marker = MARKER_none; // initialize cached marker to empty
m = get_marker(z);
if (!SOI(m)) return e("no SOI","Corrupt JPEG");
if (scan == SCAN_type) return 1;
m = get_marker(z);
while (!SOF(m)) {
if (!process_marker(z,m)) return 0;
m = get_marker(z);
while (m == MARKER_none) {
// some files have extra padding after their blocks, so ok, we'll scan
if (at_eof(z->s)) return e("no SOF", "Corrupt JPEG");
m = get_marker(z);
}
}
if (!process_frame_header(z, scan)) return 0;
return 1;
}

static int decode_jpeg_image(jpeg *j)
{
int m;
j->restart_interval = 0;
if (!decode_jpeg_header(j, SCAN_load)) return 0;
m = get_marker(j);
while (!EOI(m)) {
if (SOS(m)) {
if (!process_scan_header(j)) return 0;
if (!parse_entropy_coded_data(j)) return 0;
if (j->marker == MARKER_none ) {
// handle 0s at the end of image data from IP Kamera 9060
while (!at_eof(j->s)) {
int x = get8(j->s);
if (x == 255) {
j->marker = get8u(j->s);
break;
} else if (x != 0) {
return 0;
}
}
// if we reach eof without hitting a marker, get_marker() below will fail and we'll eventually return 0
}
} else {
if (!process_marker(j, m)) return 0;
}
m = get_marker(j);
}
return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef uint8 *(*resample_row_func)(uint8 *out, uint8 *in0, uint8 *in1,
int w, int hs);

#define div4(x) ((uint8) ((x) >> 2))

static uint8 *resample_row_1(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
STBI_NOTUSED(out);
STBI_NOTUSED(in_far);
STBI_NOTUSED(w);
STBI_NOTUSED(hs);
return in_near;
}

static uint8* resample_row_v_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
// need to generate two samples vertically for every one in input
int i;
STBI_NOTUSED(hs);
for (i=0; i < w; ++i)
out[i] = div4(3*in_near[i] + in_far[i] + 2);
return out;
}

static uint8*  resample_row_h_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
// need to generate two samples horizontally for every one in input
int i;
uint8 *input = in_near;

if (w == 1) {
// if only one sample, can't do any interpolation
out[0] = out[1] = input[0];
return out;
}

out[0] = input[0];
out[1] = div4(input[0]*3 + input[1] + 2);
for (i=1; i < w-1; ++i) {
int n = 3*input[i]+2;
out[i*2+0] = div4(n+input[i-1]);
out[i*2+1] = div4(n+input[i+1]);
}
out[i*2+0] = div4(input[w-2]*3 + input[w-1] + 2);
out[i*2+1] = input[w-1];

STBI_NOTUSED(in_far);
STBI_NOTUSED(hs);

return out;
}

#define div16(x) ((uint8) ((x) >> 4))

static uint8 *resample_row_hv_2(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
// need to generate 2x2 samples for every one in input
int i,t0,t1;
if (w == 1) {
out[0] = out[1] = div4(3*in_near[0] + in_far[0] + 2);
return out;
}

t1 = 3*in_near[0] + in_far[0];
out[0] = div4(t1+2);
for (i=1; i < w; ++i) {
t0 = t1;
t1 = 3*in_near[i]+in_far[i];
out[i*2-1] = div16(3*t0 + t1 + 8);
out[i*2  ] = div16(3*t1 + t0 + 8);
}
out[w*2-1] = div4(t1+2);

STBI_NOTUSED(hs);

return out;
}

static uint8 *resample_row_generic(uint8 *out, uint8 *in_near, uint8 *in_far, int w, int hs)
{
// resample with nearest-neighbor
int i,j;
in_far = in_far;
for (i=0; i < w; ++i)
for (j=0; j < hs; ++j)
out[i*hs+j] = in_near[i];
return out;
}

#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))

// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)
// VC6 without processor=Pro is generating multiple LEAs per multiply!
static void YCbCr_to_RGB_row(uint8 *out, const uint8 *y, const uint8 *pcb, const uint8 *pcr, int count, int step)
{
int i;
for (i=0; i < count; ++i) {
int y_fixed = (y[i] << 16) + 32768; // rounding
int r,g,b;
int cr = pcr[i] - 128;
int cb = pcb[i] - 128;
r = y_fixed + cr*float2fixed(1.40200f);
g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
b = y_fixed                            + cb*float2fixed(1.77200f);
r >>= 16;
g >>= 16;
b >>= 16;
if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
out[0] = (uint8)r;
out[1] = (uint8)g;
out[2] = (uint8)b;
out[3] = 255;
out += step;
}
}

#ifdef STBI_SIMD
static stbi_YCbCr_to_RGB_run stbi_YCbCr_installed = YCbCr_to_RGB_row;

void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)
{
stbi_YCbCr_installed = func;
}
#endif


// clean up the temporary component buffers
static void cleanup_jpeg(jpeg *j)
{
int i;
for (i=0; i < j->s->img_n; ++i) {
if (j->img_comp[i].data) {
free(j->img_comp[i].raw_data);
j->img_comp[i].data = NULL;
}
if (j->img_comp[i].linebuf) {
free(j->img_comp[i].linebuf);
j->img_comp[i].linebuf = NULL;
}
}
}

typedef struct
{
resample_row_func resample;
uint8 *line0,*line1;
int hs,vs;   // expansion factor in each axis
int w_lores; // horizontal pixels pre-expansion
int ystep;   // how far through vertical expansion we are
int ypos;    // which pre-expansion row we're on
} stbi_resample;

static uint8 *load_jpeg_image(jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
int n, decode_n;
// validate req_comp
if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
z->s->img_n = 0;

// load a jpeg image from whichever source
if (!decode_jpeg_image(z)) { cleanup_jpeg(z); return NULL; }

// determine actual number of components to generate
n = req_comp ? req_comp : z->s->img_n;

if (z->s->img_n == 3 && n < 3)
decode_n = 1;
else
decode_n = z->s->img_n;

// resample and color-convert
{
int k;
uint i,j;
uint8 *output;
uint8 *coutput[4];

stbi_resample res_comp[4];

for (k=0; k < decode_n; ++k) {
stbi_resample *r = &res_comp[k];

// allocate line buffer big enough for upsampling off the edges
// with upsample factor of 4
z->img_comp[k].linebuf = (uint8 *) malloc(z->s->img_x + 3);
if (!z->img_comp[k].linebuf) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

r->hs      = z->img_h_max / z->img_comp[k].h;
r->vs      = z->img_v_max / z->img_comp[k].v;
r->ystep   = r->vs >> 1;
r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
r->ypos    = 0;
r->line0   = r->line1 = z->img_comp[k].data;

if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
else if (r->hs == 1 && r->vs == 2) r->resample = resample_row_v_2;
else if (r->hs == 2 && r->vs == 1) r->resample = resample_row_h_2;
else if (r->hs == 2 && r->vs == 2) r->resample = resample_row_hv_2;
else                               r->resample = resample_row_generic;
}

// can't error after this so, this is safe
output = (uint8 *) malloc(n * z->s->img_x * z->s->img_y + 1);
if (!output) { cleanup_jpeg(z); return epuc("outofmem", "Out of memory"); }

// now go ahead and resample
for (j=0; j < z->s->img_y; ++j) {
uint8 *out = output + n * z->s->img_x * j;
for (k=0; k < decode_n; ++k) {
stbi_resample *r = &res_comp[k];
int y_bot = r->ystep >= (r->vs >> 1);
coutput[k] = r->resample(z->img_comp[k].linebuf,
y_bot ? r->line1 : r->line0,
y_bot ? r->line0 : r->line1,
r->w_lores, r->hs);
if (++r->ystep >= r->vs) {
r->ystep = 0;
r->line0 = r->line1;
if (++r->ypos < z->img_comp[k].y)
r->line1 += z->img_comp[k].w2;
}
}
if (n >= 3) {
uint8 *y = coutput[0];
if (z->s->img_n == 3) {
#ifdef STBI_SIMD
stbi_YCbCr_installed(out, y, coutput[1], coutput[2], z->s.img_x, n);
#else
YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s->img_x, n);
#endif
} else
for (i=0; i < z->s->img_x; ++i) {
out[0] = out[1] = out[2] = y[i];
out[3] = 255; // not used if n==3
out += n;
}
} else {
uint8 *y = coutput[0];
if (n == 1)
for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
else
for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
}
}
cleanup_jpeg(z);
*out_x = z->s->img_x;
*out_y = z->s->img_y;
if (comp) *comp  = z->s->img_n; // report original components, not output
return output;
}
}

static unsigned char *stbi_jpeg_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
jpeg j;
j.s = s;
return load_jpeg_image(&j, x,y,comp,req_comp);
}

static int stbi_jpeg_test(stbi *s)
{
int r;
jpeg j;
j.s = s;
r = decode_jpeg_header(&j, SCAN_type);
stbi_rewind(s);
return r;
}

static int stbi_jpeg_info_raw(jpeg *j, int *x, int *y, int *comp)
{
if (!decode_jpeg_header(j, SCAN_header)) {
stbi_rewind( j->s );
return 0;
}
if (x) *x = j->s->img_x;
if (y) *y = j->s->img_y;
if (comp) *comp = j->s->img_n;
return 1;
}

static int stbi_jpeg_info(stbi *s, int *x, int *y, int *comp)
{
jpeg j;
j.s = s;
return stbi_jpeg_info_raw(&j, x, y, comp);
}

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define ZFAST_BITS  9 // accelerate all cases in default tables
#define ZFAST_MASK  ((1 << ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
uint16 fast[1 << ZFAST_BITS];
uint16 firstcode[16];
int maxcode[17];
uint16 firstsymbol[16];
uint8  size[288];
uint16 value[288];
} zhuffman;

stbi_inline static int bitreverse16(int n)
{
n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
return n;
}

stbi_inline static int bit_reverse(int v, int bits)
{
assert(bits <= 16);
// to bit reverse n bits, reverse 16 and shift
// e.g. 11 bits, bit reverse and shift away 5
return bitreverse16(v) >> (16-bits);
}

static int zbuild_huffman(zhuffman *z, uint8 *sizelist, int num)
{
int i,k=0;
int code, next_code[16], sizes[17];

// DEFLATE spec for generating codes
memset(sizes, 0, sizeof(sizes));
memset(z->fast, 255, sizeof(z->fast));
for (i=0; i < num; ++i)
++sizes[sizelist[i]];
sizes[0] = 0;
for (i=1; i < 16; ++i)
assert(sizes[i] <= (1 << i));
code = 0;
for (i=1; i < 16; ++i) {
next_code[i] = code;
z->firstcode[i] = (uint16) code;
z->firstsymbol[i] = (uint16) k;
code = (code + sizes[i]);
if (sizes[i])
if (code-1 >= (1 << i)) return e("bad codelengths","Corrupt JPEG");
z->maxcode[i] = code << (16-i); // preshift for inner loop
code <<= 1;
k += sizes[i];
}
z->maxcode[16] = 0x10000; // sentinel
for (i=0; i < num; ++i) {
int s = sizelist[i];
if (s) {
int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
z->size[c] = (uint8)s;
z->value[c] = (uint16)i;
if (s <= ZFAST_BITS) {
int k = bit_reverse(next_code[s],s);
while (k < (1 << ZFAST_BITS)) {
z->fast[k] = (uint16) c;
k += (1 << s);
}
}
++next_code[s];
}
}
return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
uint8 *zbuffer, *zbuffer_end;
int num_bits;
uint32 code_buffer;

char *zout;
char *zout_start;
char *zout_end;
int   z_expandable;

zhuffman z_length, z_distance;
} zbuf;

stbi_inline static int zget8(zbuf *z)
{
if (z->zbuffer >= z->zbuffer_end) return 0;
return *z->zbuffer++;
}

static void fill_bits(zbuf *z)
{
do {
assert(z->code_buffer < (1U << z->num_bits));
z->code_buffer |= zget8(z) << z->num_bits;
z->num_bits += 8;
} while (z->num_bits <= 24);
}

stbi_inline static unsigned int zreceive(zbuf *z, int n)
{
unsigned int k;
if (z->num_bits < n) fill_bits(z);
k = z->code_buffer & ((1 << n) - 1);
z->code_buffer >>= n;
z->num_bits -= n;
return k;
}

stbi_inline static int zhuffman_decode(zbuf *a, zhuffman *z)
{
int b,s,k;
if (a->num_bits < 16) fill_bits(a);
b = z->fast[a->code_buffer & ZFAST_MASK];
if (b < 0xffff) {
s = z->size[b];
a->code_buffer >>= s;
a->num_bits -= s;
return z->value[b];
}

// not resolved by fast table, so compute it the slow way
// use jpeg approach, which requires MSbits at top
k = bit_reverse(a->code_buffer, 16);
for (s=ZFAST_BITS+1; ; ++s)
if (k < z->maxcode[s])
break;
if (s == 16) return -1; // invalid code!
// code size is s, so:
b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
assert(z->size[b] == s);
a->code_buffer >>= s;
a->num_bits -= s;
return z->value[b];
}

static int expand(zbuf *z, int n)  // need to make room for n bytes
{
char *q;
int cur, limit;
if (!z->z_expandable) return e("output buffer limit","Corrupt PNG");
cur   = (int) (z->zout     - z->zout_start);
limit = (int) (z->zout_end - z->zout_start);
while (cur + n > limit)
limit *= 2;
q = (char *) realloc(z->zout_start, limit);
if (q == NULL) return e("outofmem", "Out of memory");
z->zout_start = q;
z->zout       = q + cur;
z->zout_end   = q + limit;
return 1;
}

static int length_base[31] = {
3,4,5,6,7,8,9,10,11,13,
15,17,19,23,27,31,35,43,51,59,
67,83,99,115,131,163,195,227,258,0,0 };

static int length_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static int dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static int dist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int parse_huffman_block(zbuf *a)
{
for(;;) {
int z = zhuffman_decode(a, &a->z_length);
if (z < 256) {
if (z < 0) return e("bad huffman code","Corrupt PNG"); // error in huffman codes
if (a->zout >= a->zout_end) if (!expand(a, 1)) return 0;
*a->zout++ = (char) z;
} else {
uint8 *p;
int len,dist;
if (z == 256) return 1;
z -= 257;
len = length_base[z];
if (length_extra[z]) len += zreceive(a, length_extra[z]);
z = zhuffman_decode(a, &a->z_distance);
if (z < 0) return e("bad huffman code","Corrupt PNG");
dist = dist_base[z];
if (dist_extra[z]) dist += zreceive(a, dist_extra[z]);
if (a->zout - a->zout_start < dist) return e("bad dist","Corrupt PNG");
if (a->zout + len > a->zout_end) if (!expand(a, len)) return 0;
p = (uint8 *) (a->zout - dist);
while (len--)
*a->zout++ = *p++;
}
}
}

static int compute_huffman_codes(zbuf *a)
{
static uint8 length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
zhuffman z_codelength;
uint8 lencodes[286+32+137];//padding for maximum single op
uint8 codelength_sizes[19];
int i,n;

int hlit  = zreceive(a,5) + 257;
int hdist = zreceive(a,5) + 1;
int hclen = zreceive(a,4) + 4;

memset(codelength_sizes, 0, sizeof(codelength_sizes));
for (i=0; i < hclen; ++i) {
int s = zreceive(a,3);
codelength_sizes[length_dezigzag[i]] = (uint8) s;
}
if (!zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

n = 0;
while (n < hlit + hdist) {
int c = zhuffman_decode(a, &z_codelength);
assert(c >= 0 && c < 19);
if (c < 16)
lencodes[n++] = (uint8) c;
else if (c == 16) {
c = zreceive(a,2)+3;
memset(lencodes+n, lencodes[n-1], c);
n += c;
} else if (c == 17) {
c = zreceive(a,3)+3;
memset(lencodes+n, 0, c);
n += c;
} else {
assert(c == 18);
c = zreceive(a,7)+11;
memset(lencodes+n, 0, c);
n += c;
}
}
if (n != hlit+hdist) return e("bad codelengths","Corrupt PNG");
if (!zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
if (!zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
return 1;
}

static int parse_uncompressed_block(zbuf *a)
{
uint8 header[4];
int len,nlen,k;
if (a->num_bits & 7)
zreceive(a, a->num_bits & 7); // discard
// drain the bit-packed data into header
k = 0;
while (a->num_bits > 0) {
header[k++] = (uint8) (a->code_buffer & 255); // wtf this warns?
a->code_buffer >>= 8;
a->num_bits -= 8;
}
assert(a->num_bits == 0);
// now fill header the normal way
while (k < 4)
header[k++] = (uint8) zget8(a);
len  = header[1] * 256 + header[0];
nlen = header[3] * 256 + header[2];
if (nlen != (len ^ 0xffff)) return e("zlib corrupt","Corrupt PNG");
if (a->zbuffer + len > a->zbuffer_end) return e("read past buffer","Corrupt PNG");
if (a->zout + len > a->zout_end)
if (!expand(a, len)) return 0;
memcpy(a->zout, a->zbuffer, len);
a->zbuffer += len;
a->zout += len;
return 1;
}

static int parse_zlib_header(zbuf *a)
{
int cmf   = zget8(a);
int cm    = cmf & 15;
/* int cinfo = cmf >> 4; */
int flg   = zget8(a);
if ((cmf*256+flg) % 31 != 0) return e("bad zlib header","Corrupt PNG"); // zlib spec
if (flg & 32) return e("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
if (cm != 8) return e("bad compression","Corrupt PNG"); // DEFLATE required for png
// window = 1 << (8 + cinfo)... but who cares, we fully buffer output
return 1;
}

// @TODO: should statically initialize these for optimal thread safety
static uint8 default_length[288], default_distance[32];
static void init_defaults(void)
{
int i;   // use <= to match clearly with spec
for (i=0; i <= 143; ++i)     default_length[i]   = 8;
for (   ; i <= 255; ++i)     default_length[i]   = 9;
for (   ; i <= 279; ++i)     default_length[i]   = 7;
for (   ; i <= 287; ++i)     default_length[i]   = 8;

for (i=0; i <=  31; ++i)     default_distance[i] = 5;
}

int stbi_png_partial; // a quick hack to only allow decoding some of a PNG... I should implement real streaming support instead
static int parse_zlib(zbuf *a, int parse_header)
{
int final, type;
if (parse_header)
if (!parse_zlib_header(a)) return 0;
a->num_bits = 0;
a->code_buffer = 0;
do {
final = zreceive(a,1);
type = zreceive(a,2);
if (type == 0) {
if (!parse_uncompressed_block(a)) return 0;
} else if (type == 3) {
return 0;
} else {
if (type == 1) {
// use fixed code lengths
if (!default_distance[31]) init_defaults();
if (!zbuild_huffman(&a->z_length  , default_length  , 288)) return 0;
if (!zbuild_huffman(&a->z_distance, default_distance,  32)) return 0;
} else {
if (!compute_huffman_codes(a)) return 0;
}
if (!parse_huffman_block(a)) return 0;
}
if (stbi_png_partial && a->zout - a->zout_start > 65536)
break;
} while (!final);
return 1;
}

static int do_zlib(zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
a->zout_start = obuf;
a->zout       = obuf;
a->zout_end   = obuf + olen;
a->z_expandable = exp;

return parse_zlib(a, parse_header);
}

char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
zbuf a;
char *p = (char *) malloc(initial_size);
if (p == NULL) return NULL;
a.zbuffer = (uint8 *) buffer;
a.zbuffer_end = (uint8 *) buffer + len;
if (do_zlib(&a, p, initial_size, 1, 1)) {
if (outlen) *outlen = (int) (a.zout - a.zout_start);
return a.zout_start;
} else {
free(a.zout_start);
return NULL;
}
}

char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
zbuf a;
char *p = (char *) malloc(initial_size);
if (p == NULL) return NULL;
a.zbuffer = (uint8 *) buffer;
a.zbuffer_end = (uint8 *) buffer + len;
if (do_zlib(&a, p, initial_size, 1, parse_header)) {
if (outlen) *outlen = (int) (a.zout - a.zout_start);
return a.zout_start;
} else {
free(a.zout_start);
return NULL;
}
}

int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
zbuf a;
a.zbuffer = (uint8 *) ibuffer;
a.zbuffer_end = (uint8 *) ibuffer + ilen;
if (do_zlib(&a, obuffer, olen, 0, 1))
return (int) (a.zout - a.zout_start);
else
return -1;
}

char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
zbuf a;
char *p = (char *) malloc(16384);
if (p == NULL) return NULL;
a.zbuffer = (uint8 *) buffer;
a.zbuffer_end = (uint8 *) buffer+len;
if (do_zlib(&a, p, 16384, 1, 0)) {
if (outlen) *outlen = (int) (a.zout - a.zout_start);
return a.zout_start;
} else {
free(a.zout_start);
return NULL;
}
}

int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
zbuf a;
a.zbuffer = (uint8 *) ibuffer;
a.zbuffer_end = (uint8 *) ibuffer + ilen;
if (do_zlib(&a, obuffer, olen, 0, 0))
return (int) (a.zout - a.zout_start);
else
return -1;
}

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding


typedef struct
{
uint32 length;
uint32 type;
} chunk;

#define PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))

static chunk get_chunk_header(stbi *s)
{
chunk c;
c.length = get32(s);
c.type   = get32(s);
return c;
}

static int check_png_header(stbi *s)
{
static uint8 png_sig[8] = { 137,80,78,71,13,10,26,10 };
int i;
for (i=0; i < 8; ++i)
if (get8u(s) != png_sig[i]) return e("bad png sig","Not a PNG");
return 1;
}

typedef struct
{
stbi *s;
uint8 *idata, *expanded, *out;
} png;


enum {
F_none=0, F_sub=1, F_up=2, F_avg=3, F_paeth=4,
F_avg_first, F_paeth_first
};

static uint8 first_row_filter[5] =
{
F_none, F_sub, F_none, F_avg_first, F_paeth_first
};

static int paeth(int a, int b, int c)
{
int p = a + b - c;
int pa = abs(p-a);
int pb = abs(p-b);
int pc = abs(p-c);
if (pa <= pb && pa <= pc) return a;
if (pb <= pc) return b;
return c;
}

// create the png data from post-deflated data
static int create_png_image_raw(png *a, uint8 *raw, uint32 raw_len, int out_n, uint32 x, uint32 y)
{
stbi *s = a->s;
uint32 i,j,stride = x*out_n;
int k;
int img_n = s->img_n; // copy it into a local for later
assert(out_n == s->img_n || out_n == s->img_n+1);
if (stbi_png_partial) y = 1;
a->out = (uint8 *) malloc(x * y * out_n);
if (!a->out) return e("outofmem", "Out of memory");
if (!stbi_png_partial) {
if (s->img_x == x && s->img_y == y) {
if (raw_len != (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");
} else { // interlaced:
if (raw_len < (img_n * x + 1) * y) return e("not enough pixels","Corrupt PNG");
}
}
for (j=0; j < y; ++j) {
uint8 *cur = a->out + stride*j;
uint8 *prior = cur - stride;
int filter = *raw++;
if (filter > 4) return e("invalid filter","Corrupt PNG");
// if first row, use special filter that doesn't sample previous row
if (j == 0) filter = first_row_filter[filter];
// handle first pixel explicitly
for (k=0; k < img_n; ++k) {
switch (filter) {
case F_none       : cur[k] = raw[k]; break;
case F_sub        : cur[k] = raw[k]; break;
case F_up         : cur[k] = raw[k] + prior[k]; break;
case F_avg        : cur[k] = raw[k] + (prior[k]>>1); break;
case F_paeth      : cur[k] = (uint8) (raw[k] + paeth(0,prior[k],0)); break;
case F_avg_first  : cur[k] = raw[k]; break;
case F_paeth_first: cur[k] = raw[k]; break;
}
}
if (img_n != out_n) cur[img_n] = 255;
raw += img_n;
cur += out_n;
prior += out_n;
// this is a little gross, so that we don't switch per-pixel or per-component
if (img_n == out_n) {
#define CASE(f) \
case f:     \
for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \
for (k=0; k < img_n; ++k)
switch (filter) {
CASE(F_none)  cur[k] = raw[k]; break;
CASE(F_sub)   cur[k] = raw[k] + cur[k-img_n]; break;
CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-img_n])>>1); break;
CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;
CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-img_n] >> 1); break;
CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-img_n],0,0)); break;
}
#undef CASE
} else {
assert(img_n+1 == out_n);
#define CASE(f) \
case f:     \
for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
for (k=0; k < img_n; ++k)
switch (filter) {
CASE(F_none)  cur[k] = raw[k]; break;
CASE(F_sub)   cur[k] = raw[k] + cur[k-out_n]; break;
CASE(F_up)    cur[k] = raw[k] + prior[k]; break;
CASE(F_avg)   cur[k] = raw[k] + ((prior[k] + cur[k-out_n])>>1); break;
CASE(F_paeth)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;
CASE(F_avg_first)    cur[k] = raw[k] + (cur[k-out_n] >> 1); break;
CASE(F_paeth_first)  cur[k] = (uint8) (raw[k] + paeth(cur[k-out_n],0,0)); break;
}
#undef CASE
}
}
return 1;
}

static int create_png_image(png *a, uint8 *raw, uint32 raw_len, int out_n, int interlaced)
{
uint8 *final;
int p;
int save;
if (!interlaced)
return create_png_image_raw(a, raw, raw_len, out_n, a->s->img_x, a->s->img_y);
save = stbi_png_partial;
stbi_png_partial = 0;

// de-interlacing
final = (uint8 *) malloc(a->s->img_x * a->s->img_y * out_n);
for (p=0; p < 7; ++p) {
int xorig[] = { 0,4,0,2,0,1,0 };
int yorig[] = { 0,0,4,0,2,0,1 };
int xspc[]  = { 8,8,4,4,2,2,1 };
int yspc[]  = { 8,8,8,4,4,2,2 };
int i,j,x,y;
// pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
if (x && y) {
if (!create_png_image_raw(a, raw, raw_len, out_n, x, y)) {
free(final);
return 0;
}
for (j=0; j < y; ++j)
for (i=0; i < x; ++i)
memcpy(final + (j*yspc[p]+yorig[p])*a->s->img_x*out_n + (i*xspc[p]+xorig[p])*out_n,
a->out + (j*x+i)*out_n, out_n);
free(a->out);
raw += (x*out_n+1)*y;
raw_len -= (x*out_n+1)*y;
}
}
a->out = final;

stbi_png_partial = save;
return 1;
}

static int compute_transparency(png *z, uint8 tc[3], int out_n)
{
stbi *s = z->s;
uint32 i, pixel_count = s->img_x * s->img_y;
uint8 *p = z->out;

// compute color-based transparency, assuming we've
// already got 255 as the alpha value in the output
assert(out_n == 2 || out_n == 4);

if (out_n == 2) {
for (i=0; i < pixel_count; ++i) {
p[1] = (p[0] == tc[0] ? 0 : 255);
p += 2;
}
} else {
for (i=0; i < pixel_count; ++i) {
if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
p[3] = 0;
p += 4;
}
}
return 1;
}

static int expand_palette(png *a, uint8 *palette, int len, int pal_img_n)
{
uint32 i, pixel_count = a->s->img_x * a->s->img_y;
uint8 *p, *temp_out, *orig = a->out;

p = (uint8 *) malloc(pixel_count * pal_img_n);
if (p == NULL) return e("outofmem", "Out of memory");

// between here and free(out) below, exitting would leak
temp_out = p;

if (pal_img_n == 3) {
for (i=0; i < pixel_count; ++i) {
int n = orig[i]*4;
p[0] = palette[n  ];
p[1] = palette[n+1];
p[2] = palette[n+2];
p += 3;
}
} else {
for (i=0; i < pixel_count; ++i) {
int n = orig[i]*4;
p[0] = palette[n  ];
p[1] = palette[n+1];
p[2] = palette[n+2];
p[3] = palette[n+3];
p += 4;
}
}
free(a->out);
a->out = temp_out;

STBI_NOTUSED(len);

return 1;
}

static int stbi_unpremultiply_on_load = 0;
static int stbi_de_iphone_flag = 0;

void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
stbi_unpremultiply_on_load = flag_true_if_should_unpremultiply;
}
void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
stbi_de_iphone_flag = flag_true_if_should_convert;
}

static void stbi_de_iphone(png *z)
{
stbi *s = z->s;
uint32 i, pixel_count = s->img_x * s->img_y;
uint8 *p = z->out;

if (s->img_out_n == 3) {  // convert bgr to rgb
for (i=0; i < pixel_count; ++i) {
uint8 t = p[0];
p[0] = p[2];
p[2] = t;
p += 3;
}
} else {
assert(s->img_out_n == 4);
if (stbi_unpremultiply_on_load) {
// convert bgr to rgb and unpremultiply
for (i=0; i < pixel_count; ++i) {
uint8 a = p[3];
uint8 t = p[0];
if (a) {
p[0] = p[2] * 255 / a;
p[1] = p[1] * 255 / a;
p[2] =  t   * 255 / a;
} else {
p[0] = p[2];
p[2] = t;
}
p += 4;
}
} else {
// convert bgr to rgb
for (i=0; i < pixel_count; ++i) {
uint8 t = p[0];
p[0] = p[2];
p[2] = t;
p += 4;
}
}
}
}

static int parse_png_file(png *z, int scan, int req_comp)
{
uint8 palette[1024], pal_img_n=0;
uint8 has_trans=0, tc[3];
uint32 ioff=0, idata_limit=0, i, pal_len=0;
int first=1,k,interlace=0, iphone=0;
stbi *s = z->s;

z->expanded = NULL;
z->idata = NULL;
z->out = NULL;

if (!check_png_header(s)) return 0;

if (scan == SCAN_type) return 1;

for (;;) {
chunk c = get_chunk_header(s);
switch (c.type) {
case PNG_TYPE('C','g','B','I'):
iphone = stbi_de_iphone_flag;
skip(s, c.length);
break;
case PNG_TYPE('I','H','D','R'): {
int depth,color,comp,filter;
if (!first) return e("multiple IHDR","Corrupt PNG");
first = 0;
if (c.length != 13) return e("bad IHDR len","Corrupt PNG");
s->img_x = get32(s); if (s->img_x > (1 << 24)) return e("too large","Very large image (corrupt?)");
s->img_y = get32(s); if (s->img_y > (1 << 24)) return e("too large","Very large image (corrupt?)");
depth = get8(s);  if (depth != 8)        return e("8bit only","PNG not supported: 8-bit only");
color = get8(s);  if (color > 6)         return e("bad ctype","Corrupt PNG");
if (color == 3) pal_img_n = 3; else if (color & 1) return e("bad ctype","Corrupt PNG");
comp  = get8(s);  if (comp) return e("bad comp method","Corrupt PNG");
filter= get8(s);  if (filter) return e("bad filter method","Corrupt PNG");
interlace = get8(s); if (interlace>1) return e("bad interlace method","Corrupt PNG");
if (!s->img_x || !s->img_y) return e("0-pixel image","Corrupt PNG");
if (!pal_img_n) {
s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
if ((1 << 30) / s->img_x / s->img_n < s->img_y) return e("too large", "Image too large to decode");
if (scan == SCAN_header) return 1;
} else {
// if paletted, then pal_n is our final components, and
// img_n is # components to decompress/filter.
s->img_n = 1;
if ((1 << 30) / s->img_x / 4 < s->img_y) return e("too large","Corrupt PNG");
// if SCAN_header, have to scan to see if we have a tRNS
}
break;
}

case PNG_TYPE('P','L','T','E'):  {
if (first) return e("first not IHDR", "Corrupt PNG");
if (c.length > 256*3) return e("invalid PLTE","Corrupt PNG");
pal_len = c.length / 3;
if (pal_len * 3 != c.length) return e("invalid PLTE","Corrupt PNG");
for (i=0; i < pal_len; ++i) {
palette[i*4+0] = get8u(s);
palette[i*4+1] = get8u(s);
palette[i*4+2] = get8u(s);
palette[i*4+3] = 255;
}
break;
}

case PNG_TYPE('t','R','N','S'): {
if (first) return e("first not IHDR", "Corrupt PNG");
if (z->idata) return e("tRNS after IDAT","Corrupt PNG");
if (pal_img_n) {
if (scan == SCAN_header) { s->img_n = 4; return 1; }
if (pal_len == 0) return e("tRNS before PLTE","Corrupt PNG");
if (c.length > pal_len) return e("bad tRNS len","Corrupt PNG");
pal_img_n = 4;
for (i=0; i < c.length; ++i)
palette[i*4+3] = get8u(s);
} else {
if (!(s->img_n & 1)) return e("tRNS with alpha","Corrupt PNG");
if (c.length != (uint32) s->img_n*2) return e("bad tRNS len","Corrupt PNG");
has_trans = 1;
for (k=0; k < s->img_n; ++k)
tc[k] = (uint8) get16(s); // non 8-bit images will be larger
}
break;
}

case PNG_TYPE('I','D','A','T'): {
if (first) return e("first not IHDR", "Corrupt PNG");
if (pal_img_n && !pal_len) return e("no PLTE","Corrupt PNG");
if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }
if (ioff + c.length > idata_limit) {
uint8 *p;
if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
while (ioff + c.length > idata_limit)
idata_limit *= 2;
p = (uint8 *) realloc(z->idata, idata_limit); if (p == NULL) return e("outofmem", "Out of memory");
z->idata = p;
}
if (!getn(s, z->idata+ioff,c.length)) return e("outofdata","Corrupt PNG");
ioff += c.length;
break;
}

case PNG_TYPE('I','E','N','D'): {
uint32 raw_len;
if (first) return e("first not IHDR", "Corrupt PNG");
if (scan != SCAN_load) return 1;
if (z->idata == NULL) return e("no IDAT","Corrupt PNG");
z->expanded = (uint8 *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, 16384, (int *) &raw_len, !iphone);
if (z->expanded == NULL) return 0; // zlib should set error
free(z->idata); z->idata = NULL;
if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
s->img_out_n = s->img_n+1;
else
s->img_out_n = s->img_n;
if (!create_png_image(z, z->expanded, raw_len, s->img_out_n, interlace)) return 0;
if (has_trans)
if (!compute_transparency(z, tc, s->img_out_n)) return 0;
if (iphone && s->img_out_n > 2)
stbi_de_iphone(z);
if (pal_img_n) {
// pal_img_n == 3 or 4
s->img_n = pal_img_n; // record the actual colors we had
s->img_out_n = pal_img_n;
if (req_comp >= 3) s->img_out_n = req_comp;
if (!expand_palette(z, palette, pal_len, s->img_out_n))
return 0;
}
free(z->expanded); z->expanded = NULL;
return 1;
}

default:
// if critical, fail
if (first) return e("first not IHDR", "Corrupt PNG");
if ((c.type & (1 << 29)) == 0) {
#ifndef STBI_NO_FAILURE_STRINGS
// not threadsafe
static char invalid_chunk[] = "XXXX chunk not known";
invalid_chunk[0] = (uint8) (c.type >> 24);
invalid_chunk[1] = (uint8) (c.type >> 16);
invalid_chunk[2] = (uint8) (c.type >>  8);
invalid_chunk[3] = (uint8) (c.type >>  0);
#endif
return e(invalid_chunk, "PNG not supported: unknown chunk type");
}
skip(s, c.length);
break;
}
// end of chunk, read and skip CRC
get32(s);
}
}

static unsigned char *do_png(png *p, int *x, int *y, int *n, int req_comp)
{
unsigned char *result=NULL;
if (req_comp < 0 || req_comp > 4) return epuc("bad req_comp", "Internal error");
if (parse_png_file(p, SCAN_load, req_comp)) {
result = p->out;
p->out = NULL;
if (req_comp && req_comp != p->s->img_out_n) {
result = convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
p->s->img_out_n = req_comp;
if (result == NULL) return result;
}
*x = p->s->img_x;
*y = p->s->img_y;
if (n) *n = p->s->img_n;
}
free(p->out);      p->out      = NULL;
free(p->expanded); p->expanded = NULL;
free(p->idata);    p->idata    = NULL;

return result;
}

static unsigned char *stbi_png_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
png p;
p.s = s;
return do_png(&p, x,y,comp,req_comp);
}

static int stbi_png_test(stbi *s)
{
int r;
r = check_png_header(s);
stbi_rewind(s);
return r;
}

static int stbi_png_info_raw(png *p, int *x, int *y, int *comp)
{
if (!parse_png_file(p, SCAN_header, 0)) {
stbi_rewind( p->s );
return 0;
}
if (x) *x = p->s->img_x;
if (y) *y = p->s->img_y;
if (comp) *comp = p->s->img_n;
return 1;
}

static int      stbi_png_info(stbi *s, int *x, int *y, int *comp)
{
png p;
p.s = s;
return stbi_png_info_raw(&p, x, y, comp);
}

// Microsoft/Windows BMP image

static int bmp_test(stbi *s)
{
int sz;
if (get8(s) != 'B') return 0;
if (get8(s) != 'M') return 0;
get32le(s); // discard filesize
get16le(s); // discard reserved
get16le(s); // discard reserved
get32le(s); // discard data offset
sz = get32le(s);
if (sz == 12 || sz == 40 || sz == 56 || sz == 108) return 1;
return 0;
}

static int stbi_bmp_test(stbi *s)
{
int r = bmp_test(s);
stbi_rewind(s);
return r;
}


// returns 0..31 for the highest set bit
static int high_bit(unsigned int z)
{
int n=0;
if (z == 0) return -1;
if (z >= 0x10000) n += 16, z >>= 16;
if (z >= 0x00100) n +=  8, z >>=  8;
if (z >= 0x00010) n +=  4, z >>=  4;
if (z >= 0x00004) n +=  2, z >>=  2;
if (z >= 0x00002) n +=  1, z >>=  1;
return n;
}

static int bitcount(unsigned int a)
{
a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
a = (a + (a >> 8)); // max 16 per 8 bits
a = (a + (a >> 16)); // max 32 per 8 bits
return a & 0xff;
}

static int shiftsigned(int v, int shift, int bits)
{
int result;
int z=0;

if (shift < 0) v <<= -shift;
else v >>= shift;
result = v;

z = bits;
while (z < 8) {
result += v >> z;
z += bits;
}
return result;
}

static stbi_uc *bmp_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
uint8 *out;
unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;
stbi_uc pal[256][4];
int psize=0,i,j,compress=0,width;
int bpp, flip_vertically, pad, target, offset, hsz;
if (get8(s) != 'B' || get8(s) != 'M') return epuc("not BMP", "Corrupt BMP");
get32le(s); // discard filesize
get16le(s); // discard reserved
get16le(s); // discard reserved
offset = get32le(s);
hsz = get32le(s);
if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) return epuc("unknown BMP", "BMP type not supported: unknown");
if (hsz == 12) {
s->img_x = get16le(s);
s->img_y = get16le(s);
} else {
s->img_x = get32le(s);
s->img_y = get32le(s);
}
if (get16le(s) != 1) return epuc("bad BMP", "bad BMP");
bpp = get16le(s);
if (bpp == 1) return epuc("monochrome", "BMP type not supported: 1-bit");
flip_vertically = ((int) s->img_y) > 0;
s->img_y = abs((int) s->img_y);
if (hsz == 12) {
if (bpp < 24)
psize = (offset - 14 - 24) / 3;
} else {
compress = get32le(s);
if (compress == 1 || compress == 2) return epuc("BMP RLE", "BMP type not supported: RLE");
get32le(s); // discard sizeof
get32le(s); // discard hres
get32le(s); // discard vres
get32le(s); // discard colorsused
get32le(s); // discard max important
if (hsz == 40 || hsz == 56) {
if (hsz == 56) {
get32le(s);
get32le(s);
get32le(s);
get32le(s);
}
if (bpp == 16 || bpp == 32) {
mr = mg = mb = 0;
if (compress == 0) {
if (bpp == 32) {
mr = 0xffu << 16;
mg = 0xffu <<  8;
mb = 0xffu <<  0;
ma = 0xffu << 24;
fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
} else {
mr = 31u << 10;
mg = 31u <<  5;
mb = 31u <<  0;
}
} else if (compress == 3) {
mr = get32le(s);
mg = get32le(s);
mb = get32le(s);
// not documented, but generated by photoshop and handled by mspaint
if (mr == mg && mg == mb) {
// ?!?!?
return epuc("bad BMP", "bad BMP");
}
} else
return epuc("bad BMP", "bad BMP");
}
} else {
assert(hsz == 108);
mr = get32le(s);
mg = get32le(s);
mb = get32le(s);
ma = get32le(s);
get32le(s); // discard color space
for (i=0; i < 12; ++i)
get32le(s); // discard color space parameters
}
if (bpp < 16)
psize = (offset - 14 - hsz) >> 2;
}
s->img_n = ma ? 4 : 3;
if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
target = req_comp;
else
target = s->img_n; // if they want monochrome, we'll post-convert
out = (stbi_uc *) malloc(target * s->img_x * s->img_y);
if (!out) return epuc("outofmem", "Out of memory");
if (bpp < 16) {
int z=0;
if (psize == 0 || psize > 256) { free(out); return epuc("invalid", "Corrupt BMP"); }
for (i=0; i < psize; ++i) {
pal[i][2] = get8u(s);
pal[i][1] = get8u(s);
pal[i][0] = get8u(s);
if (hsz != 12) get8(s);
pal[i][3] = 255;
}
skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));
if (bpp == 4) width = (s->img_x + 1) >> 1;
else if (bpp == 8) width = s->img_x;
else { free(out); return epuc("bad bpp", "Corrupt BMP"); }
pad = (-width)&3;
for (j=0; j < (int) s->img_y; ++j) {
for (i=0; i < (int) s->img_x; i += 2) {
int v=get8(s),v2=0;
if (bpp == 4) {
v2 = v & 15;
v >>= 4;
}
out[z++] = pal[v][0];
out[z++] = pal[v][1];
out[z++] = pal[v][2];
if (target == 4) out[z++] = 255;
if (i+1 == (int) s->img_x) break;
v = (bpp == 8) ? get8(s) : v2;
out[z++] = pal[v][0];
out[z++] = pal[v][1];
out[z++] = pal[v][2];
if (target == 4) out[z++] = 255;
}
skip(s, pad);
}
} else {
int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
int z = 0;
int easy=0;
skip(s, offset - 14 - hsz);
if (bpp == 24) width = 3 * s->img_x;
else if (bpp == 16) width = 2*s->img_x;
else /* bpp = 32 and pad = 0 */ width=0;
pad = (-width) & 3;
if (bpp == 24) {
easy = 1;
} else if (bpp == 32) {
if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
easy = 2;
}
if (!easy) {
if (!mr || !mg || !mb) { free(out); return epuc("bad masks", "Corrupt BMP"); }
// right shift amt to put high bit in position #7
rshift = high_bit(mr)-7; rcount = bitcount(mr);
gshift = high_bit(mg)-7; gcount = bitcount(mr);
bshift = high_bit(mb)-7; bcount = bitcount(mr);
ashift = high_bit(ma)-7; acount = bitcount(mr);
}
for (j=0; j < (int) s->img_y; ++j) {
if (easy) {
for (i=0; i < (int) s->img_x; ++i) {
int a;
out[z+2] = get8u(s);
out[z+1] = get8u(s);
out[z+0] = get8u(s);
z += 3;
a = (easy == 2 ? get8(s) : 255);
if (target == 4) out[z++] = (uint8) a;
}
} else {
for (i=0; i < (int) s->img_x; ++i) {
uint32 v = (bpp == 16 ? get16le(s) : get32le(s));
int a;
out[z++] = (uint8) shiftsigned(v & mr, rshift, rcount);
out[z++] = (uint8) shiftsigned(v & mg, gshift, gcount);
out[z++] = (uint8) shiftsigned(v & mb, bshift, bcount);
a = (ma ? shiftsigned(v & ma, ashift, acount) : 255);
if (target == 4) out[z++] = (uint8) a;
}
}
skip(s, pad);
}
}
if (flip_vertically) {
stbi_uc t;
for (j=0; j < (int) s->img_y>>1; ++j) {
stbi_uc *p1 = out +      j     *s->img_x*target;
stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
for (i=0; i < (int) s->img_x*target; ++i) {
t = p1[i], p1[i] = p2[i], p2[i] = t;
}
}
}

if (req_comp && req_comp != target) {
out = convert_format(out, target, req_comp, s->img_x, s->img_y);
if (out == NULL) return out; // convert_format frees input on failure
}

*x = s->img_x;
*y = s->img_y;
if (comp) *comp = s->img_n;
return out;
}

static stbi_uc *stbi_bmp_load(stbi *s,int *x, int *y, int *comp, int req_comp)
{
return bmp_load(s, x,y,comp,req_comp);
}


// Targa Truevision - TGA
// by Jonathan Dummer

static int tga_info(stbi *s, int *x, int *y, int *comp)
{
int tga_w, tga_h, tga_comp;
int sz;
get8u(s);                   // discard Offset
sz = get8u(s);              // color type
if( sz > 1 ) {
stbi_rewind(s);
return 0;      // only RGB or indexed allowed
}
sz = get8u(s);              // image type
// only RGB or grey allowed, +/- RLE
if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
skip(s,9);
tga_w = get16le(s);
if( tga_w < 1 ) {
stbi_rewind(s);
return 0;   // test width
}
tga_h = get16le(s);
if( tga_h < 1 ) {
stbi_rewind(s);
return 0;   // test height
}
sz = get8(s);               // bits per pixel
// only RGB or RGBA or grey allowed
if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
stbi_rewind(s);
return 0;
}
tga_comp = sz;
if (x) *x = tga_w;
if (y) *y = tga_h;
if (comp) *comp = tga_comp / 8;
return 1;                   // seems to have passed everything
}

int stbi_tga_info(stbi *s, int *x, int *y, int *comp)
{
return tga_info(s, x, y, comp);
}

static int tga_test(stbi *s)
{
int sz;
get8u(s);      //   discard Offset
sz = get8u(s);   //   color type
if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
sz = get8u(s);   //   image type
if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
get16(s);      //   discard palette start
get16(s);      //   discard palette length
get8(s);         //   discard bits per palette color entry
get16(s);      //   discard x origin
get16(s);      //   discard y origin
if ( get16(s) < 1 ) return 0;      //   test width
if ( get16(s) < 1 ) return 0;      //   test height
sz = get8(s);   //   bits per pixel
if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) ) return 0;   //   only RGB or RGBA or grey allowed
return 1;      //   seems to have passed everything
}

static int stbi_tga_test(stbi *s)
{
int res = tga_test(s);
stbi_rewind(s);
return res;
}

static stbi_uc *tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
//   read in the TGA header stuff
int tga_offset = get8u(s);
int tga_indexed = get8u(s);
int tga_image_type = get8u(s);
int tga_is_RLE = 0;
int tga_palette_start = get16le(s);
int tga_palette_len = get16le(s);
int tga_palette_bits = get8u(s);
int tga_x_origin = get16le(s);
int tga_y_origin = get16le(s);
int tga_width = get16le(s);
int tga_height = get16le(s);
int tga_bits_per_pixel = get8u(s);
int tga_inverted = get8u(s);
//   image data
unsigned char *tga_data;
unsigned char *tga_palette = NULL;
int i, j;
unsigned char raw_data[4];
unsigned char trans_data[4];
int RLE_count = 0;
int RLE_repeating = 0;
int read_next_pixel = 1;

//   do a tiny bit of precessing
if ( tga_image_type >= 8 )
{
tga_image_type -= 8;
tga_is_RLE = 1;
}
/* int tga_alpha_bits = tga_inverted & 15; */
tga_inverted = 1 - ((tga_inverted >> 5) & 1);

//   error check
if ( //(tga_indexed) ||
(tga_width < 1) || (tga_height < 1) ||
(tga_image_type < 1) || (tga_image_type > 3) ||
((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
(tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
)
{
return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
}

//   If I'm paletted, then I'll use the number of bits from the palette
if ( tga_indexed )
{
tga_bits_per_pixel = tga_palette_bits;
}

//   tga info
*x = tga_width;
*y = tga_height;
if ( (req_comp < 1) || (req_comp > 4) )
{
//   just use whatever the file was
req_comp = tga_bits_per_pixel / 8;
*comp = req_comp;
} else
{
//   force a new number of components
*comp = tga_bits_per_pixel/8;
}
tga_data = (unsigned char*)malloc( tga_width * tga_height * req_comp );
if (!tga_data) return epuc("outofmem", "Out of memory");

//   skip to the data's starting position (offset usually = 0)
skip(s, tga_offset );
//   do I need to load a palette?
if ( tga_indexed )
{
//   any data to skip? (offset usually = 0)
skip(s, tga_palette_start );
//   load the palette
tga_palette = (unsigned char*)malloc( tga_palette_len * tga_palette_bits / 8 );
if (!tga_palette) return epuc("outofmem", "Out of memory");
if (!getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {
free(tga_data);
free(tga_palette);
return epuc("bad palette", "Corrupt TGA");
}
}
//   load the data
trans_data[0] = trans_data[1] = trans_data[2] = trans_data[3] = 0;
for (i=0; i < tga_width * tga_height; ++i)
{
//   if I'm in RLE mode, do I need to get a RLE chunk?
if ( tga_is_RLE )
{
if ( RLE_count == 0 )
{
//   yep, get the next byte as a RLE command
int RLE_cmd = get8u(s);
RLE_count = 1 + (RLE_cmd & 127);
RLE_repeating = RLE_cmd >> 7;
read_next_pixel = 1;
} else if ( !RLE_repeating )
{
read_next_pixel = 1;
}
} else
{
read_next_pixel = 1;
}
//   OK, if I need to read a pixel, do it now
if ( read_next_pixel )
{
//   load however much data we did have
if ( tga_indexed )
{
//   read in 1 byte, then perform the lookup
int pal_idx = get8u(s);
if ( pal_idx >= tga_palette_len )
{
//   invalid index
pal_idx = 0;
}
pal_idx *= tga_bits_per_pixel / 8;
for (j = 0; j*8 < tga_bits_per_pixel; ++j)
{
raw_data[j] = tga_palette[pal_idx+j];
}
} else
{
//   read in the data raw
for (j = 0; j*8 < tga_bits_per_pixel; ++j)
{
raw_data[j] = get8u(s);
}
}
//   convert raw to the intermediate format
switch (tga_bits_per_pixel)
{
case 8:
//   Luminous => RGBA
trans_data[0] = raw_data[0];
trans_data[1] = raw_data[0];
trans_data[2] = raw_data[0];
trans_data[3] = 255;
break;
case 16:
//   Luminous,Alpha => RGBA
trans_data[0] = raw_data[0];
trans_data[1] = raw_data[0];
trans_data[2] = raw_data[0];
trans_data[3] = raw_data[1];
break;
case 24:
//   BGR => RGBA
trans_data[0] = raw_data[2];
trans_data[1] = raw_data[1];
trans_data[2] = raw_data[0];
trans_data[3] = 255;
break;
case 32:
//   BGRA => RGBA
trans_data[0] = raw_data[2];
trans_data[1] = raw_data[1];
trans_data[2] = raw_data[0];
trans_data[3] = raw_data[3];
break;
}
//   clear the reading flag for the next pixel
read_next_pixel = 0;
} // end of reading a pixel
//   convert to final format
switch (req_comp)
{
case 1:
//   RGBA => Luminance
tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
break;
case 2:
//   RGBA => Luminance,Alpha
tga_data[i*req_comp+0] = compute_y(trans_data[0],trans_data[1],trans_data[2]);
tga_data[i*req_comp+1] = trans_data[3];
break;
case 3:
//   RGBA => RGB
tga_data[i*req_comp+0] = trans_data[0];
tga_data[i*req_comp+1] = trans_data[1];
tga_data[i*req_comp+2] = trans_data[2];
break;
case 4:
//   RGBA => RGBA
tga_data[i*req_comp+0] = trans_data[0];
tga_data[i*req_comp+1] = trans_data[1];
tga_data[i*req_comp+2] = trans_data[2];
tga_data[i*req_comp+3] = trans_data[3];
break;
}
//   in case we're in RLE mode, keep counting down
--RLE_count;
}
//   do I need to invert the image?
if ( tga_inverted )
{
for (j = 0; j*2 < tga_height; ++j)
{
int index1 = j * tga_width * req_comp;
int index2 = (tga_height - 1 - j) * tga_width * req_comp;
for (i = tga_width * req_comp; i > 0; --i)
{
unsigned char temp = tga_data[index1];
tga_data[index1] = tga_data[index2];
tga_data[index2] = temp;
++index1;
++index2;
}
}
}
//   clear my palette, if I had one
if ( tga_palette != NULL )
{
free( tga_palette );
}
//   the things I do to get rid of an error message, and yet keep
//   Microsoft's C compilers happy... [8^(
tga_palette_start = tga_palette_len = tga_palette_bits =
tga_x_origin = tga_y_origin = 0;
//   OK, done
return tga_data;
}

static stbi_uc *stbi_tga_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
return tga_load(s,x,y,comp,req_comp);
}


// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

static int psd_test(stbi *s)
{
if (get32(s) != 0x38425053) return 0;   // "8BPS"
else return 1;
}

static int stbi_psd_test(stbi *s)
{
int r = psd_test(s);
stbi_rewind(s);
return r;
}

static stbi_uc *psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
int   pixelCount;
int channelCount, compression;
int channel, i, count, len;
int w,h;
uint8 *out;

// Check identifier
if (get32(s) != 0x38425053)   // "8BPS"
return epuc("not PSD", "Corrupt PSD image");

// Check file type version.
if (get16(s) != 1)
return epuc("wrong version", "Unsupported version of PSD image");

// Skip 6 reserved bytes.
skip(s, 6 );

// Read the number of channels (R, G, B, A, etc).
channelCount = get16(s);
if (channelCount < 0 || channelCount > 16)
return epuc("wrong channel count", "Unsupported number of channels in PSD image");

// Read the rows and columns of the image.
h = get32(s);
w = get32(s);

// Make sure the depth is 8 bits.
if (get16(s) != 8)
return epuc("unsupported bit depth", "PSD bit depth is not 8 bit");

// Make sure the color mode is RGB.
// Valid options are:
//   0: Bitmap
//   1: Grayscale
//   2: Indexed color
//   3: RGB color
//   4: CMYK color
//   7: Multichannel
//   8: Duotone
//   9: Lab color
if (get16(s) != 3)
return epuc("wrong color format", "PSD is not in RGB color format");

// Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
skip(s,get32(s) );

// Skip the image resources.  (resolution, pen tool paths, etc)
skip(s, get32(s) );

// Skip the reserved data.
skip(s, get32(s) );

// Find out if the data is compressed.
// Known values:
//   0: no compression
//   1: RLE compressed
compression = get16(s);
if (compression > 1)
return epuc("bad compression", "PSD has an unknown compression format");

// Create the destination image.
out = (stbi_uc *) malloc(4 * w*h);
if (!out) return epuc("outofmem", "Out of memory");
pixelCount = w*h;

// Initialize the data to zero.
//memset( out, 0, pixelCount * 4 );

// Finally, the image data.
if (compression) {
// RLE as used by .PSD and .TIFF
// Loop until you get the number of unpacked bytes you are expecting:
//     Read the next source byte into n.
//     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
//     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
//     Else if n is 128, noop.
// Endloop

// The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
// which we're going to just skip.
skip(s, h * channelCount * 2 );

// Read the RLE data by channel.
for (channel = 0; channel < 4; channel++) {
uint8 *p;

p = out+channel;
if (channel >= channelCount) {
// Fill this channel with default data.
for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;
} else {
// Read the RLE data.
count = 0;
while (count < pixelCount) {
len = get8(s);
if (len == 128) {
// No-op.
} else if (len < 128) {
// Copy next len+1 bytes literally.
len++;
count += len;
while (len) {
*p = get8u(s);
p += 4;
len--;
}
} else if (len > 128) {
uint8   val;
// Next -len+1 bytes in the dest are replicated from next source byte.
// (Interpret len as a negative 8-bit int.)
len ^= 0x0FF;
len += 2;
val = get8u(s);
count += len;
while (len) {
*p = val;
p += 4;
len--;
}
}
}
}
}

} else {
// We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
// where each channel consists of an 8-bit value for each pixel in the image.

// Read the data by channel.
for (channel = 0; channel < 4; channel++) {
uint8 *p;

p = out + channel;
if (channel > channelCount) {
// Fill this channel with default data.
for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;
} else {
// Read the data.
for (i = 0; i < pixelCount; i++)
*p = get8u(s), p += 4;
}
}
}

if (req_comp && req_comp != 4) {
out = convert_format(out, 4, req_comp, w, h);
if (out == NULL) return out; // convert_format frees input on failure
}

if (comp) *comp = channelCount;
*y = h;
*x = w;

return out;
}

static stbi_uc *stbi_psd_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
return psd_load(s,x,y,comp,req_comp);
}

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

static int pic_is4(stbi *s,const char *str)
{
int i;
for (i=0; i<4; ++i)
if (get8(s) != (stbi_uc)str[i])
return 0;

return 1;
}

static int pic_test(stbi *s)
{
int i;

if (!pic_is4(s,"\x53\x80\xF6\x34"))
return 0;

for(i=0;i<84;++i)
get8(s);

if (!pic_is4(s,"PICT"))
return 0;

return 1;
}

typedef struct
{
stbi_uc size,type,channel;
} pic_packet_t;

static stbi_uc *pic_readval(stbi *s, int channel, stbi_uc *dest)
{
int mask=0x80, i;

for (i=0; i<4; ++i, mask>>=1) {
if (channel & mask) {
if (at_eof(s)) return epuc("bad file","PIC file too short");
dest[i]=get8u(s);
}
}

return dest;
}

static void pic_copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
int mask=0x80,i;

for (i=0;i<4; ++i, mask>>=1)
if (channel&mask)
dest[i]=src[i];
}

static stbi_uc *pic_load2(stbi *s,int width,int height,int *comp, stbi_uc *result)
{
int act_comp=0,num_packets=0,y,chained;
pic_packet_t packets[10];

// this will (should...) cater for even some bizarre stuff like having data
// for the same channel in multiple packets.
do {
pic_packet_t *packet;

if (num_packets==sizeof(packets)/sizeof(packets[0]))
return epuc("bad format","too many packets");

packet = &packets[num_packets++];

chained = get8(s);
packet->size    = get8u(s);
packet->type    = get8u(s);
packet->channel = get8u(s);

act_comp |= packet->channel;

if (at_eof(s))          return epuc("bad file","file too short (reading packets)");
if (packet->size != 8)  return epuc("bad format","packet isn't 8bpp");
} while (chained);

*comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

for(y=0; y<height; ++y) {
int packet_idx;

for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
pic_packet_t *packet = &packets[packet_idx];
stbi_uc *dest = result+y*width*4;

switch (packet->type) {
default:
return epuc("bad format","packet has bad compression type");

case 0: {//uncompressed
int x;

for(x=0;x<width;++x, dest+=4)
if (!pic_readval(s,packet->channel,dest))
return 0;
break;
}

case 1://Pure RLE
{
int left=width, i;

while (left>0) {
stbi_uc count,value[4];

count=get8u(s);
if (at_eof(s))   return epuc("bad file","file too short (pure read count)");

if (count > left)
count = (uint8) left;

if (!pic_readval(s,packet->channel,value))  return 0;

for(i=0; i<count; ++i,dest+=4)
pic_copyval(packet->channel,dest,value);
left -= count;
}
}
break;

case 2: {//Mixed RLE
int left=width;
while (left>0) {
int count = get8(s), i;
if (at_eof(s))  return epuc("bad file","file too short (mixed read count)");

if (count >= 128) { // Repeated
stbi_uc value[4];
int i;

if (count==128)
count = get16(s);
else
count -= 127;
if (count > left)
return epuc("bad file","scanline overrun");

if (!pic_readval(s,packet->channel,value))
return 0;

for(i=0;i<count;++i, dest += 4)
pic_copyval(packet->channel,dest,value);
} else { // Raw
++count;
if (count>left) return epuc("bad file","scanline overrun");

for(i=0;i<count;++i, dest+=4)
if (!pic_readval(s,packet->channel,dest))
return 0;
}
left-=count;
}
break;
}
}
}
}

return result;
}

static stbi_uc *pic_load(stbi *s,int *px,int *py,int *comp,int req_comp)
{
stbi_uc *result;
int i, x,y;

for (i=0; i<92; ++i)
get8(s);

x = get16(s);
y = get16(s);
if (at_eof(s))  return epuc("bad file","file too short (pic header)");
if ((1 << 28) / x < y) return epuc("too large", "Image too large to decode");

get32(s); //skip `ratio'
get16(s); //skip `fields'
get16(s); //skip `pad'

// intermediate buffer is RGBA
result = (stbi_uc *) malloc(x*y*4);
memset(result, 0xff, x*y*4);

if (!pic_load2(s,x,y,comp, result)) {
free(result);
result=0;
}
*px = x;
*py = y;
if (req_comp == 0) req_comp = *comp;
result=convert_format(result,4,req_comp,x,y);

return result;
}

static int stbi_pic_test(stbi *s)
{
int r = pic_test(s);
stbi_rewind(s);
return r;
}

static stbi_uc *stbi_pic_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
return pic_load(s,x,y,comp,req_comp);
}

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb
typedef struct stbi_gif_lzw_struct {
int16 prefix;
uint8 first;
uint8 suffix;
} stbi_gif_lzw;

typedef struct stbi_gif_struct
{
int w,h;
stbi_uc *out;                 // output buffer (always 4 components)
int flags, bgindex, ratio, transparent, eflags;
uint8  pal[256][4];
uint8 lpal[256][4];
stbi_gif_lzw codes[4096];
uint8 *color_table;
int parse, step;
int lflags;
int start_x, start_y;
int max_x, max_y;
int cur_x, cur_y;
int line_size;
} stbi_gif;

static int gif_test(stbi *s)
{
int sz;
if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8') return 0;
sz = get8(s);
if (sz != '9' && sz != '7') return 0;
if (get8(s) != 'a') return 0;
return 1;
}

static int stbi_gif_test(stbi *s)
{
int r = gif_test(s);
stbi_rewind(s);
return r;
}

static void stbi_gif_parse_colortable(stbi *s, uint8 pal[256][4], int num_entries, int transp)
{
int i;
for (i=0; i < num_entries; ++i) {
pal[i][2] = get8u(s);
pal[i][1] = get8u(s);
pal[i][0] = get8u(s);
pal[i][3] = transp ? 0 : 255;
}
}

static int stbi_gif_header(stbi *s, stbi_gif *g, int *comp, int is_info)
{
uint8 version;
if (get8(s) != 'G' || get8(s) != 'I' || get8(s) != 'F' || get8(s) != '8')
return e("not GIF", "Corrupt GIF");

version = get8u(s);
if (version != '7' && version != '9')    return e("not GIF", "Corrupt GIF");
if (get8(s) != 'a')                      return e("not GIF", "Corrupt GIF");

failure_reason = "";
g->w = get16le(s);
g->h = get16le(s);
g->flags = get8(s);
g->bgindex = get8(s);
g->ratio = get8(s);
g->transparent = -1;

if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

if (is_info) return 1;

if (g->flags & 0x80)
stbi_gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

return 1;
}

static int stbi_gif_info_raw(stbi *s, int *x, int *y, int *comp)
{
stbi_gif g;
if (!stbi_gif_header(s, &g, comp, 1)) {
stbi_rewind( s );
return 0;
}
if (x) *x = g.w;
if (y) *y = g.h;
return 1;
}

static void stbi_out_gif_code(stbi_gif *g, uint16 code)
{
uint8 *p, *c;

// recurse to decode the prefixes, since the linked-list is backwards,
// and working backwards through an interleaved image would be nasty
if (g->codes[code].prefix >= 0)
stbi_out_gif_code(g, g->codes[code].prefix);

if (g->cur_y >= g->max_y) return;

p = &g->out[g->cur_x + g->cur_y];
c = &g->color_table[g->codes[code].suffix * 4];

if (c[3] >= 128) {
p[0] = c[2];
p[1] = c[1];
p[2] = c[0];
p[3] = c[3];
}
g->cur_x += 4;

if (g->cur_x >= g->max_x) {
g->cur_x = g->start_x;
g->cur_y += g->step;

while (g->cur_y >= g->max_y && g->parse > 0) {
g->step = (1 << g->parse) * g->line_size;
g->cur_y = g->start_y + (g->step >> 1);
--g->parse;
}
}
}

static uint8 *stbi_process_gif_raster(stbi *s, stbi_gif *g)
{
uint8 lzw_cs;
int32 len, code;
uint32 first;
int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
stbi_gif_lzw *p;

lzw_cs = get8u(s);
clear = 1 << lzw_cs;
first = 1;
codesize = lzw_cs + 1;
codemask = (1 << codesize) - 1;
bits = 0;
valid_bits = 0;
for (code = 0; code < clear; code++) {
g->codes[code].prefix = -1;
g->codes[code].first = (uint8) code;
g->codes[code].suffix = (uint8) code;
}

// support no starting clear code
avail = clear+2;
oldcode = -1;

len = 0;
for(;;) {
if (valid_bits < codesize) {
if (len == 0) {
len = get8(s); // start new block
if (len == 0)
return g->out;
}
--len;
bits |= (int32) get8(s) << valid_bits;
valid_bits += 8;
} else {
int32 code = bits & codemask;
bits >>= codesize;
valid_bits -= codesize;
// @OPTIMIZE: is there some way we can accelerate the non-clear path?
if (code == clear) {  // clear code
codesize = lzw_cs + 1;
codemask = (1 << codesize) - 1;
avail = clear + 2;
oldcode = -1;
first = 0;
} else if (code == clear + 1) { // end of stream code
skip(s, len);
while ((len = get8(s)) > 0)
skip(s,len);
return g->out;
} else if (code <= avail) {
if (first) return epuc("no clear code", "Corrupt GIF");

if (oldcode >= 0) {
p = &g->codes[avail++];
if (avail > 4096)        return epuc("too many codes", "Corrupt GIF");
p->prefix = (int16) oldcode;
p->first = g->codes[oldcode].first;
p->suffix = (code == avail) ? p->first : g->codes[code].first;
} else if (code == avail)
return epuc("illegal code in raster", "Corrupt GIF");

stbi_out_gif_code(g, (uint16) code);

if ((avail & codemask) == 0 && avail <= 0x0FFF) {
codesize++;
codemask = (1 << codesize) - 1;
}

oldcode = code;
} else {
return epuc("illegal code in raster", "Corrupt GIF");
}
}
}
}

static void stbi_fill_gif_background(stbi_gif *g)
{
int i;
uint8 *c = g->pal[g->bgindex];
// @OPTIMIZE: write a dword at a time
for (i = 0; i < g->w * g->h * 4; i += 4) {
uint8 *p  = &g->out[i];
p[0] = c[2];
p[1] = c[1];
p[2] = c[0];
p[3] = c[3];
}
}

// this function is designed to support animated gifs, although stb_image doesn't support it
static uint8 *stbi_gif_load_next(stbi *s, stbi_gif *g, int *comp, int req_comp)
{
int i;
uint8 *old_out = 0;

if (g->out == 0) {
if (!stbi_gif_header(s, g, comp,0))     return 0; // failure_reason set by stbi_gif_header
g->out = (uint8 *) malloc(4 * g->w * g->h);
if (g->out == 0)                      return epuc("outofmem", "Out of memory");
stbi_fill_gif_background(g);
} else {
// animated-gif-only path
if (((g->eflags & 0x1C) >> 2) == 3) {
old_out = g->out;
g->out = (uint8 *) malloc(4 * g->w * g->h);
if (g->out == 0)                   return epuc("outofmem", "Out of memory");
memcpy(g->out, old_out, g->w*g->h*4);
}
}

for (;;) {
switch (get8(s)) {
case 0x2C: /* Image Descriptor */
{
int32 x, y, w, h;
uint8 *o;

x = get16le(s);
y = get16le(s);
w = get16le(s);
h = get16le(s);
if (((x + w) > (g->w)) || ((y + h) > (g->h)))
return epuc("bad Image Descriptor", "Corrupt GIF");

g->line_size = g->w * 4;
g->start_x = x * 4;
g->start_y = y * g->line_size;
g->max_x   = g->start_x + w * 4;
g->max_y   = g->start_y + h * g->line_size;
g->cur_x   = g->start_x;
g->cur_y   = g->start_y;

g->lflags = get8(s);

if (g->lflags & 0x40) {
g->step = 8 * g->line_size; // first interlaced spacing
g->parse = 3;
} else {
g->step = g->line_size;
g->parse = 0;
}

if (g->lflags & 0x80) {
stbi_gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
g->color_table = (uint8 *) g->lpal;
} else if (g->flags & 0x80) {
for (i=0; i < 256; ++i)  // @OPTIMIZE: reset only the previous transparent
g->pal[i][3] = 255;
if (g->transparent >= 0 && (g->eflags & 0x01))
g->pal[g->transparent][3] = 0;
g->color_table = (uint8 *) g->pal;
} else
return epuc("missing color table", "Corrupt GIF");

o = stbi_process_gif_raster(s, g);
if (o == NULL) return NULL;

if (req_comp && req_comp != 4)
o = convert_format(o, 4, req_comp, g->w, g->h);
return o;
}

case 0x21: // Comment Extension.
{
int len;
if (get8(s) == 0xF9) { // Graphic Control Extension.
len = get8(s);
if (len == 4) {
g->eflags = get8(s);
get16le(s); // delay
g->transparent = get8(s);
} else {
skip(s, len);
break;
}
}
while ((len = get8(s)) != 0)
skip(s, len);
break;
}

case 0x3B: // gif stream termination code
return (uint8 *) 1;

default:
return epuc("unknown code", "Corrupt GIF");
}
}
}

static stbi_uc *stbi_gif_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
uint8 *u = 0;
stbi_gif g={0};

u = stbi_gif_load_next(s, &g, comp, req_comp);
if (u == (void *) 1) u = 0;  // end of animated gif marker
if (u) {
*x = g.w;
*y = g.h;
}

return u;
}

static int stbi_gif_info(stbi *s, int *x, int *y, int *comp)
{
return stbi_gif_info_raw(s,x,y,comp);
}


// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int hdr_test(stbi *s)
{
const char *signature = "#?RADIANCE\n";
int i;
for (i=0; signature[i]; ++i)
if (get8(s) != signature[i])
return 0;
return 1;
}

static int stbi_hdr_test(stbi* s)
{
int r = hdr_test(s);
stbi_rewind(s);
return r;
}

#define HDR_BUFLEN  1024
static char *hdr_gettoken(stbi *z, char *buffer)
{
int len=0;
char c = '\0';

c = (char) get8(z);

while (!at_eof(z) && c != '\n') {
buffer[len++] = c;
if (len == HDR_BUFLEN-1) {
// flush to end of line
while (!at_eof(z) && get8(z) != '\n')
;
break;
}
c = (char) get8(z);
}

buffer[len] = 0;
return buffer;
}

static void hdr_convert(float *output, stbi_uc *input, int req_comp)
{
if ( input[3] != 0 ) {
float f1;
// Exponent
f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
if (req_comp <= 2)
output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
else {
output[0] = input[0] * f1;
output[1] = input[1] * f1;
output[2] = input[2] * f1;
}
if (req_comp == 2) output[1] = 1;
if (req_comp == 4) output[3] = 1;
} else {
switch (req_comp) {
case 4: output[3] = 1; /* fallthrough */
case 3: output[0] = output[1] = output[2] = 0;
break;
case 2: output[1] = 1; /* fallthrough */
case 1: output[0] = 0;
break;
}
}
}

static float *hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
char buffer[HDR_BUFLEN];
char *token;
int valid = 0;
int width, height;
stbi_uc *scanline;
float *hdr_data;
int len;
unsigned char count, value;
int i, j, k, c1,c2, z;


// Check identifier
if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
return epf("not HDR", "Corrupt HDR image");

// Parse header
for(;;) {
token = hdr_gettoken(s,buffer);
if (token[0] == 0) break;
if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
}

if (!valid)    return epf("unsupported format", "Unsupported HDR format");

// Parse width and height
// can't use sscanf() if we're not using stdio!
token = hdr_gettoken(s,buffer);
if (strncmp(token, "-Y ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
token += 3;
height = strtol(token, &token, 10);
while (*token == ' ') ++token;
if (strncmp(token, "+X ", 3))  return epf("unsupported data layout", "Unsupported HDR format");
token += 3;
width = strtol(token, NULL, 10);

*x = width;
*y = height;

*comp = 3;
if (req_comp == 0) req_comp = 3;

// Read data
hdr_data = (float *) malloc(height * width * req_comp * sizeof(float));

// Load image data
// image data is stored as some number of sca
if ( width < 8 || width >= 32768) {
// Read flat data
for (j=0; j < height; ++j) {
for (i=0; i < width; ++i) {
stbi_uc rgbe[4];
main_decode_loop:
getn(s, rgbe, 4);
hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
}
}
} else {
// Read RLE-encoded data
scanline = NULL;

for (j = 0; j < height; ++j) {
c1 = get8(s);
c2 = get8(s);
len = get8(s);
if (c1 != 2 || c2 != 2 || (len & 0x80)) {
// not run-length encoded, so we have to actually use THIS data as a decoded
// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
uint8 rgbe[4];
rgbe[0] = (uint8) c1;
rgbe[1] = (uint8) c2;
rgbe[2] = (uint8) len;
rgbe[3] = (uint8) get8u(s);
hdr_convert(hdr_data, rgbe, req_comp);
i = 1;
j = 0;
free(scanline);
goto main_decode_loop; // yes, this makes no sense
}
len <<= 8;
len |= get8(s);
if (len != width) { free(hdr_data); free(scanline); return epf("invalid decoded scanline length", "corrupt HDR"); }
if (scanline == NULL) scanline = (stbi_uc *) malloc(width * 4);

for (k = 0; k < 4; ++k) {
i = 0;
while (i < width) {
count = get8u(s);
if (count > 128) {
// Run
value = get8u(s);
count -= 128;
for (z = 0; z < count; ++z)
scanline[i++ * 4 + k] = value;
} else {
// Dump
for (z = 0; z < count; ++z)
scanline[i++ * 4 + k] = get8u(s);
}
}
}
for (i=0; i < width; ++i)
hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
}
free(scanline);
}

return hdr_data;
}

static float *stbi_hdr_load(stbi *s, int *x, int *y, int *comp, int req_comp)
{
return hdr_load(s,x,y,comp,req_comp);
}

static int stbi_hdr_info(stbi *s, int *x, int *y, int *comp)
{
char buffer[HDR_BUFLEN];
char *token;
int valid = 0;

if (strcmp(hdr_gettoken(s,buffer), "#?RADIANCE") != 0) {
stbi_rewind( s );
return 0;
}

for(;;) {
token = hdr_gettoken(s,buffer);
if (token[0] == 0) break;
if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
}

if (!valid) {
stbi_rewind( s );
return 0;
}
token = hdr_gettoken(s,buffer);
if (strncmp(token, "-Y ", 3)) {
stbi_rewind( s );
return 0;
}
token += 3;
*y = strtol(token, &token, 10);
while (*token == ' ') ++token;
if (strncmp(token, "+X ", 3)) {
stbi_rewind( s );
return 0;
}
token += 3;
*x = strtol(token, NULL, 10);
*comp = 3;
return 1;
}
#endif // STBI_NO_HDR

static int stbi_bmp_info(stbi *s, int *x, int *y, int *comp)
{
int hsz;
if (get8(s) != 'B' || get8(s) != 'M') {
stbi_rewind( s );
return 0;
}
skip(s,12);
hsz = get32le(s);
if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108) {
stbi_rewind( s );
return 0;
}
if (hsz == 12) {
*x = get16le(s);
*y = get16le(s);
} else {
*x = get32le(s);
*y = get32le(s);
}
if (get16le(s) != 1) {
stbi_rewind( s );
return 0;
}
*comp = get16le(s) / 8;
return 1;
}

static int stbi_psd_info(stbi *s, int *x, int *y, int *comp)
{
int channelCount;
if (get32(s) != 0x38425053) {
stbi_rewind( s );
return 0;
}
if (get16(s) != 1) {
stbi_rewind( s );
return 0;
}
skip(s, 6);
channelCount = get16(s);
if (channelCount < 0 || channelCount > 16) {
stbi_rewind( s );
return 0;
}
*y = get32(s);
*x = get32(s);
if (get16(s) != 8) {
stbi_rewind( s );
return 0;
}
if (get16(s) != 3) {
stbi_rewind( s );
return 0;
}
*comp = 4;
return 1;
}

static int stbi_pic_info(stbi *s, int *x, int *y, int *comp)
{
int act_comp=0,num_packets=0,chained;
pic_packet_t packets[10];

skip(s, 92);

*x = get16(s);
*y = get16(s);
if (at_eof(s))  return 0;
if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
stbi_rewind( s );
return 0;
}

skip(s, 8);

do {
pic_packet_t *packet;

if (num_packets==sizeof(packets)/sizeof(packets[0]))
return 0;

packet = &packets[num_packets++];
chained = get8(s);
packet->size    = get8u(s);
packet->type    = get8u(s);
packet->channel = get8u(s);
act_comp |= packet->channel;

if (at_eof(s)) {
stbi_rewind( s );
return 0;
}
if (packet->size != 8) {
stbi_rewind( s );
return 0;
}
} while (chained);

*comp = (act_comp & 0x10 ? 4 : 3);

return 1;
}

static int stbi_info_main(stbi *s, int *x, int *y, int *comp)
{
if (stbi_jpeg_info(s, x, y, comp))
return 1;
if (stbi_png_info(s, x, y, comp))
return 1;
if (stbi_gif_info(s, x, y, comp))
return 1;
if (stbi_bmp_info(s, x, y, comp))
return 1;
if (stbi_psd_info(s, x, y, comp))
return 1;
if (stbi_pic_info(s, x, y, comp))
return 1;
#ifndef STBI_NO_HDR
if (stbi_hdr_info(s, x, y, comp))
return 1;
#endif
// test tga last because it's a crappy test!
if (stbi_tga_info(s, x, y, comp))
return 1;
return e("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO
int stbi_info(char const *filename, int *x, int *y, int *comp)
{
FILE *f = fopen(filename, "rb");
int result;
if (!f) return e("can't fopen", "Unable to open file");
result = stbi_info_from_file(f, x, y, comp);
fclose(f);
return result;
}

int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
int r;
stbi s;
long pos = ftell(f);
start_file(&s, f);
r = stbi_info_main(&s,x,y,comp);
fseek(f,pos,SEEK_SET);
return r;
}
#endif // !STBI_NO_STDIO

int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
stbi s;
start_mem(&s,buffer,len);
return stbi_info_main(&s,x,y,comp);
}

int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
stbi s;
start_callbacks(&s, (stbi_io_callbacks *) c, user);
return stbi_info_main(&s,x,y,comp);
}

#endif // STBI_HEADER_FILE_ONLY

/*
revision history:
1.33 (2011-07-14)
make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
1.32 (2011-07-13)
support for "info" function for all supported filetypes (SpartanJ)
1.31 (2011-06-20)
a few more leak fixes, bug in PNG handling (SpartanJ)
1.30 (2011-06-11)
added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
removed deprecated format-specific test/load functions
removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
fix inefficiency in decoding 32-bit BMP (David Woo)
1.29 (2010-08-16)
various warning fixes from Aurelien Pocheville
1.28 (2010-08-01)
fix bug in GIF palette transparency (SpartanJ)
1.27 (2010-08-01)
cast-to-uint8 to fix warnings
1.26 (2010-07-24)
fix bug in file buffering for PNG reported by SpartanJ
1.25 (2010-07-17)
refix trans_data warning (Won Chun)
1.24 (2010-07-12)
perf improvements reading from files on platforms with lock-heavy fgetc()
minor perf improvements for jpeg
deprecated type-specific functions so we'll get feedback if they're needed
attempt to fix trans_data warning (Won Chun)
1.23   fixed bug in iPhone support
1.22 (2010-07-10)
removed image *writing* support
stbi_info support from Jetro Lauha
GIF support from Jean-Marc Lienher
iPhone PNG-extensions from James Brown
warning-fixes from Nicolas Schulz and Janez Zemva (i.e. Janez (U+017D)emva)
1.21   fix use of 'uint8' in header (reported by jon blow)
1.20   added support for Softimage PIC, by Tom Seddon
1.19   bug in interlaced PNG corruption check (found by ryg)
1.18 2008-08-02
fix a threading bug (local mutable static)
1.17   support interlaced PNG
1.16   major bugfix - convert_format converted one too many pixels
1.15   initialize some fields for thread safety
1.14   fix threadsafe conversion bug
header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
1.13   threadsafe
1.12   const qualifiers in the API
1.11   Support installable IDCT, colorspace conversion routines
1.10   Fixes for 64-bit (don't use "unsigned long")
optimized upsampling by Fabian "ryg" Giesen
1.09   Fix format-conversion for PSD code (bad global variables!)
1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz
1.07   attempt to fix C++ warning/errors again
1.06   attempt to fix C++ warning/errors again
1.05   fix TGA loading to return correct *comp and use good luminance calc
1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free
1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR
1.02   support for (subset of) HDR files, float interface for preferred access to them
1.01   fix bug: possible bug in handling right-side up bmps... not sure
fix bug: the stbi_bmp_load() and stbi_tga_load() functions didn't work at all
1.00   interface to zlib that skips zlib header
0.99   correct handling of alpha in palette
0.98   TGA loader by lonesock; dynamically add loaders (untested)
0.97   jpeg errors on too large a file; also catch another malloc failure
0.96   fix detection of invalid v value - particleman@mollyrocket forum
0.95   during header scan, seek to markers in case of padding
0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same
0.93   handle jpegtran output; verbose errors
0.92   read 4,8,16,24,32-bit BMP files of several formats
0.91   output 24-bit Windows 3.0 BMP files
0.90   fix a few more warnings; bump version number to approach 1.0
0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd
0.60   fix compiling as c++
0.59   fix warnings: merge Dave Moore's -Wall fixes
0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian
0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
0.56   fix bug: zlib uncompressed mode len vs. nlen
0.55   fix bug: restart_interval not initialized to 0
0.54   allow NULL for 'int *comp'
0.53   fix bug in png 3->4; speedup png decoding
0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments
0.51   obey req_comp requests, 1-component jpegs return as 1-component,
on 'test' only check type, not whether we support this variant
0.50   first released version
*/
#ifdef _WIN32
#pragma warning( pop )
#endif

#pragma warning(disable: 4804)
/*
xxHash - Fast Hash algorithm
Copyright (C) 2012-2014, Yann Collet.
BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

You can contact the author at :
- xxHash source repository : http://code.google.com/p/xxhash/
*/


//**************************************
// Tuning parameters
//**************************************
// Unaligned memory access is automatically enabled for "common" CPU, such as x86.
// For others CPU, the compiler will be more cautious, and insert extra code to ensure aligned access is respected.
// If you know your target CPU supports unaligned memory access, you want to force this option manually to improve performance.
// You can also enable this parameter if you know your input data will always be aligned (boundaries of 4, for U32).
#if defined(__ARM_FEATURE_UNALIGNED) || defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
#  define XXH_USE_UNALIGNED_ACCESS 1
#endif

// XXH_ACCEPT_NULL_INPUT_POINTER :
// If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.
// When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.
// This option has a very small performance cost (only measurable on small inputs).
// By default, this option is disabled. To enable it, uncomment below define :
// #define XXH_ACCEPT_NULL_INPUT_POINTER 1

// XXH_FORCE_NATIVE_FORMAT :
// By default, xxHash library provides endian-independant Hash values, based on little-endian convention.
// Results are therefore identical for little-endian and big-endian CPU.
// This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
// Should endian-independance be of no importance for your application, you may set the #define below to 1.
// It will improve speed for Big-endian CPU.
// This option has no impact on Little_Endian CPU.
#define XXH_FORCE_NATIVE_FORMAT 0

//**************************************
// Compiler Specific Options
//**************************************
// Disable some Visual warning messages
#ifdef _MSC_VER  // Visual Studio
#  pragma warning(disable : 4127)      // disable: C4127: conditional expression is constant
#endif

#ifdef _MSC_VER    // Visual Studio
#  define FORCE_INLINE static __forceinline
#else
#  ifdef __GNUC__
#    define FORCE_INLINE static inline __attribute__((always_inline))
#  else
#    define FORCE_INLINE static inline
#  endif
#endif

//**************************************
// Includes & Memory related functions
//**************************************
// Modify the local functions below should you wish to use some other memory related routines
// for malloc(), free()
FORCE_INLINE void* XXH_malloc(size_t s) { return malloc(s); }
FORCE_INLINE void  XXH_free  (void* p)  { free(p); }
// for memcpy()
FORCE_INLINE void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }


//**************************************
// Basic Types
//**************************************
#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   // C99
# include <stdint.h>
typedef uint8_t  BYTE;
typedef uint16_t U16;
typedef uint32_t U32;
typedef  int32_t S32;
typedef uint64_t U64;
#else
typedef unsigned char      BYTE;
typedef unsigned short     U16;
typedef unsigned int       U32;
typedef   signed int       S32;
typedef unsigned long long U64;
#endif

#if defined(__GNUC__)  && !defined(XXH_USE_UNALIGNED_ACCESS)
#  define _PACKED __attribute__ ((packed))
#else
#  define _PACKED
#endif

#if !defined(XXH_USE_UNALIGNED_ACCESS) && !defined(__GNUC__)
#  ifdef __IBMC__
#    pragma pack(1)
#  else
#    pragma pack(push, 1)
#  endif
#endif

typedef struct _U32_S { U32 v; } _PACKED U32_S;
typedef struct _U64_S { U64 v; } _PACKED U64_S;

#if !defined(XXH_USE_UNALIGNED_ACCESS) && !defined(__GNUC__)
#  pragma pack(pop)
#endif

#define A32(x) (((U32_S *)(x))->v)
#define A64(x) (((U64_S *)(x))->v)


//***************************************
// Compiler-specific Functions and Macros
//***************************************
#define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)

// Note : although _rotl exists for minGW (GCC under windows), performance seems poor
#if defined(_MSC_VER)
#  define XXH_rotl32(x,r) _rotl(x,r)
#  define XXH_rotl64(x,r) _rotl64(x,r)
#else
#  define XXH_rotl32(x,r) ((x << r) | (x >> (32 - r)))
#  define XXH_rotl64(x,r) ((x << r) | (x >> (64 - r)))
#endif

#if defined(_MSC_VER)     // Visual Studio
#  define XXH_swap32 _byteswap_ulong
#  define XXH_swap64 _byteswap_uint64
#elif GCC_VERSION >= 403
#  define XXH_swap32 __builtin_bswap32
#  define XXH_swap64 __builtin_bswap64
#else
static inline U32 XXH_swap32 (U32 x) {
return  ((x << 24) & 0xff000000 ) |
((x <<  8) & 0x00ff0000 ) |
((x >>  8) & 0x0000ff00 ) |
((x >> 24) & 0x000000ff );}
static inline U64 XXH_swap64 (U64 x) {
return  ((x << 56) & 0xff00000000000000ULL) |
((x << 40) & 0x00ff000000000000ULL) |
((x << 24) & 0x0000ff0000000000ULL) |
((x << 8)  & 0x000000ff00000000ULL) |
((x >> 8)  & 0x00000000ff000000ULL) |
((x >> 24) & 0x0000000000ff0000ULL) |
((x >> 40) & 0x000000000000ff00ULL) |
((x >> 56) & 0x00000000000000ffULL);}
#endif


//**************************************
// Constants
//**************************************
#define PRIME32_1   2654435761U
#define PRIME32_2   2246822519U
#define PRIME32_3   3266489917U
#define PRIME32_4    668265263U
#define PRIME32_5    374761393U

#define PRIME64_1 11400714785074694791ULL
#define PRIME64_2 14029467366897019727ULL
#define PRIME64_3  1609587929392839161ULL
#define PRIME64_4  9650029242287828579ULL
#define PRIME64_5  2870177450012600261ULL

//**************************************
// Architecture Macros
//**************************************
typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
#ifndef XXH_CPU_LITTLE_ENDIAN   // It is possible to define XXH_CPU_LITTLE_ENDIAN externally, for example using a compiler switch
static const int one = 1;
#   define XXH_CPU_LITTLE_ENDIAN   (*(char*)(&one))
#endif


//**************************************
// Macros
//**************************************
#define XXH_STATIC_ASSERT(c)   { enum { XXH_static_assert = 1/(!!(c)) }; }    // use only *after* variable declarations


//****************************
// Memory reads
//****************************
typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;

FORCE_INLINE U32 XXH_readLE32_align(const U32* ptr, XXH_endianess endian, XXH_alignment align)
{
if (align==XXH_unaligned)
return endian==XXH_littleEndian ? A32(ptr) : XXH_swap32(A32(ptr));
else
return endian==XXH_littleEndian ? *ptr : XXH_swap32(*ptr);
}

FORCE_INLINE U32 XXH_readLE32(const U32* ptr, XXH_endianess endian) { return XXH_readLE32_align(ptr, endian, XXH_unaligned); }

FORCE_INLINE U64 XXH_readLE64_align(const U64* ptr, XXH_endianess endian, XXH_alignment align)
{
if (align==XXH_unaligned)
return endian==XXH_littleEndian ? A64(ptr) : XXH_swap64(A64(ptr));
else
return endian==XXH_littleEndian ? *ptr : XXH_swap64(*ptr);
}

FORCE_INLINE U64 XXH_readLE64(const U64* ptr, XXH_endianess endian) { return XXH_readLE64_align(ptr, endian, XXH_unaligned); }


//****************************
// Simple Hash Functions
//****************************
FORCE_INLINE U32 XXH32_endian_align(const void* input, unsigned int len, U32 seed, XXH_endianess endian, XXH_alignment align)
{
const BYTE* p = (const BYTE*)input;
const BYTE* bEnd = p + len;
U32 h32;
#define XXH_get32bits(p) XXH_readLE32_align((const U32*)p, endian, align)

#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
if (p==NULL) { len=0; bEnd=p=(const BYTE*)(size_t)16; }
#endif

if (len>=16)
{
const BYTE* const limit = bEnd - 16;
U32 v1 = seed + PRIME32_1 + PRIME32_2;
U32 v2 = seed + PRIME32_2;
U32 v3 = seed + 0;
U32 v4 = seed - PRIME32_1;

do
{
v1 += XXH_get32bits(p) * PRIME32_2; v1 = XXH_rotl32(v1, 13); v1 *= PRIME32_1; p+=4;
v2 += XXH_get32bits(p) * PRIME32_2; v2 = XXH_rotl32(v2, 13); v2 *= PRIME32_1; p+=4;
v3 += XXH_get32bits(p) * PRIME32_2; v3 = XXH_rotl32(v3, 13); v3 *= PRIME32_1; p+=4;
v4 += XXH_get32bits(p) * PRIME32_2; v4 = XXH_rotl32(v4, 13); v4 *= PRIME32_1; p+=4;
} while (p<=limit);

h32 = XXH_rotl32(v1, 1) + XXH_rotl32(v2, 7) + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
}
else
{
h32  = seed + PRIME32_5;
}

h32 += (U32) len;

while (p<=bEnd-4)
{
h32 += XXH_get32bits(p) * PRIME32_3;
h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
p+=4;
}

while (p<bEnd)
{
h32 += (*p) * PRIME32_5;
h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
p++;
}

h32 ^= h32 >> 15;
h32 *= PRIME32_2;
h32 ^= h32 >> 13;
h32 *= PRIME32_3;
h32 ^= h32 >> 16;

return h32;
}


U32 XXH32(const void* input, unsigned int len, U32 seed)
{
#if 0
// Simple version, good for code maintenance, but unfortunately slow for small inputs
void* state = XXH32_init(seed);
XXH32_update(state, input, len);
return XXH32_digest(state);
#else
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

#  if !defined(XXH_USE_UNALIGNED_ACCESS)
if ((((size_t)input) & 3) == 0)   // Input is aligned, let's leverage the speed advantage
{
if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
else
return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
}
#  endif

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
else
return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
#endif
}

FORCE_INLINE U64 XXH64_endian_align(const void* input, unsigned int len, U64 seed, XXH_endianess endian, XXH_alignment align)
{
const BYTE* p = (const BYTE*)input;
const BYTE* bEnd = p + len;
U64 h64;
#define XXH_get64bits(p) XXH_readLE64_align((const U64*)p, endian, align)

#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
if (p==NULL) { len=0; bEnd=p=(const BYTE*)(size_t)32; }
#endif

if (len>=32)
{
const BYTE* const limit = bEnd - 32;
U64 v1 = seed + PRIME64_1 + PRIME64_2;
U64 v2 = seed + PRIME64_2;
U64 v3 = seed + 0;
U64 v4 = seed - PRIME64_1;

do
{
v1 += XXH_get64bits(p) * PRIME64_2; p+=8; v1 = XXH_rotl64(v1, 31); v1 *= PRIME64_1;
v2 += XXH_get64bits(p) * PRIME64_2; p+=8; v2 = XXH_rotl64(v2, 31); v2 *= PRIME64_1;
v3 += XXH_get64bits(p) * PRIME64_2; p+=8; v3 = XXH_rotl64(v3, 31); v3 *= PRIME64_1;
v4 += XXH_get64bits(p) * PRIME64_2; p+=8; v4 = XXH_rotl64(v4, 31); v4 *= PRIME64_1;
} while (p<=limit);

h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

v1 *= PRIME64_2; v1 = XXH_rotl64(v1, 31); v1 *= PRIME64_1; h64 ^= v1;
h64 = h64 * PRIME64_1 + PRIME64_4;

v2 *= PRIME64_2; v2 = XXH_rotl64(v2, 31); v2 *= PRIME64_1; h64 ^= v2;
h64 = h64 * PRIME64_1 + PRIME64_4;

v3 *= PRIME64_2; v3 = XXH_rotl64(v3, 31); v3 *= PRIME64_1; h64 ^= v3;
h64 = h64 * PRIME64_1 + PRIME64_4;

v4 *= PRIME64_2; v4 = XXH_rotl64(v4, 31); v4 *= PRIME64_1; h64 ^= v4;
h64 = h64 * PRIME64_1 + PRIME64_4;
}
else
{
h64  = seed + PRIME64_5;
}

h64 += (U64) len;

while (p<=bEnd-8)
{
U64 k1 = XXH_get64bits(p);
k1 *= PRIME64_2; k1 = XXH_rotl64(k1,31); k1 *= PRIME64_1; h64 ^= k1;
h64 = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;
p+=8;
}

#if 1

if (p<=bEnd-4)
{
h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1;
h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
p+=4;
}

while (p<bEnd)
{
h64 ^= (*p) * PRIME64_5;
h64 = XXH_rotl64(h64, 11) * PRIME64_1;
p++;
}

#else

if( p<bEnd )
{
// Copy the remaining bytes
U64 k1 = PRIME64_5;
BYTE* _k1 = (BYTE*)&k1;
switch( (size_t)(bEnd-p))  // Yes, I tried multiple ways of doing this memcopy
{
case 7:	*_k1++ = *p++;
case 6:	*_k1++ = *p++;
case 5:	*_k1++ = *p++;
case 4:	*_k1++ = *p++;
case 3:	*_k1++ = *p++;
case 2:	*_k1++ = *p++;
case 1:	*_k1++ = *p++;
}

k1 *= PRIME64_5; k1 = XXH_rotl64(k1,31); k1 *= PRIME64_3; h64 ^= k1;
h64 = XXH_rotl64(h64, 11) * PRIME64_1 + PRIME64_4;
}

#endif

h64 ^= h64 >> 33;
h64 *= PRIME64_2;
h64 ^= h64 >> 29;
h64 *= PRIME64_3;
h64 ^= h64 >> 32;

return h64;
}


unsigned long long XXH64(const void* input, unsigned int len, unsigned long long seed)
{
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

#  if !defined(XXH_USE_UNALIGNED_ACCESS)
if ((((size_t)input) & 7)==0)   // Input is aligned, let's leverage the speed advantage
{
if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
else
return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
}
#  endif

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
else
return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
}

//****************************
// Advanced Hash Functions
//****************************

struct XXH_state32_t
{
U64 total_len;
U32 seed;
U32 v1;
U32 v2;
U32 v3;
U32 v4;
int memsize;
char memory[16];
};

struct XXH_state64_t
{
U64 total_len;
U64 seed;
U64 v1;
U64 v2;
U64 v3;
U64 v4;
int memsize;
char memory[32];
};


int XXH32_sizeofState(void)
{
XXH_STATIC_ASSERT(XXH32_SIZEOFSTATE >= sizeof(struct XXH_state32_t));   // A compilation error here means XXH32_SIZEOFSTATE is not large enough
return sizeof(struct XXH_state32_t);
}

int XXH64_sizeofState(void)
{
XXH_STATIC_ASSERT(XXH64_SIZEOFSTATE >= sizeof(struct XXH_state64_t));   // A compilation error here means XXH64_SIZEOFSTATE is not large enough
return sizeof(struct XXH_state64_t);
}


XXH_errorcode XXH32_resetState(void* state_in, U32 seed)
{
struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;
state->seed = seed;
state->v1 = seed + PRIME32_1 + PRIME32_2;
state->v2 = seed + PRIME32_2;
state->v3 = seed + 0;
state->v4 = seed - PRIME32_1;
state->total_len = 0;
state->memsize = 0;
return XXH_OK;
}

XXH_errorcode XXH64_resetState(void* state_in, unsigned long long seed)
{
struct XXH_state64_t * state = (struct XXH_state64_t *) state_in;
state->seed = seed;
state->v1 = seed + PRIME64_1 + PRIME64_2;
state->v2 = seed + PRIME64_2;
state->v3 = seed + 0;
state->v4 = seed - PRIME64_1;
state->total_len = 0;
state->memsize = 0;
return XXH_OK;
}


void* XXH32_init (U32 seed)
{
void* state = XXH_malloc (sizeof(struct XXH_state32_t));
XXH32_resetState(state, seed);
return state;
}

void* XXH64_init (unsigned long long seed)
{
void* state = XXH_malloc (sizeof(struct XXH_state64_t));
XXH64_resetState(state, seed);
return state;
}


FORCE_INLINE XXH_errorcode XXH32_update_endian (void* state_in, const void* input, int len, XXH_endianess endian)
{
struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;
const BYTE* p = (const BYTE*)input;
const BYTE* const bEnd = p + len;

#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
if (input==NULL) return XXH_ERROR;
#endif

state->total_len += len;

if (state->memsize + len < 16)   // fill in tmp buffer
{
XXH_memcpy(state->memory + state->memsize, input, len);
state->memsize +=  len;
return XXH_OK;
}

if (state->memsize)   // some data left from previous update
{
XXH_memcpy(state->memory + state->memsize, input, 16-state->memsize);
{
const U32* p32 = (const U32*)state->memory;
state->v1 += XXH_readLE32(p32, endian) * PRIME32_2; state->v1 = XXH_rotl32(state->v1, 13); state->v1 *= PRIME32_1; p32++;
state->v2 += XXH_readLE32(p32, endian) * PRIME32_2; state->v2 = XXH_rotl32(state->v2, 13); state->v2 *= PRIME32_1; p32++;
state->v3 += XXH_readLE32(p32, endian) * PRIME32_2; state->v3 = XXH_rotl32(state->v3, 13); state->v3 *= PRIME32_1; p32++;
state->v4 += XXH_readLE32(p32, endian) * PRIME32_2; state->v4 = XXH_rotl32(state->v4, 13); state->v4 *= PRIME32_1; p32++;
}
p += 16-state->memsize;
state->memsize = 0;
}

if (p <= bEnd-16)
{
const BYTE* const limit = bEnd - 16;
U32 v1 = state->v1;
U32 v2 = state->v2;
U32 v3 = state->v3;
U32 v4 = state->v4;

do
{
v1 += XXH_readLE32((const U32*)p, endian) * PRIME32_2; v1 = XXH_rotl32(v1, 13); v1 *= PRIME32_1; p+=4;
v2 += XXH_readLE32((const U32*)p, endian) * PRIME32_2; v2 = XXH_rotl32(v2, 13); v2 *= PRIME32_1; p+=4;
v3 += XXH_readLE32((const U32*)p, endian) * PRIME32_2; v3 = XXH_rotl32(v3, 13); v3 *= PRIME32_1; p+=4;
v4 += XXH_readLE32((const U32*)p, endian) * PRIME32_2; v4 = XXH_rotl32(v4, 13); v4 *= PRIME32_1; p+=4;
} while (p<=limit);

state->v1 = v1;
state->v2 = v2;
state->v3 = v3;
state->v4 = v4;
}

if (p < bEnd)
{
XXH_memcpy(state->memory, p, bEnd-p);
state->memsize = (int)(bEnd-p);
}

return XXH_OK;
}

XXH_errorcode XXH32_update (void* state_in, const void* input, unsigned int len)
{
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH32_update_endian(state_in, input, len, XXH_littleEndian);
else
return XXH32_update_endian(state_in, input, len, XXH_bigEndian);
}



FORCE_INLINE U32 XXH32_intermediateDigest_endian (void* state_in, XXH_endianess endian)
{
struct XXH_state32_t * state = (struct XXH_state32_t *) state_in;
const BYTE * p = (const BYTE*)state->memory;
BYTE* bEnd = (BYTE*)state->memory + state->memsize;
U32 h32;

if (state->total_len >= 16)
{
h32 = XXH_rotl32(state->v1, 1) + XXH_rotl32(state->v2, 7) + XXH_rotl32(state->v3, 12) + XXH_rotl32(state->v4, 18);
}
else
{
h32  = state->seed + PRIME32_5;
}

h32 += (U32) state->total_len;

while (p<=bEnd-4)
{
h32 += XXH_readLE32((const U32*)p, endian) * PRIME32_3;
h32  = XXH_rotl32(h32, 17) * PRIME32_4;
p+=4;
}

while (p<bEnd)
{
h32 += (*p) * PRIME32_5;
h32 = XXH_rotl32(h32, 11) * PRIME32_1;
p++;
}

h32 ^= h32 >> 15;
h32 *= PRIME32_2;
h32 ^= h32 >> 13;
h32 *= PRIME32_3;
h32 ^= h32 >> 16;

return h32;
}


U32 XXH32_intermediateDigest (void* state_in)
{
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH32_intermediateDigest_endian(state_in, XXH_littleEndian);
else
return XXH32_intermediateDigest_endian(state_in, XXH_bigEndian);
}


U32 XXH32_digest (void* state_in)
{
U32 h32 = XXH32_intermediateDigest(state_in);

XXH_free(state_in);

return h32;
}


FORCE_INLINE XXH_errorcode XXH64_update_endian (void* state_in, const void* input, int len, XXH_endianess endian)
{
struct XXH_state64_t * state = (struct XXH_state64_t *) state_in;
const BYTE* p = (const BYTE*)input;
const BYTE* const bEnd = p + len;

#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
if (input==NULL) return XXH_ERROR;
#endif

state->total_len += len;

if (state->memsize + len < 32)   // fill in tmp buffer
{
XXH_memcpy(state->memory + state->memsize, input, len);
state->memsize +=  len;
return XXH_OK;
}

if (state->memsize)   // some data left from previous update
{
XXH_memcpy(state->memory + state->memsize, input, 32-state->memsize);
{
const U64* p64 = (const U64*)state->memory;
state->v1 += XXH_readLE64(p64, endian) * PRIME64_2; state->v1 = XXH_rotl64(state->v1, 31); state->v1 *= PRIME64_1; p64++;
state->v2 += XXH_readLE64(p64, endian) * PRIME64_2; state->v2 = XXH_rotl64(state->v2, 31); state->v2 *= PRIME64_1; p64++;
state->v3 += XXH_readLE64(p64, endian) * PRIME64_2; state->v3 = XXH_rotl64(state->v3, 31); state->v3 *= PRIME64_1; p64++;
state->v4 += XXH_readLE64(p64, endian) * PRIME64_2; state->v4 = XXH_rotl64(state->v4, 31); state->v4 *= PRIME64_1; p64++;
}
p += 32-state->memsize;
state->memsize = 0;
}

if (p <= bEnd-32)
{
const BYTE* const limit = bEnd - 32;
U64 v1 = state->v1;
U64 v2 = state->v2;
U64 v3 = state->v3;
U64 v4 = state->v4;

do
{
v1 += XXH_readLE64((const U64*)p, endian) * PRIME64_2; v1 = XXH_rotl64(v1, 31); v1 *= PRIME64_1; p+=8;
v2 += XXH_readLE64((const U64*)p, endian) * PRIME64_2; v2 = XXH_rotl64(v2, 31); v2 *= PRIME64_1; p+=8;
v3 += XXH_readLE64((const U64*)p, endian) * PRIME64_2; v3 = XXH_rotl64(v3, 31); v3 *= PRIME64_1; p+=8;
v4 += XXH_readLE64((const U64*)p, endian) * PRIME64_2; v4 = XXH_rotl64(v4, 31); v4 *= PRIME64_1; p+=8;
} while (p<=limit);

state->v1 = v1;
state->v2 = v2;
state->v3 = v3;
state->v4 = v4;
}

if (p < bEnd)
{
XXH_memcpy(state->memory, p, bEnd-p);
state->memsize = (int)(bEnd-p);
}

return XXH_OK;
}

XXH_errorcode XXH64_update (void* state_in, const void* input, unsigned int len)
{
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
else
return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
}



FORCE_INLINE U64 XXH64_intermediateDigest_endian (void* state_in, XXH_endianess endian)
{
struct XXH_state64_t * state = (struct XXH_state64_t *) state_in;
const BYTE * p = (const BYTE*)state->memory;
BYTE* bEnd = (BYTE*)state->memory + state->memsize;
U64 h64;

if (state->total_len >= 32)
{
U64 v1 = state->v1;
U64 v2 = state->v2;
U64 v3 = state->v3;
U64 v4 = state->v4;

h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);

v1 *= PRIME64_2; v1 = XXH_rotl64(v1, 31); v1 *= PRIME64_1; h64 ^= v1;
h64 = h64*PRIME64_1 + PRIME64_4;

v2 *= PRIME64_2; v2 = XXH_rotl64(v2, 31); v2 *= PRIME64_1; h64 ^= v2;
h64 = h64*PRIME64_1 + PRIME64_4;

v3 *= PRIME64_2; v3 = XXH_rotl64(v3, 31); v3 *= PRIME64_1; h64 ^= v3;
h64 = h64*PRIME64_1 + PRIME64_4;

v4 *= PRIME64_2; v4 = XXH_rotl64(v4, 31); v4 *= PRIME64_1; h64 ^= v4;
h64 = h64*PRIME64_1 + PRIME64_4;
}
else
{
h64  = state->seed + PRIME64_5;
}

h64 += (U64) state->total_len;

while (p<=bEnd-8)
{
U64 k1 = XXH_readLE64((const U64*)p, endian);
k1 *= PRIME64_2; k1 = XXH_rotl64(k1,31); k1 *= PRIME64_1; h64 ^= k1;
h64 = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;
p+=8;
}

if (p<=bEnd-4)
{
h64 ^= (U64)(XXH_readLE32((const U32*)p, endian)) * PRIME64_1;
h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
p+=4;
}

while (p<bEnd)
{
h64 ^= (*p) * PRIME64_5;
h64 = XXH_rotl64(h64, 11) * PRIME64_1;
p++;
}

h64 ^= h64 >> 33;
h64 *= PRIME64_2;
h64 ^= h64 >> 29;
h64 *= PRIME64_3;
h64 ^= h64 >> 32;

return h64;
}


unsigned long long XXH64_intermediateDigest (void* state_in)
{
XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;

if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
return XXH64_intermediateDigest_endian(state_in, XXH_littleEndian);
else
return XXH64_intermediateDigest_endian(state_in, XXH_bigEndian);
}


unsigned long long XXH64_digest (void* state_in)
{
U64 h64 = XXH64_intermediateDigest(state_in);

XXH_free(state_in);

return h64;
}



#if defined(__APPLE__)

static void* AppleGLGetProcAddress (const GLubyte *name)
{
static const struct mach_header* image = NULL;
NSSymbol symbol;
char* symbolName;
if (NULL == image)
{
image = NSAddImage("/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL", NSADDIMAGE_OPTION_RETURN_ON_ERROR);
}
/* prepend a '_' for the Unix C symbol mangling convention */
symbolName = malloc(strlen((const char*)name) + 2);
strcpy(symbolName+1, (const char*)name);
symbolName[0] = '_';
symbol = NULL;
/* if (NSIsSymbolNameDefined(symbolName))
symbol = NSLookupAndBindSymbol(symbolName); */
symbol = image ? NSLookupSymbolInImage(image, symbolName, NSLOOKUPSYMBOLINIMAGE_OPTION_BIND | NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR) : NULL;
free(symbolName);
return symbol ? NSAddressOfSymbol(symbol) : NULL;
}
#endif /* __APPLE__ */

#if defined(__sgi) || defined (__sun)

static void* SunGetProcAddress (const GLubyte* name)
{
static void* h = NULL;
static void* gpa;

if (h == NULL)
{
if ((h = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL)) == NULL) return NULL;
gpa = dlsym(h, "glXGetProcAddress");
}

if (gpa != NULL)
return ((void*(*)(const GLubyte*))gpa)(name);
else
return dlsym(h, (const char*)name);
}
#endif /* __sgi || __sun */

#if defined(_WIN32)

#ifdef _MSC_VER
#pragma warning(disable: 4055)
#pragma warning(disable: 4054)
#endif

static int TestPointer(const PROC pTest)
{
ptrdiff_t iTest;
if(!pTest) return 0;
iTest = (ptrdiff_t)pTest;

if(iTest == 1 || iTest == 2 || iTest == 3 || iTest == -1) return 0;

return 1;
}

static PROC WinGetProcAddress(const char *name)
{
HMODULE glMod = NULL;
PROC pFunc = wglGetProcAddress((LPCSTR)name);
if(TestPointer(pFunc))
{
return pFunc;
}
glMod = GetModuleHandleA("OpenGL32.dll");
return (PROC)GetProcAddress(glMod, (LPCSTR)name);
}

#define IntGetProcAddress(name) WinGetProcAddress(name)
#else
#if defined(__APPLE__)
#define IntGetProcAddress(name) AppleGLGetProcAddress(name)
#else
#if defined(__sgi) || defined(__sun)
#define IntGetProcAddress(name) SunGetProcAddress(name)
#else /* GLX */

#define IntGetProcAddress(name) (*glXGetProcAddressARB)((const GLubyte*)name)
#endif
#endif
#endif

int ogl_ext_ARB_framebuffer_sRGB = ogl_LOAD_FAILED;
int ogl_ext_EXT_framebuffer_sRGB = ogl_LOAD_FAILED;

void (CODEGEN_FUNCPTR *_ptrc_glBlendFunc)(GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClear)(GLbitfield) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearColor)(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearDepth)(GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearStencil)(GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glColorMask)(GLboolean, GLboolean, GLboolean, GLboolean) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCullFace)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDepthFunc)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDepthMask)(GLboolean) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDepthRange)(GLdouble, GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDisable)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawBuffer)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEnable)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFinish)() = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFlush)() = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFrontFace)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBooleanv)(GLenum, GLboolean *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetDoublev)(GLenum, GLdouble *) = NULL;
GLenum (CODEGEN_FUNCPTR *_ptrc_glGetError)() = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetFloatv)(GLenum, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetIntegerv)(GLenum, GLint *) = NULL;
const GLubyte * (CODEGEN_FUNCPTR *_ptrc_glGetString)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexImage)(GLenum, GLint, GLenum, GLenum, GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexLevelParameterfv)(GLenum, GLint, GLenum, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexLevelParameteriv)(GLenum, GLint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterfv)(GLenum, GLenum, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameteriv)(GLenum, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glHint)(GLenum, GLenum) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsEnabled)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glLineWidth)(GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glLogicOp)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPixelStoref)(GLenum, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPixelStorei)(GLenum, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPointSize)(GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPolygonMode)(GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glReadBuffer)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glReadPixels)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glScissor)(GLint, GLint, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilFunc)(GLenum, GLint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilMask)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilOp)(GLenum, GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexImage1D)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexImage2D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameterf)(GLenum, GLenum, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameterfv)(GLenum, GLenum, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameteri)(GLenum, GLenum, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameteriv)(GLenum, GLenum, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glViewport)(GLint, GLint, GLsizei, GLsizei) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBindTexture)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCopyTexImage1D)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCopyTexImage2D)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage1D)(GLenum, GLint, GLint, GLint, GLint, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage2D)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteTextures)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawArrays)(GLenum, GLint, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawElements)(GLenum, GLsizei, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenTextures)(GLsizei, GLuint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsTexture)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPolygonOffset)(GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage1D)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage2D)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBlendColor)(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBlendEquation)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCopyTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawRangeElements)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glActiveTexture)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage1D)(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage2D)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexImage3D)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage1D)(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage2D)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompressedTexSubImage3D)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetCompressedTexImage)(GLenum, GLint, GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSampleCoverage)(GLfloat, GLboolean) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBlendFuncSeparate)(GLenum, GLenum, GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawArrays)(GLenum, const GLint *, const GLsizei *, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawElements)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPointParameterf)(GLenum, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPointParameterfv)(GLenum, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPointParameteri)(GLenum, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPointParameteriv)(GLenum, const GLint *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBeginQuery)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindBuffer)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBufferData)(GLenum, GLsizeiptr, const GLvoid *, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBufferSubData)(GLenum, GLintptr, GLsizeiptr, const GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteBuffers)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteQueries)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEndQuery)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenBuffers)(GLsizei, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenQueries)(GLsizei, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBufferParameteriv)(GLenum, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBufferPointerv)(GLenum, GLenum, GLvoid **) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBufferSubData)(GLenum, GLintptr, GLsizeiptr, GLvoid *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectiv)(GLuint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectuiv)(GLuint, GLenum, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetQueryiv)(GLenum, GLenum, GLint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsBuffer)(GLuint) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsQuery)(GLuint) = NULL;
void * (CODEGEN_FUNCPTR *_ptrc_glMapBuffer)(GLenum, GLenum) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glUnmapBuffer)(GLenum) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glAttachShader)(GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindAttribLocation)(GLuint, GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBlendEquationSeparate)(GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glCompileShader)(GLuint) = NULL;
GLuint (CODEGEN_FUNCPTR *_ptrc_glCreateProgram)() = NULL;
GLuint (CODEGEN_FUNCPTR *_ptrc_glCreateShader)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteProgram)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteShader)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDetachShader)(GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDisableVertexAttribArray)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawBuffers)(GLsizei, const GLenum *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEnableVertexAttribArray)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveAttrib)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniform)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetAttachedShaders)(GLuint, GLsizei, GLsizei *, GLuint *) = NULL;
GLint (CODEGEN_FUNCPTR *_ptrc_glGetAttribLocation)(GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetProgramInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetProgramiv)(GLuint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetShaderInfoLog)(GLuint, GLsizei, GLsizei *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetShaderSource)(GLuint, GLsizei, GLsizei *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetShaderiv)(GLuint, GLenum, GLint *) = NULL;
GLint (CODEGEN_FUNCPTR *_ptrc_glGetUniformLocation)(GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetUniformfv)(GLuint, GLint, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetUniformiv)(GLuint, GLint, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribPointerv)(GLuint, GLenum, GLvoid **) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribdv)(GLuint, GLenum, GLdouble *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribfv)(GLuint, GLenum, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribiv)(GLuint, GLenum, GLint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsProgram)(GLuint) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsShader)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glLinkProgram)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glShaderSource)(GLuint, GLsizei, const GLchar *const*, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilFuncSeparate)(GLenum, GLenum, GLint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilMaskSeparate)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glStencilOpSeparate)(GLenum, GLenum, GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1f)(GLint, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1fv)(GLint, GLsizei, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1i)(GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1iv)(GLint, GLsizei, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2f)(GLint, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2fv)(GLint, GLsizei, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2i)(GLint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2iv)(GLint, GLsizei, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3f)(GLint, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3fv)(GLint, GLsizei, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3i)(GLint, GLint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3iv)(GLint, GLsizei, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4f)(GLint, GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4fv)(GLint, GLsizei, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4i)(GLint, GLint, GLint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4iv)(GLint, GLsizei, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUseProgram)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glValidateProgram)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1d)(GLuint, GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1dv)(GLuint, const GLdouble *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1f)(GLuint, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1fv)(GLuint, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1s)(GLuint, GLshort) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib1sv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2d)(GLuint, GLdouble, GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2dv)(GLuint, const GLdouble *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2f)(GLuint, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2fv)(GLuint, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2s)(GLuint, GLshort, GLshort) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib2sv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3d)(GLuint, GLdouble, GLdouble, GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3dv)(GLuint, const GLdouble *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3f)(GLuint, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3fv)(GLuint, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3s)(GLuint, GLshort, GLshort, GLshort) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib3sv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nbv)(GLuint, const GLbyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Niv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nsv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nub)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nubv)(GLuint, const GLubyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nuiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4Nusv)(GLuint, const GLushort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4bv)(GLuint, const GLbyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4d)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4dv)(GLuint, const GLdouble *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4f)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4fv)(GLuint, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4iv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4s)(GLuint, GLshort, GLshort, GLshort, GLshort) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4sv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4ubv)(GLuint, const GLubyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4uiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttrib4usv)(GLuint, const GLushort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribPointer)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2x3fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix2x4fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3x2fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix3x4fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4x2fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformMatrix4x3fv)(GLint, GLsizei, GLboolean, const GLfloat *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBeginConditionalRender)(GLuint, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBeginTransformFeedback)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindBufferBase)(GLenum, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindBufferRange)(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindFragDataLocation)(GLuint, GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindFramebuffer)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindRenderbuffer)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindVertexArray)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBlitFramebuffer)(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum) = NULL;
GLenum (CODEGEN_FUNCPTR *_ptrc_glCheckFramebufferStatus)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClampColor)(GLenum, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearBufferfi)(GLenum, GLint, GLfloat, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearBufferfv)(GLenum, GLint, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearBufferiv)(GLenum, GLint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glClearBufferuiv)(GLenum, GLint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glColorMaski)(GLuint, GLboolean, GLboolean, GLboolean, GLboolean) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteFramebuffers)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteRenderbuffers)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteVertexArrays)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDisablei)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEnablei)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEndConditionalRender)() = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glEndTransformFeedback)() = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFlushMappedBufferRange)(GLenum, GLintptr, GLsizeiptr) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferRenderbuffer)(GLenum, GLenum, GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture1D)(GLenum, GLenum, GLenum, GLuint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture2D)(GLenum, GLenum, GLenum, GLuint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture3D)(GLenum, GLenum, GLenum, GLuint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTextureLayer)(GLenum, GLenum, GLuint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenFramebuffers)(GLsizei, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenRenderbuffers)(GLsizei, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenVertexArrays)(GLsizei, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenerateMipmap)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBooleani_v)(GLenum, GLuint, GLboolean *) = NULL;
GLint (CODEGEN_FUNCPTR *_ptrc_glGetFragDataLocation)(GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetFramebufferAttachmentParameteriv)(GLenum, GLenum, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetIntegeri_v)(GLenum, GLuint, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetRenderbufferParameteriv)(GLenum, GLenum, GLint *) = NULL;
const GLubyte * (CODEGEN_FUNCPTR *_ptrc_glGetStringi)(GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterIiv)(GLenum, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTexParameterIuiv)(GLenum, GLenum, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetTransformFeedbackVarying)(GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetUniformuiv)(GLuint, GLint, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribIiv)(GLuint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetVertexAttribIuiv)(GLuint, GLenum, GLuint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsEnabledi)(GLenum, GLuint) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsFramebuffer)(GLuint) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsRenderbuffer)(GLuint) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsVertexArray)(GLuint) = NULL;
void * (CODEGEN_FUNCPTR *_ptrc_glMapBufferRange)(GLenum, GLintptr, GLsizeiptr, GLbitfield) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glRenderbufferStorage)(GLenum, GLenum, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glRenderbufferStorageMultisample)(GLenum, GLsizei, GLenum, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameterIiv)(GLenum, GLenum, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexParameterIuiv)(GLenum, GLenum, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTransformFeedbackVaryings)(GLuint, GLsizei, const GLchar *const*, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1ui)(GLint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform1uiv)(GLint, GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2ui)(GLint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform2uiv)(GLint, GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3ui)(GLint, GLuint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform3uiv)(GLint, GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4ui)(GLint, GLuint, GLuint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniform4uiv)(GLint, GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1i)(GLuint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1iv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1ui)(GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI1uiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2i)(GLuint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2iv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2ui)(GLuint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI2uiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3i)(GLuint, GLint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3iv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3ui)(GLuint, GLuint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI3uiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4bv)(GLuint, const GLbyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4i)(GLuint, GLint, GLint, GLint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4iv)(GLuint, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4sv)(GLuint, const GLshort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4ubv)(GLuint, const GLubyte *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4ui)(GLuint, GLuint, GLuint, GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4uiv)(GLuint, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribI4usv)(GLuint, const GLushort *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribIPointer)(GLuint, GLint, GLenum, GLsizei, const GLvoid *) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glCopyBufferSubData)(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawArraysInstanced)(GLenum, GLint, GLsizei, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsInstanced)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformBlockName)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformBlockiv)(GLuint, GLuint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformName)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetActiveUniformsiv)(GLuint, GLsizei, const GLuint *, GLenum, GLint *) = NULL;
GLuint (CODEGEN_FUNCPTR *_ptrc_glGetUniformBlockIndex)(GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetUniformIndices)(GLuint, GLsizei, const GLchar *const*, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glPrimitiveRestartIndex)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexBuffer)(GLenum, GLenum, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glUniformBlockBinding)(GLuint, GLuint, GLuint) = NULL;

GLenum (CODEGEN_FUNCPTR *_ptrc_glClientWaitSync)(GLsync, GLbitfield, GLuint64) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteSync)(GLsync) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsBaseVertex)(GLenum, GLsizei, GLenum, const GLvoid *, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawElementsInstancedBaseVertex)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDrawRangeElementsBaseVertex)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *, GLint) = NULL;
GLsync (CODEGEN_FUNCPTR *_ptrc_glFenceSync)(GLenum, GLbitfield) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glFramebufferTexture)(GLenum, GLenum, GLuint, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetBufferParameteri64v)(GLenum, GLenum, GLint64 *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetInteger64i_v)(GLenum, GLuint, GLint64 *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetInteger64v)(GLenum, GLint64 *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetMultisamplefv)(GLenum, GLuint, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetSynciv)(GLsync, GLenum, GLsizei, GLsizei *, GLint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsSync)(GLsync) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glMultiDrawElementsBaseVertex)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glProvokingVertex)(GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSampleMaski)(GLuint, GLbitfield) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexImage2DMultisample)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glTexImage3DMultisample)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glWaitSync)(GLsync, GLbitfield, GLuint64) = NULL;

void (CODEGEN_FUNCPTR *_ptrc_glBindFragDataLocationIndexed)(GLuint, GLuint, GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glBindSampler)(GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glDeleteSamplers)(GLsizei, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGenSamplers)(GLsizei, GLuint *) = NULL;
GLint (CODEGEN_FUNCPTR *_ptrc_glGetFragDataIndex)(GLuint, const GLchar *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjecti64v)(GLuint, GLenum, GLint64 *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetQueryObjectui64v)(GLuint, GLenum, GLuint64 *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterIiv)(GLuint, GLenum, GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterIuiv)(GLuint, GLenum, GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameterfv)(GLuint, GLenum, GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glGetSamplerParameteriv)(GLuint, GLenum, GLint *) = NULL;
GLboolean (CODEGEN_FUNCPTR *_ptrc_glIsSampler)(GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glQueryCounter)(GLuint, GLenum) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterIiv)(GLuint, GLenum, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterIuiv)(GLuint, GLenum, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterf)(GLuint, GLenum, GLfloat) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameterfv)(GLuint, GLenum, const GLfloat *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameteri)(GLuint, GLenum, GLint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glSamplerParameteriv)(GLuint, GLenum, const GLint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribDivisor)(GLuint, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP1ui)(GLuint, GLenum, GLboolean, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP1uiv)(GLuint, GLenum, GLboolean, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP2ui)(GLuint, GLenum, GLboolean, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP2uiv)(GLuint, GLenum, GLboolean, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP3ui)(GLuint, GLenum, GLboolean, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP3uiv)(GLuint, GLenum, GLboolean, const GLuint *) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP4ui)(GLuint, GLenum, GLboolean, GLuint) = NULL;
void (CODEGEN_FUNCPTR *_ptrc_glVertexAttribP4uiv)(GLuint, GLenum, GLboolean, const GLuint *) = NULL;

static int Load_Version_3_3()
{
int numFailed = 0;
_ptrc_glBlendFunc = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glBlendFunc");
if(!_ptrc_glBlendFunc) numFailed++;
_ptrc_glClear = (void (CODEGEN_FUNCPTR *)(GLbitfield))IntGetProcAddress("glClear");
if(!_ptrc_glClear) numFailed++;
_ptrc_glClearColor = (void (CODEGEN_FUNCPTR *)(GLfloat, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glClearColor");
if(!_ptrc_glClearColor) numFailed++;
_ptrc_glClearDepth = (void (CODEGEN_FUNCPTR *)(GLdouble))IntGetProcAddress("glClearDepth");
if(!_ptrc_glClearDepth) numFailed++;
_ptrc_glClearStencil = (void (CODEGEN_FUNCPTR *)(GLint))IntGetProcAddress("glClearStencil");
if(!_ptrc_glClearStencil) numFailed++;
_ptrc_glColorMask = (void (CODEGEN_FUNCPTR *)(GLboolean, GLboolean, GLboolean, GLboolean))IntGetProcAddress("glColorMask");
if(!_ptrc_glColorMask) numFailed++;
_ptrc_glCullFace = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glCullFace");
if(!_ptrc_glCullFace) numFailed++;
_ptrc_glDepthFunc = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glDepthFunc");
if(!_ptrc_glDepthFunc) numFailed++;
_ptrc_glDepthMask = (void (CODEGEN_FUNCPTR *)(GLboolean))IntGetProcAddress("glDepthMask");
if(!_ptrc_glDepthMask) numFailed++;
_ptrc_glDepthRange = (void (CODEGEN_FUNCPTR *)(GLdouble, GLdouble))IntGetProcAddress("glDepthRange");
if(!_ptrc_glDepthRange) numFailed++;
_ptrc_glDisable = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glDisable");
if(!_ptrc_glDisable) numFailed++;
_ptrc_glDrawBuffer = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glDrawBuffer");
if(!_ptrc_glDrawBuffer) numFailed++;
_ptrc_glEnable = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glEnable");
if(!_ptrc_glEnable) numFailed++;
_ptrc_glFinish = (void (CODEGEN_FUNCPTR *)())IntGetProcAddress("glFinish");
if(!_ptrc_glFinish) numFailed++;
_ptrc_glFlush = (void (CODEGEN_FUNCPTR *)())IntGetProcAddress("glFlush");
if(!_ptrc_glFlush) numFailed++;
_ptrc_glFrontFace = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glFrontFace");
if(!_ptrc_glFrontFace) numFailed++;
_ptrc_glGetBooleanv = (void (CODEGEN_FUNCPTR *)(GLenum, GLboolean *))IntGetProcAddress("glGetBooleanv");
if(!_ptrc_glGetBooleanv) numFailed++;
_ptrc_glGetDoublev = (void (CODEGEN_FUNCPTR *)(GLenum, GLdouble *))IntGetProcAddress("glGetDoublev");
if(!_ptrc_glGetDoublev) numFailed++;
_ptrc_glGetError = (GLenum (CODEGEN_FUNCPTR *)())IntGetProcAddress("glGetError");
if(!_ptrc_glGetError) numFailed++;
_ptrc_glGetFloatv = (void (CODEGEN_FUNCPTR *)(GLenum, GLfloat *))IntGetProcAddress("glGetFloatv");
if(!_ptrc_glGetFloatv) numFailed++;
_ptrc_glGetIntegerv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint *))IntGetProcAddress("glGetIntegerv");
if(!_ptrc_glGetIntegerv) numFailed++;
_ptrc_glGetString = (const GLubyte * (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glGetString");
if(!_ptrc_glGetString) numFailed++;
_ptrc_glGetTexImage = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLenum, GLvoid *))IntGetProcAddress("glGetTexImage");
if(!_ptrc_glGetTexImage) numFailed++;
_ptrc_glGetTexLevelParameterfv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLfloat *))IntGetProcAddress("glGetTexLevelParameterfv");
if(!_ptrc_glGetTexLevelParameterfv) numFailed++;
_ptrc_glGetTexLevelParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLint *))IntGetProcAddress("glGetTexLevelParameteriv");
if(!_ptrc_glGetTexLevelParameteriv) numFailed++;
_ptrc_glGetTexParameterfv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLfloat *))IntGetProcAddress("glGetTexParameterfv");
if(!_ptrc_glGetTexParameterfv) numFailed++;
_ptrc_glGetTexParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint *))IntGetProcAddress("glGetTexParameteriv");
if(!_ptrc_glGetTexParameteriv) numFailed++;
_ptrc_glHint = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glHint");
if(!_ptrc_glHint) numFailed++;
_ptrc_glIsEnabled = (GLboolean (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glIsEnabled");
if(!_ptrc_glIsEnabled) numFailed++;
_ptrc_glLineWidth = (void (CODEGEN_FUNCPTR *)(GLfloat))IntGetProcAddress("glLineWidth");
if(!_ptrc_glLineWidth) numFailed++;
_ptrc_glLogicOp = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glLogicOp");
if(!_ptrc_glLogicOp) numFailed++;
_ptrc_glPixelStoref = (void (CODEGEN_FUNCPTR *)(GLenum, GLfloat))IntGetProcAddress("glPixelStoref");
if(!_ptrc_glPixelStoref) numFailed++;
_ptrc_glPixelStorei = (void (CODEGEN_FUNCPTR *)(GLenum, GLint))IntGetProcAddress("glPixelStorei");
if(!_ptrc_glPixelStorei) numFailed++;
_ptrc_glPointSize = (void (CODEGEN_FUNCPTR *)(GLfloat))IntGetProcAddress("glPointSize");
if(!_ptrc_glPointSize) numFailed++;
_ptrc_glPolygonMode = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glPolygonMode");
if(!_ptrc_glPolygonMode) numFailed++;
_ptrc_glReadBuffer = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glReadBuffer");
if(!_ptrc_glReadBuffer) numFailed++;
_ptrc_glReadPixels = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *))IntGetProcAddress("glReadPixels");
if(!_ptrc_glReadPixels) numFailed++;
_ptrc_glScissor = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLsizei, GLsizei))IntGetProcAddress("glScissor");
if(!_ptrc_glScissor) numFailed++;
_ptrc_glStencilFunc = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLuint))IntGetProcAddress("glStencilFunc");
if(!_ptrc_glStencilFunc) numFailed++;
_ptrc_glStencilMask = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glStencilMask");
if(!_ptrc_glStencilMask) numFailed++;
_ptrc_glStencilOp = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum))IntGetProcAddress("glStencilOp");
if(!_ptrc_glStencilOp) numFailed++;
_ptrc_glTexImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexImage1D");
if(!_ptrc_glTexImage1D) numFailed++;
_ptrc_glTexImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexImage2D");
if(!_ptrc_glTexImage2D) numFailed++;
_ptrc_glTexParameterf = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLfloat))IntGetProcAddress("glTexParameterf");
if(!_ptrc_glTexParameterf) numFailed++;
_ptrc_glTexParameterfv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, const GLfloat *))IntGetProcAddress("glTexParameterfv");
if(!_ptrc_glTexParameterfv) numFailed++;
_ptrc_glTexParameteri = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint))IntGetProcAddress("glTexParameteri");
if(!_ptrc_glTexParameteri) numFailed++;
_ptrc_glTexParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, const GLint *))IntGetProcAddress("glTexParameteriv");
if(!_ptrc_glTexParameteriv) numFailed++;
_ptrc_glViewport = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLsizei, GLsizei))IntGetProcAddress("glViewport");
if(!_ptrc_glViewport) numFailed++;
_ptrc_glBindTexture = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glBindTexture");
if(!_ptrc_glBindTexture) numFailed++;
_ptrc_glCopyTexImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint))IntGetProcAddress("glCopyTexImage1D");
if(!_ptrc_glCopyTexImage1D) numFailed++;
_ptrc_glCopyTexImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint))IntGetProcAddress("glCopyTexImage2D");
if(!_ptrc_glCopyTexImage2D) numFailed++;
_ptrc_glCopyTexSubImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLint, GLsizei))IntGetProcAddress("glCopyTexSubImage1D");
if(!_ptrc_glCopyTexSubImage1D) numFailed++;
_ptrc_glCopyTexSubImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei))IntGetProcAddress("glCopyTexSubImage2D");
if(!_ptrc_glCopyTexSubImage2D) numFailed++;
_ptrc_glDeleteTextures = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteTextures");
if(!_ptrc_glDeleteTextures) numFailed++;
_ptrc_glDrawArrays = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLsizei))IntGetProcAddress("glDrawArrays");
if(!_ptrc_glDrawArrays) numFailed++;
_ptrc_glDrawElements = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLenum, const GLvoid *))IntGetProcAddress("glDrawElements");
if(!_ptrc_glDrawElements) numFailed++;
_ptrc_glGenTextures = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenTextures");
if(!_ptrc_glGenTextures) numFailed++;
_ptrc_glIsTexture = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsTexture");
if(!_ptrc_glIsTexture) numFailed++;
_ptrc_glPolygonOffset = (void (CODEGEN_FUNCPTR *)(GLfloat, GLfloat))IntGetProcAddress("glPolygonOffset");
if(!_ptrc_glPolygonOffset) numFailed++;
_ptrc_glTexSubImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexSubImage1D");
if(!_ptrc_glTexSubImage1D) numFailed++;
_ptrc_glTexSubImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexSubImage2D");
if(!_ptrc_glTexSubImage2D) numFailed++;
_ptrc_glBlendColor = (void (CODEGEN_FUNCPTR *)(GLfloat, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glBlendColor");
if(!_ptrc_glBlendColor) numFailed++;
_ptrc_glBlendEquation = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glBlendEquation");
if(!_ptrc_glBlendEquation) numFailed++;
_ptrc_glCopyTexSubImage3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei))IntGetProcAddress("glCopyTexSubImage3D");
if(!_ptrc_glCopyTexSubImage3D) numFailed++;
_ptrc_glDrawRangeElements = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *))IntGetProcAddress("glDrawRangeElements");
if(!_ptrc_glDrawRangeElements) numFailed++;
_ptrc_glTexImage3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexImage3D");
if(!_ptrc_glTexImage3D) numFailed++;
_ptrc_glTexSubImage3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))IntGetProcAddress("glTexSubImage3D");
if(!_ptrc_glTexSubImage3D) numFailed++;
_ptrc_glActiveTexture = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glActiveTexture");
if(!_ptrc_glActiveTexture) numFailed++;
_ptrc_glCompressedTexImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLsizei, GLint, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexImage1D");
if(!_ptrc_glCompressedTexImage1D) numFailed++;
_ptrc_glCompressedTexImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexImage2D");
if(!_ptrc_glCompressedTexImage2D) numFailed++;
_ptrc_glCompressedTexImage3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexImage3D");
if(!_ptrc_glCompressedTexImage3D) numFailed++;
_ptrc_glCompressedTexSubImage1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLsizei, GLenum, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexSubImage1D");
if(!_ptrc_glCompressedTexSubImage1D) numFailed++;
_ptrc_glCompressedTexSubImage2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexSubImage2D");
if(!_ptrc_glCompressedTexSubImage2D) numFailed++;
_ptrc_glCompressedTexSubImage3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLsizei, const GLvoid *))IntGetProcAddress("glCompressedTexSubImage3D");
if(!_ptrc_glCompressedTexSubImage3D) numFailed++;
_ptrc_glGetCompressedTexImage = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLvoid *))IntGetProcAddress("glGetCompressedTexImage");
if(!_ptrc_glGetCompressedTexImage) numFailed++;
_ptrc_glSampleCoverage = (void (CODEGEN_FUNCPTR *)(GLfloat, GLboolean))IntGetProcAddress("glSampleCoverage");
if(!_ptrc_glSampleCoverage) numFailed++;
_ptrc_glBlendFuncSeparate = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLenum))IntGetProcAddress("glBlendFuncSeparate");
if(!_ptrc_glBlendFuncSeparate) numFailed++;
_ptrc_glMultiDrawArrays = (void (CODEGEN_FUNCPTR *)(GLenum, const GLint *, const GLsizei *, GLsizei))IntGetProcAddress("glMultiDrawArrays");
if(!_ptrc_glMultiDrawArrays) numFailed++;
_ptrc_glMultiDrawElements = (void (CODEGEN_FUNCPTR *)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei))IntGetProcAddress("glMultiDrawElements");
if(!_ptrc_glMultiDrawElements) numFailed++;
_ptrc_glPointParameterf = (void (CODEGEN_FUNCPTR *)(GLenum, GLfloat))IntGetProcAddress("glPointParameterf");
if(!_ptrc_glPointParameterf) numFailed++;
_ptrc_glPointParameterfv = (void (CODEGEN_FUNCPTR *)(GLenum, const GLfloat *))IntGetProcAddress("glPointParameterfv");
if(!_ptrc_glPointParameterfv) numFailed++;
_ptrc_glPointParameteri = (void (CODEGEN_FUNCPTR *)(GLenum, GLint))IntGetProcAddress("glPointParameteri");
if(!_ptrc_glPointParameteri) numFailed++;
_ptrc_glPointParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, const GLint *))IntGetProcAddress("glPointParameteriv");
if(!_ptrc_glPointParameteriv) numFailed++;
_ptrc_glBeginQuery = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glBeginQuery");
if(!_ptrc_glBeginQuery) numFailed++;
_ptrc_glBindBuffer = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glBindBuffer");
if(!_ptrc_glBindBuffer) numFailed++;
_ptrc_glBufferData = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizeiptr, const GLvoid *, GLenum))IntGetProcAddress("glBufferData");
if(!_ptrc_glBufferData) numFailed++;
_ptrc_glBufferSubData = (void (CODEGEN_FUNCPTR *)(GLenum, GLintptr, GLsizeiptr, const GLvoid *))IntGetProcAddress("glBufferSubData");
if(!_ptrc_glBufferSubData) numFailed++;
_ptrc_glDeleteBuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteBuffers");
if(!_ptrc_glDeleteBuffers) numFailed++;
_ptrc_glDeleteQueries = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteQueries");
if(!_ptrc_glDeleteQueries) numFailed++;
_ptrc_glEndQuery = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glEndQuery");
if(!_ptrc_glEndQuery) numFailed++;
_ptrc_glGenBuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenBuffers");
if(!_ptrc_glGenBuffers) numFailed++;
_ptrc_glGenQueries = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenQueries");
if(!_ptrc_glGenQueries) numFailed++;
_ptrc_glGetBufferParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint *))IntGetProcAddress("glGetBufferParameteriv");
if(!_ptrc_glGetBufferParameteriv) numFailed++;
_ptrc_glGetBufferPointerv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLvoid **))IntGetProcAddress("glGetBufferPointerv");
if(!_ptrc_glGetBufferPointerv) numFailed++;
_ptrc_glGetBufferSubData = (void (CODEGEN_FUNCPTR *)(GLenum, GLintptr, GLsizeiptr, GLvoid *))IntGetProcAddress("glGetBufferSubData");
if(!_ptrc_glGetBufferSubData) numFailed++;
_ptrc_glGetQueryObjectiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetQueryObjectiv");
if(!_ptrc_glGetQueryObjectiv) numFailed++;
_ptrc_glGetQueryObjectuiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLuint *))IntGetProcAddress("glGetQueryObjectuiv");
if(!_ptrc_glGetQueryObjectuiv) numFailed++;
_ptrc_glGetQueryiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint *))IntGetProcAddress("glGetQueryiv");
if(!_ptrc_glGetQueryiv) numFailed++;
_ptrc_glIsBuffer = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsBuffer");
if(!_ptrc_glIsBuffer) numFailed++;
_ptrc_glIsQuery = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsQuery");
if(!_ptrc_glIsQuery) numFailed++;
_ptrc_glMapBuffer = (void * (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glMapBuffer");
if(!_ptrc_glMapBuffer) numFailed++;
_ptrc_glUnmapBuffer = (GLboolean (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glUnmapBuffer");
if(!_ptrc_glUnmapBuffer) numFailed++;
_ptrc_glAttachShader = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("glAttachShader");
if(!_ptrc_glAttachShader) numFailed++;
_ptrc_glBindAttribLocation = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, const GLchar *))IntGetProcAddress("glBindAttribLocation");
if(!_ptrc_glBindAttribLocation) numFailed++;
_ptrc_glBlendEquationSeparate = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glBlendEquationSeparate");
if(!_ptrc_glBlendEquationSeparate) numFailed++;
_ptrc_glCompileShader = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glCompileShader");
if(!_ptrc_glCompileShader) numFailed++;
_ptrc_glCreateProgram = (GLuint (CODEGEN_FUNCPTR *)())IntGetProcAddress("glCreateProgram");
if(!_ptrc_glCreateProgram) numFailed++;
_ptrc_glCreateShader = (GLuint (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glCreateShader");
if(!_ptrc_glCreateShader) numFailed++;
_ptrc_glDeleteProgram = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glDeleteProgram");
if(!_ptrc_glDeleteProgram) numFailed++;
_ptrc_glDeleteShader = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glDeleteShader");
if(!_ptrc_glDeleteShader) numFailed++;
_ptrc_glDetachShader = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("glDetachShader");
if(!_ptrc_glDetachShader) numFailed++;
_ptrc_glDisableVertexAttribArray = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glDisableVertexAttribArray");
if(!_ptrc_glDisableVertexAttribArray) numFailed++;
_ptrc_glDrawBuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLenum *))IntGetProcAddress("glDrawBuffers");
if(!_ptrc_glDrawBuffers) numFailed++;
_ptrc_glEnableVertexAttribArray = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glEnableVertexAttribArray");
if(!_ptrc_glEnableVertexAttribArray) numFailed++;
_ptrc_glGetActiveAttrib = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *))IntGetProcAddress("glGetActiveAttrib");
if(!_ptrc_glGetActiveAttrib) numFailed++;
_ptrc_glGetActiveUniform = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLsizei, GLsizei *, GLint *, GLenum *, GLchar *))IntGetProcAddress("glGetActiveUniform");
if(!_ptrc_glGetActiveUniform) numFailed++;
_ptrc_glGetAttachedShaders = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, GLsizei *, GLuint *))IntGetProcAddress("glGetAttachedShaders");
if(!_ptrc_glGetAttachedShaders) numFailed++;
_ptrc_glGetAttribLocation = (GLint (CODEGEN_FUNCPTR *)(GLuint, const GLchar *))IntGetProcAddress("glGetAttribLocation");
if(!_ptrc_glGetAttribLocation) numFailed++;
_ptrc_glGetProgramInfoLog = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, GLsizei *, GLchar *))IntGetProcAddress("glGetProgramInfoLog");
if(!_ptrc_glGetProgramInfoLog) numFailed++;
_ptrc_glGetProgramiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetProgramiv");
if(!_ptrc_glGetProgramiv) numFailed++;
_ptrc_glGetShaderInfoLog = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, GLsizei *, GLchar *))IntGetProcAddress("glGetShaderInfoLog");
if(!_ptrc_glGetShaderInfoLog) numFailed++;
_ptrc_glGetShaderSource = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, GLsizei *, GLchar *))IntGetProcAddress("glGetShaderSource");
if(!_ptrc_glGetShaderSource) numFailed++;
_ptrc_glGetShaderiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetShaderiv");
if(!_ptrc_glGetShaderiv) numFailed++;
_ptrc_glGetUniformLocation = (GLint (CODEGEN_FUNCPTR *)(GLuint, const GLchar *))IntGetProcAddress("glGetUniformLocation");
if(!_ptrc_glGetUniformLocation) numFailed++;
_ptrc_glGetUniformfv = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLfloat *))IntGetProcAddress("glGetUniformfv");
if(!_ptrc_glGetUniformfv) numFailed++;
_ptrc_glGetUniformiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLint *))IntGetProcAddress("glGetUniformiv");
if(!_ptrc_glGetUniformiv) numFailed++;
_ptrc_glGetVertexAttribPointerv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLvoid **))IntGetProcAddress("glGetVertexAttribPointerv");
if(!_ptrc_glGetVertexAttribPointerv) numFailed++;
_ptrc_glGetVertexAttribdv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLdouble *))IntGetProcAddress("glGetVertexAttribdv");
if(!_ptrc_glGetVertexAttribdv) numFailed++;
_ptrc_glGetVertexAttribfv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLfloat *))IntGetProcAddress("glGetVertexAttribfv");
if(!_ptrc_glGetVertexAttribfv) numFailed++;
_ptrc_glGetVertexAttribiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetVertexAttribiv");
if(!_ptrc_glGetVertexAttribiv) numFailed++;
_ptrc_glIsProgram = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsProgram");
if(!_ptrc_glIsProgram) numFailed++;
_ptrc_glIsShader = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsShader");
if(!_ptrc_glIsShader) numFailed++;
_ptrc_glLinkProgram = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glLinkProgram");
if(!_ptrc_glLinkProgram) numFailed++;
_ptrc_glShaderSource = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, const GLchar *const*, const GLint *))IntGetProcAddress("glShaderSource");
if(!_ptrc_glShaderSource) numFailed++;
_ptrc_glStencilFuncSeparate = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint, GLuint))IntGetProcAddress("glStencilFuncSeparate");
if(!_ptrc_glStencilFuncSeparate) numFailed++;
_ptrc_glStencilMaskSeparate = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glStencilMaskSeparate");
if(!_ptrc_glStencilMaskSeparate) numFailed++;
_ptrc_glStencilOpSeparate = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLenum))IntGetProcAddress("glStencilOpSeparate");
if(!_ptrc_glStencilOpSeparate) numFailed++;
_ptrc_glUniform1f = (void (CODEGEN_FUNCPTR *)(GLint, GLfloat))IntGetProcAddress("glUniform1f");
if(!_ptrc_glUniform1f) numFailed++;
_ptrc_glUniform1fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLfloat *))IntGetProcAddress("glUniform1fv");
if(!_ptrc_glUniform1fv) numFailed++;
_ptrc_glUniform1i = (void (CODEGEN_FUNCPTR *)(GLint, GLint))IntGetProcAddress("glUniform1i");
if(!_ptrc_glUniform1i) numFailed++;
_ptrc_glUniform1iv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLint *))IntGetProcAddress("glUniform1iv");
if(!_ptrc_glUniform1iv) numFailed++;
_ptrc_glUniform2f = (void (CODEGEN_FUNCPTR *)(GLint, GLfloat, GLfloat))IntGetProcAddress("glUniform2f");
if(!_ptrc_glUniform2f) numFailed++;
_ptrc_glUniform2fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLfloat *))IntGetProcAddress("glUniform2fv");
if(!_ptrc_glUniform2fv) numFailed++;
_ptrc_glUniform2i = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLint))IntGetProcAddress("glUniform2i");
if(!_ptrc_glUniform2i) numFailed++;
_ptrc_glUniform2iv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLint *))IntGetProcAddress("glUniform2iv");
if(!_ptrc_glUniform2iv) numFailed++;
_ptrc_glUniform3f = (void (CODEGEN_FUNCPTR *)(GLint, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glUniform3f");
if(!_ptrc_glUniform3f) numFailed++;
_ptrc_glUniform3fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLfloat *))IntGetProcAddress("glUniform3fv");
if(!_ptrc_glUniform3fv) numFailed++;
_ptrc_glUniform3i = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLint, GLint))IntGetProcAddress("glUniform3i");
if(!_ptrc_glUniform3i) numFailed++;
_ptrc_glUniform3iv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLint *))IntGetProcAddress("glUniform3iv");
if(!_ptrc_glUniform3iv) numFailed++;
_ptrc_glUniform4f = (void (CODEGEN_FUNCPTR *)(GLint, GLfloat, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glUniform4f");
if(!_ptrc_glUniform4f) numFailed++;
_ptrc_glUniform4fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLfloat *))IntGetProcAddress("glUniform4fv");
if(!_ptrc_glUniform4fv) numFailed++;
_ptrc_glUniform4i = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLint, GLint, GLint))IntGetProcAddress("glUniform4i");
if(!_ptrc_glUniform4i) numFailed++;
_ptrc_glUniform4iv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLint *))IntGetProcAddress("glUniform4iv");
if(!_ptrc_glUniform4iv) numFailed++;
_ptrc_glUniformMatrix2fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix2fv");
if(!_ptrc_glUniformMatrix2fv) numFailed++;
_ptrc_glUniformMatrix3fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix3fv");
if(!_ptrc_glUniformMatrix3fv) numFailed++;
_ptrc_glUniformMatrix4fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix4fv");
if(!_ptrc_glUniformMatrix4fv) numFailed++;
_ptrc_glUseProgram = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glUseProgram");
if(!_ptrc_glUseProgram) numFailed++;
_ptrc_glValidateProgram = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glValidateProgram");
if(!_ptrc_glValidateProgram) numFailed++;
_ptrc_glVertexAttrib1d = (void (CODEGEN_FUNCPTR *)(GLuint, GLdouble))IntGetProcAddress("glVertexAttrib1d");
if(!_ptrc_glVertexAttrib1d) numFailed++;
_ptrc_glVertexAttrib1dv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLdouble *))IntGetProcAddress("glVertexAttrib1dv");
if(!_ptrc_glVertexAttrib1dv) numFailed++;
_ptrc_glVertexAttrib1f = (void (CODEGEN_FUNCPTR *)(GLuint, GLfloat))IntGetProcAddress("glVertexAttrib1f");
if(!_ptrc_glVertexAttrib1f) numFailed++;
_ptrc_glVertexAttrib1fv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLfloat *))IntGetProcAddress("glVertexAttrib1fv");
if(!_ptrc_glVertexAttrib1fv) numFailed++;
_ptrc_glVertexAttrib1s = (void (CODEGEN_FUNCPTR *)(GLuint, GLshort))IntGetProcAddress("glVertexAttrib1s");
if(!_ptrc_glVertexAttrib1s) numFailed++;
_ptrc_glVertexAttrib1sv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttrib1sv");
if(!_ptrc_glVertexAttrib1sv) numFailed++;
_ptrc_glVertexAttrib2d = (void (CODEGEN_FUNCPTR *)(GLuint, GLdouble, GLdouble))IntGetProcAddress("glVertexAttrib2d");
if(!_ptrc_glVertexAttrib2d) numFailed++;
_ptrc_glVertexAttrib2dv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLdouble *))IntGetProcAddress("glVertexAttrib2dv");
if(!_ptrc_glVertexAttrib2dv) numFailed++;
_ptrc_glVertexAttrib2f = (void (CODEGEN_FUNCPTR *)(GLuint, GLfloat, GLfloat))IntGetProcAddress("glVertexAttrib2f");
if(!_ptrc_glVertexAttrib2f) numFailed++;
_ptrc_glVertexAttrib2fv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLfloat *))IntGetProcAddress("glVertexAttrib2fv");
if(!_ptrc_glVertexAttrib2fv) numFailed++;
_ptrc_glVertexAttrib2s = (void (CODEGEN_FUNCPTR *)(GLuint, GLshort, GLshort))IntGetProcAddress("glVertexAttrib2s");
if(!_ptrc_glVertexAttrib2s) numFailed++;
_ptrc_glVertexAttrib2sv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttrib2sv");
if(!_ptrc_glVertexAttrib2sv) numFailed++;
_ptrc_glVertexAttrib3d = (void (CODEGEN_FUNCPTR *)(GLuint, GLdouble, GLdouble, GLdouble))IntGetProcAddress("glVertexAttrib3d");
if(!_ptrc_glVertexAttrib3d) numFailed++;
_ptrc_glVertexAttrib3dv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLdouble *))IntGetProcAddress("glVertexAttrib3dv");
if(!_ptrc_glVertexAttrib3dv) numFailed++;
_ptrc_glVertexAttrib3f = (void (CODEGEN_FUNCPTR *)(GLuint, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glVertexAttrib3f");
if(!_ptrc_glVertexAttrib3f) numFailed++;
_ptrc_glVertexAttrib3fv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLfloat *))IntGetProcAddress("glVertexAttrib3fv");
if(!_ptrc_glVertexAttrib3fv) numFailed++;
_ptrc_glVertexAttrib3s = (void (CODEGEN_FUNCPTR *)(GLuint, GLshort, GLshort, GLshort))IntGetProcAddress("glVertexAttrib3s");
if(!_ptrc_glVertexAttrib3s) numFailed++;
_ptrc_glVertexAttrib3sv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttrib3sv");
if(!_ptrc_glVertexAttrib3sv) numFailed++;
_ptrc_glVertexAttrib4Nbv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLbyte *))IntGetProcAddress("glVertexAttrib4Nbv");
if(!_ptrc_glVertexAttrib4Nbv) numFailed++;
_ptrc_glVertexAttrib4Niv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttrib4Niv");
if(!_ptrc_glVertexAttrib4Niv) numFailed++;
_ptrc_glVertexAttrib4Nsv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttrib4Nsv");
if(!_ptrc_glVertexAttrib4Nsv) numFailed++;
_ptrc_glVertexAttrib4Nub = (void (CODEGEN_FUNCPTR *)(GLuint, GLubyte, GLubyte, GLubyte, GLubyte))IntGetProcAddress("glVertexAttrib4Nub");
if(!_ptrc_glVertexAttrib4Nub) numFailed++;
_ptrc_glVertexAttrib4Nubv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLubyte *))IntGetProcAddress("glVertexAttrib4Nubv");
if(!_ptrc_glVertexAttrib4Nubv) numFailed++;
_ptrc_glVertexAttrib4Nuiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttrib4Nuiv");
if(!_ptrc_glVertexAttrib4Nuiv) numFailed++;
_ptrc_glVertexAttrib4Nusv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLushort *))IntGetProcAddress("glVertexAttrib4Nusv");
if(!_ptrc_glVertexAttrib4Nusv) numFailed++;
_ptrc_glVertexAttrib4bv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLbyte *))IntGetProcAddress("glVertexAttrib4bv");
if(!_ptrc_glVertexAttrib4bv) numFailed++;
_ptrc_glVertexAttrib4d = (void (CODEGEN_FUNCPTR *)(GLuint, GLdouble, GLdouble, GLdouble, GLdouble))IntGetProcAddress("glVertexAttrib4d");
if(!_ptrc_glVertexAttrib4d) numFailed++;
_ptrc_glVertexAttrib4dv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLdouble *))IntGetProcAddress("glVertexAttrib4dv");
if(!_ptrc_glVertexAttrib4dv) numFailed++;
_ptrc_glVertexAttrib4f = (void (CODEGEN_FUNCPTR *)(GLuint, GLfloat, GLfloat, GLfloat, GLfloat))IntGetProcAddress("glVertexAttrib4f");
if(!_ptrc_glVertexAttrib4f) numFailed++;
_ptrc_glVertexAttrib4fv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLfloat *))IntGetProcAddress("glVertexAttrib4fv");
if(!_ptrc_glVertexAttrib4fv) numFailed++;
_ptrc_glVertexAttrib4iv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttrib4iv");
if(!_ptrc_glVertexAttrib4iv) numFailed++;
_ptrc_glVertexAttrib4s = (void (CODEGEN_FUNCPTR *)(GLuint, GLshort, GLshort, GLshort, GLshort))IntGetProcAddress("glVertexAttrib4s");
if(!_ptrc_glVertexAttrib4s) numFailed++;
_ptrc_glVertexAttrib4sv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttrib4sv");
if(!_ptrc_glVertexAttrib4sv) numFailed++;
_ptrc_glVertexAttrib4ubv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLubyte *))IntGetProcAddress("glVertexAttrib4ubv");
if(!_ptrc_glVertexAttrib4ubv) numFailed++;
_ptrc_glVertexAttrib4uiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttrib4uiv");
if(!_ptrc_glVertexAttrib4uiv) numFailed++;
_ptrc_glVertexAttrib4usv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLushort *))IntGetProcAddress("glVertexAttrib4usv");
if(!_ptrc_glVertexAttrib4usv) numFailed++;
_ptrc_glVertexAttribPointer = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLenum, GLboolean, GLsizei, const GLvoid *))IntGetProcAddress("glVertexAttribPointer");
if(!_ptrc_glVertexAttribPointer) numFailed++;
_ptrc_glUniformMatrix2x3fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix2x3fv");
if(!_ptrc_glUniformMatrix2x3fv) numFailed++;
_ptrc_glUniformMatrix2x4fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix2x4fv");
if(!_ptrc_glUniformMatrix2x4fv) numFailed++;
_ptrc_glUniformMatrix3x2fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix3x2fv");
if(!_ptrc_glUniformMatrix3x2fv) numFailed++;
_ptrc_glUniformMatrix3x4fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix3x4fv");
if(!_ptrc_glUniformMatrix3x4fv) numFailed++;
_ptrc_glUniformMatrix4x2fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix4x2fv");
if(!_ptrc_glUniformMatrix4x2fv) numFailed++;
_ptrc_glUniformMatrix4x3fv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, GLboolean, const GLfloat *))IntGetProcAddress("glUniformMatrix4x3fv");
if(!_ptrc_glUniformMatrix4x3fv) numFailed++;
_ptrc_glBeginConditionalRender = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum))IntGetProcAddress("glBeginConditionalRender");
if(!_ptrc_glBeginConditionalRender) numFailed++;
_ptrc_glBeginTransformFeedback = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glBeginTransformFeedback");
if(!_ptrc_glBeginTransformFeedback) numFailed++;
_ptrc_glBindBufferBase = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLuint))IntGetProcAddress("glBindBufferBase");
if(!_ptrc_glBindBufferBase) numFailed++;
_ptrc_glBindBufferRange = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLuint, GLintptr, GLsizeiptr))IntGetProcAddress("glBindBufferRange");
if(!_ptrc_glBindBufferRange) numFailed++;
_ptrc_glBindFragDataLocation = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, const GLchar *))IntGetProcAddress("glBindFragDataLocation");
if(!_ptrc_glBindFragDataLocation) numFailed++;
_ptrc_glBindFramebuffer = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glBindFramebuffer");
if(!_ptrc_glBindFramebuffer) numFailed++;
_ptrc_glBindRenderbuffer = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glBindRenderbuffer");
if(!_ptrc_glBindRenderbuffer) numFailed++;
_ptrc_glBindVertexArray = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glBindVertexArray");
if(!_ptrc_glBindVertexArray) numFailed++;
_ptrc_glBlitFramebuffer = (void (CODEGEN_FUNCPTR *)(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum))IntGetProcAddress("glBlitFramebuffer");
if(!_ptrc_glBlitFramebuffer) numFailed++;
_ptrc_glCheckFramebufferStatus = (GLenum (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glCheckFramebufferStatus");
if(!_ptrc_glCheckFramebufferStatus) numFailed++;
_ptrc_glClampColor = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum))IntGetProcAddress("glClampColor");
if(!_ptrc_glClampColor) numFailed++;
_ptrc_glClearBufferfi = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLfloat, GLint))IntGetProcAddress("glClearBufferfi");
if(!_ptrc_glClearBufferfi) numFailed++;
_ptrc_glClearBufferfv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, const GLfloat *))IntGetProcAddress("glClearBufferfv");
if(!_ptrc_glClearBufferfv) numFailed++;
_ptrc_glClearBufferiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, const GLint *))IntGetProcAddress("glClearBufferiv");
if(!_ptrc_glClearBufferiv) numFailed++;
_ptrc_glClearBufferuiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, const GLuint *))IntGetProcAddress("glClearBufferuiv");
if(!_ptrc_glClearBufferuiv) numFailed++;
_ptrc_glColorMaski = (void (CODEGEN_FUNCPTR *)(GLuint, GLboolean, GLboolean, GLboolean, GLboolean))IntGetProcAddress("glColorMaski");
if(!_ptrc_glColorMaski) numFailed++;
_ptrc_glDeleteFramebuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteFramebuffers");
if(!_ptrc_glDeleteFramebuffers) numFailed++;
_ptrc_glDeleteRenderbuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteRenderbuffers");
if(!_ptrc_glDeleteRenderbuffers) numFailed++;
_ptrc_glDeleteVertexArrays = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteVertexArrays");
if(!_ptrc_glDeleteVertexArrays) numFailed++;
_ptrc_glDisablei = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glDisablei");
if(!_ptrc_glDisablei) numFailed++;
_ptrc_glEnablei = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glEnablei");
if(!_ptrc_glEnablei) numFailed++;
_ptrc_glEndConditionalRender = (void (CODEGEN_FUNCPTR *)())IntGetProcAddress("glEndConditionalRender");
if(!_ptrc_glEndConditionalRender) numFailed++;
_ptrc_glEndTransformFeedback = (void (CODEGEN_FUNCPTR *)())IntGetProcAddress("glEndTransformFeedback");
if(!_ptrc_glEndTransformFeedback) numFailed++;
_ptrc_glFlushMappedBufferRange = (void (CODEGEN_FUNCPTR *)(GLenum, GLintptr, GLsizeiptr))IntGetProcAddress("glFlushMappedBufferRange");
if(!_ptrc_glFlushMappedBufferRange) numFailed++;
_ptrc_glFramebufferRenderbuffer = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLuint))IntGetProcAddress("glFramebufferRenderbuffer");
if(!_ptrc_glFramebufferRenderbuffer) numFailed++;
_ptrc_glFramebufferTexture1D = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLuint, GLint))IntGetProcAddress("glFramebufferTexture1D");
if(!_ptrc_glFramebufferTexture1D) numFailed++;
_ptrc_glFramebufferTexture2D = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLuint, GLint))IntGetProcAddress("glFramebufferTexture2D");
if(!_ptrc_glFramebufferTexture2D) numFailed++;
_ptrc_glFramebufferTexture3D = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLuint, GLint, GLint))IntGetProcAddress("glFramebufferTexture3D");
if(!_ptrc_glFramebufferTexture3D) numFailed++;
_ptrc_glFramebufferTextureLayer = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLuint, GLint, GLint))IntGetProcAddress("glFramebufferTextureLayer");
if(!_ptrc_glFramebufferTextureLayer) numFailed++;
_ptrc_glGenFramebuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenFramebuffers");
if(!_ptrc_glGenFramebuffers) numFailed++;
_ptrc_glGenRenderbuffers = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenRenderbuffers");
if(!_ptrc_glGenRenderbuffers) numFailed++;
_ptrc_glGenVertexArrays = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenVertexArrays");
if(!_ptrc_glGenVertexArrays) numFailed++;
_ptrc_glGenerateMipmap = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glGenerateMipmap");
if(!_ptrc_glGenerateMipmap) numFailed++;
_ptrc_glGetBooleani_v = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLboolean *))IntGetProcAddress("glGetBooleani_v");
if(!_ptrc_glGetBooleani_v) numFailed++;
_ptrc_glGetFragDataLocation = (GLint (CODEGEN_FUNCPTR *)(GLuint, const GLchar *))IntGetProcAddress("glGetFragDataLocation");
if(!_ptrc_glGetFragDataLocation) numFailed++;
_ptrc_glGetFramebufferAttachmentParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLenum, GLint *))IntGetProcAddress("glGetFramebufferAttachmentParameteriv");
if(!_ptrc_glGetFramebufferAttachmentParameteriv) numFailed++;
_ptrc_glGetIntegeri_v = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLint *))IntGetProcAddress("glGetIntegeri_v");
if(!_ptrc_glGetIntegeri_v) numFailed++;
_ptrc_glGetRenderbufferParameteriv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint *))IntGetProcAddress("glGetRenderbufferParameteriv");
if(!_ptrc_glGetRenderbufferParameteriv) numFailed++;
_ptrc_glGetStringi = (const GLubyte * (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glGetStringi");
if(!_ptrc_glGetStringi) numFailed++;
_ptrc_glGetTexParameterIiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint *))IntGetProcAddress("glGetTexParameterIiv");
if(!_ptrc_glGetTexParameterIiv) numFailed++;
_ptrc_glGetTexParameterIuiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLuint *))IntGetProcAddress("glGetTexParameterIuiv");
if(!_ptrc_glGetTexParameterIuiv) numFailed++;
_ptrc_glGetTransformFeedbackVarying = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *))IntGetProcAddress("glGetTransformFeedbackVarying");
if(!_ptrc_glGetTransformFeedbackVarying) numFailed++;
_ptrc_glGetUniformuiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLuint *))IntGetProcAddress("glGetUniformuiv");
if(!_ptrc_glGetUniformuiv) numFailed++;
_ptrc_glGetVertexAttribIiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetVertexAttribIiv");
if(!_ptrc_glGetVertexAttribIiv) numFailed++;
_ptrc_glGetVertexAttribIuiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLuint *))IntGetProcAddress("glGetVertexAttribIuiv");
if(!_ptrc_glGetVertexAttribIuiv) numFailed++;
_ptrc_glIsEnabledi = (GLboolean (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glIsEnabledi");
if(!_ptrc_glIsEnabledi) numFailed++;
_ptrc_glIsFramebuffer = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsFramebuffer");
if(!_ptrc_glIsFramebuffer) numFailed++;
_ptrc_glIsRenderbuffer = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsRenderbuffer");
if(!_ptrc_glIsRenderbuffer) numFailed++;
_ptrc_glIsVertexArray = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsVertexArray");
if(!_ptrc_glIsVertexArray) numFailed++;
_ptrc_glMapBufferRange = (void * (CODEGEN_FUNCPTR *)(GLenum, GLintptr, GLsizeiptr, GLbitfield))IntGetProcAddress("glMapBufferRange");
if(!_ptrc_glMapBufferRange) numFailed++;
_ptrc_glRenderbufferStorage = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLsizei, GLsizei))IntGetProcAddress("glRenderbufferStorage");
if(!_ptrc_glRenderbufferStorage) numFailed++;
_ptrc_glRenderbufferStorageMultisample = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLenum, GLsizei, GLsizei))IntGetProcAddress("glRenderbufferStorageMultisample");
if(!_ptrc_glRenderbufferStorageMultisample) numFailed++;
_ptrc_glTexParameterIiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, const GLint *))IntGetProcAddress("glTexParameterIiv");
if(!_ptrc_glTexParameterIiv) numFailed++;
_ptrc_glTexParameterIuiv = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, const GLuint *))IntGetProcAddress("glTexParameterIuiv");
if(!_ptrc_glTexParameterIuiv) numFailed++;
_ptrc_glTransformFeedbackVaryings = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, const GLchar *const*, GLenum))IntGetProcAddress("glTransformFeedbackVaryings");
if(!_ptrc_glTransformFeedbackVaryings) numFailed++;
_ptrc_glUniform1ui = (void (CODEGEN_FUNCPTR *)(GLint, GLuint))IntGetProcAddress("glUniform1ui");
if(!_ptrc_glUniform1ui) numFailed++;
_ptrc_glUniform1uiv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLuint *))IntGetProcAddress("glUniform1uiv");
if(!_ptrc_glUniform1uiv) numFailed++;
_ptrc_glUniform2ui = (void (CODEGEN_FUNCPTR *)(GLint, GLuint, GLuint))IntGetProcAddress("glUniform2ui");
if(!_ptrc_glUniform2ui) numFailed++;
_ptrc_glUniform2uiv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLuint *))IntGetProcAddress("glUniform2uiv");
if(!_ptrc_glUniform2uiv) numFailed++;
_ptrc_glUniform3ui = (void (CODEGEN_FUNCPTR *)(GLint, GLuint, GLuint, GLuint))IntGetProcAddress("glUniform3ui");
if(!_ptrc_glUniform3ui) numFailed++;
_ptrc_glUniform3uiv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLuint *))IntGetProcAddress("glUniform3uiv");
if(!_ptrc_glUniform3uiv) numFailed++;
_ptrc_glUniform4ui = (void (CODEGEN_FUNCPTR *)(GLint, GLuint, GLuint, GLuint, GLuint))IntGetProcAddress("glUniform4ui");
if(!_ptrc_glUniform4ui) numFailed++;
_ptrc_glUniform4uiv = (void (CODEGEN_FUNCPTR *)(GLint, GLsizei, const GLuint *))IntGetProcAddress("glUniform4uiv");
if(!_ptrc_glUniform4uiv) numFailed++;
_ptrc_glVertexAttribI1i = (void (CODEGEN_FUNCPTR *)(GLuint, GLint))IntGetProcAddress("glVertexAttribI1i");
if(!_ptrc_glVertexAttribI1i) numFailed++;
_ptrc_glVertexAttribI1iv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttribI1iv");
if(!_ptrc_glVertexAttribI1iv) numFailed++;
_ptrc_glVertexAttribI1ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("glVertexAttribI1ui");
if(!_ptrc_glVertexAttribI1ui) numFailed++;
_ptrc_glVertexAttribI1uiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttribI1uiv");
if(!_ptrc_glVertexAttribI1uiv) numFailed++;
_ptrc_glVertexAttribI2i = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLint))IntGetProcAddress("glVertexAttribI2i");
if(!_ptrc_glVertexAttribI2i) numFailed++;
_ptrc_glVertexAttribI2iv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttribI2iv");
if(!_ptrc_glVertexAttribI2iv) numFailed++;
_ptrc_glVertexAttribI2ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLuint))IntGetProcAddress("glVertexAttribI2ui");
if(!_ptrc_glVertexAttribI2ui) numFailed++;
_ptrc_glVertexAttribI2uiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttribI2uiv");
if(!_ptrc_glVertexAttribI2uiv) numFailed++;
_ptrc_glVertexAttribI3i = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLint, GLint))IntGetProcAddress("glVertexAttribI3i");
if(!_ptrc_glVertexAttribI3i) numFailed++;
_ptrc_glVertexAttribI3iv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttribI3iv");
if(!_ptrc_glVertexAttribI3iv) numFailed++;
_ptrc_glVertexAttribI3ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLuint, GLuint))IntGetProcAddress("glVertexAttribI3ui");
if(!_ptrc_glVertexAttribI3ui) numFailed++;
_ptrc_glVertexAttribI3uiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttribI3uiv");
if(!_ptrc_glVertexAttribI3uiv) numFailed++;
_ptrc_glVertexAttribI4bv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLbyte *))IntGetProcAddress("glVertexAttribI4bv");
if(!_ptrc_glVertexAttribI4bv) numFailed++;
_ptrc_glVertexAttribI4i = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLint, GLint, GLint))IntGetProcAddress("glVertexAttribI4i");
if(!_ptrc_glVertexAttribI4i) numFailed++;
_ptrc_glVertexAttribI4iv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLint *))IntGetProcAddress("glVertexAttribI4iv");
if(!_ptrc_glVertexAttribI4iv) numFailed++;
_ptrc_glVertexAttribI4sv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLshort *))IntGetProcAddress("glVertexAttribI4sv");
if(!_ptrc_glVertexAttribI4sv) numFailed++;
_ptrc_glVertexAttribI4ubv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLubyte *))IntGetProcAddress("glVertexAttribI4ubv");
if(!_ptrc_glVertexAttribI4ubv) numFailed++;
_ptrc_glVertexAttribI4ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLuint, GLuint, GLuint))IntGetProcAddress("glVertexAttribI4ui");
if(!_ptrc_glVertexAttribI4ui) numFailed++;
_ptrc_glVertexAttribI4uiv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLuint *))IntGetProcAddress("glVertexAttribI4uiv");
if(!_ptrc_glVertexAttribI4uiv) numFailed++;
_ptrc_glVertexAttribI4usv = (void (CODEGEN_FUNCPTR *)(GLuint, const GLushort *))IntGetProcAddress("glVertexAttribI4usv");
if(!_ptrc_glVertexAttribI4usv) numFailed++;
_ptrc_glVertexAttribIPointer = (void (CODEGEN_FUNCPTR *)(GLuint, GLint, GLenum, GLsizei, const GLvoid *))IntGetProcAddress("glVertexAttribIPointer");
if(!_ptrc_glVertexAttribIPointer) numFailed++;
_ptrc_glCopyBufferSubData = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr))IntGetProcAddress("glCopyBufferSubData");
if(!_ptrc_glCopyBufferSubData) numFailed++;
_ptrc_glDrawArraysInstanced = (void (CODEGEN_FUNCPTR *)(GLenum, GLint, GLsizei, GLsizei))IntGetProcAddress("glDrawArraysInstanced");
if(!_ptrc_glDrawArraysInstanced) numFailed++;
_ptrc_glDrawElementsInstanced = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei))IntGetProcAddress("glDrawElementsInstanced");
if(!_ptrc_glDrawElementsInstanced) numFailed++;
_ptrc_glGetActiveUniformBlockName = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *))IntGetProcAddress("glGetActiveUniformBlockName");
if(!_ptrc_glGetActiveUniformBlockName) numFailed++;
_ptrc_glGetActiveUniformBlockiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLenum, GLint *))IntGetProcAddress("glGetActiveUniformBlockiv");
if(!_ptrc_glGetActiveUniformBlockiv) numFailed++;
_ptrc_glGetActiveUniformName = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLsizei, GLsizei *, GLchar *))IntGetProcAddress("glGetActiveUniformName");
if(!_ptrc_glGetActiveUniformName) numFailed++;
_ptrc_glGetActiveUniformsiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, const GLuint *, GLenum, GLint *))IntGetProcAddress("glGetActiveUniformsiv");
if(!_ptrc_glGetActiveUniformsiv) numFailed++;
_ptrc_glGetUniformBlockIndex = (GLuint (CODEGEN_FUNCPTR *)(GLuint, const GLchar *))IntGetProcAddress("glGetUniformBlockIndex");
if(!_ptrc_glGetUniformBlockIndex) numFailed++;
_ptrc_glGetUniformIndices = (void (CODEGEN_FUNCPTR *)(GLuint, GLsizei, const GLchar *const*, GLuint *))IntGetProcAddress("glGetUniformIndices");
if(!_ptrc_glGetUniformIndices) numFailed++;
_ptrc_glPrimitiveRestartIndex = (void (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glPrimitiveRestartIndex");
if(!_ptrc_glPrimitiveRestartIndex) numFailed++;
_ptrc_glTexBuffer = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLuint))IntGetProcAddress("glTexBuffer");
if(!_ptrc_glTexBuffer) numFailed++;
_ptrc_glUniformBlockBinding = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLuint))IntGetProcAddress("glUniformBlockBinding");
if(!_ptrc_glUniformBlockBinding) numFailed++;
_ptrc_glClientWaitSync = (GLenum (CODEGEN_FUNCPTR *)(GLsync, GLbitfield, GLuint64))IntGetProcAddress("glClientWaitSync");
if(!_ptrc_glClientWaitSync) numFailed++;
_ptrc_glDeleteSync = (void (CODEGEN_FUNCPTR *)(GLsync))IntGetProcAddress("glDeleteSync");
if(!_ptrc_glDeleteSync) numFailed++;
_ptrc_glDrawElementsBaseVertex = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLenum, const GLvoid *, GLint))IntGetProcAddress("glDrawElementsBaseVertex");
if(!_ptrc_glDrawElementsBaseVertex) numFailed++;
_ptrc_glDrawElementsInstancedBaseVertex = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLenum, const GLvoid *, GLsizei, GLint))IntGetProcAddress("glDrawElementsInstancedBaseVertex");
if(!_ptrc_glDrawElementsInstancedBaseVertex) numFailed++;
_ptrc_glDrawRangeElementsBaseVertex = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *, GLint))IntGetProcAddress("glDrawRangeElementsBaseVertex");
if(!_ptrc_glDrawRangeElementsBaseVertex) numFailed++;
_ptrc_glFenceSync = (GLsync (CODEGEN_FUNCPTR *)(GLenum, GLbitfield))IntGetProcAddress("glFenceSync");
if(!_ptrc_glFenceSync) numFailed++;
_ptrc_glFramebufferTexture = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLuint, GLint))IntGetProcAddress("glFramebufferTexture");
if(!_ptrc_glFramebufferTexture) numFailed++;
_ptrc_glGetBufferParameteri64v = (void (CODEGEN_FUNCPTR *)(GLenum, GLenum, GLint64 *))IntGetProcAddress("glGetBufferParameteri64v");
if(!_ptrc_glGetBufferParameteri64v) numFailed++;
_ptrc_glGetInteger64i_v = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLint64 *))IntGetProcAddress("glGetInteger64i_v");
if(!_ptrc_glGetInteger64i_v) numFailed++;
_ptrc_glGetInteger64v = (void (CODEGEN_FUNCPTR *)(GLenum, GLint64 *))IntGetProcAddress("glGetInteger64v");
if(!_ptrc_glGetInteger64v) numFailed++;
_ptrc_glGetMultisamplefv = (void (CODEGEN_FUNCPTR *)(GLenum, GLuint, GLfloat *))IntGetProcAddress("glGetMultisamplefv");
if(!_ptrc_glGetMultisamplefv) numFailed++;
_ptrc_glGetSynciv = (void (CODEGEN_FUNCPTR *)(GLsync, GLenum, GLsizei, GLsizei *, GLint *))IntGetProcAddress("glGetSynciv");
if(!_ptrc_glGetSynciv) numFailed++;
_ptrc_glIsSync = (GLboolean (CODEGEN_FUNCPTR *)(GLsync))IntGetProcAddress("glIsSync");
if(!_ptrc_glIsSync) numFailed++;
_ptrc_glMultiDrawElementsBaseVertex = (void (CODEGEN_FUNCPTR *)(GLenum, const GLsizei *, GLenum, const GLvoid *const*, GLsizei, const GLint *))IntGetProcAddress("glMultiDrawElementsBaseVertex");
if(!_ptrc_glMultiDrawElementsBaseVertex) numFailed++;
_ptrc_glProvokingVertex = (void (CODEGEN_FUNCPTR *)(GLenum))IntGetProcAddress("glProvokingVertex");
if(!_ptrc_glProvokingVertex) numFailed++;
_ptrc_glSampleMaski = (void (CODEGEN_FUNCPTR *)(GLuint, GLbitfield))IntGetProcAddress("glSampleMaski");
if(!_ptrc_glSampleMaski) numFailed++;
_ptrc_glTexImage2DMultisample = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean))IntGetProcAddress("glTexImage2DMultisample");
if(!_ptrc_glTexImage2DMultisample) numFailed++;
_ptrc_glTexImage3DMultisample = (void (CODEGEN_FUNCPTR *)(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean))IntGetProcAddress("glTexImage3DMultisample");
if(!_ptrc_glTexImage3DMultisample) numFailed++;
_ptrc_glWaitSync = (void (CODEGEN_FUNCPTR *)(GLsync, GLbitfield, GLuint64))IntGetProcAddress("glWaitSync");
if(!_ptrc_glWaitSync) numFailed++;
_ptrc_glBindFragDataLocationIndexed = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint, GLuint, const GLchar *))IntGetProcAddress("glBindFragDataLocationIndexed");
if(!_ptrc_glBindFragDataLocationIndexed) numFailed++;
_ptrc_glBindSampler = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("glBindSampler");
if(!_ptrc_glBindSampler) numFailed++;
_ptrc_glDeleteSamplers = (void (CODEGEN_FUNCPTR *)(GLsizei, const GLuint *))IntGetProcAddress("glDeleteSamplers");
if(!_ptrc_glDeleteSamplers) numFailed++;
_ptrc_glGenSamplers = (void (CODEGEN_FUNCPTR *)(GLsizei, GLuint *))IntGetProcAddress("glGenSamplers");
if(!_ptrc_glGenSamplers) numFailed++;
_ptrc_glGetFragDataIndex = (GLint (CODEGEN_FUNCPTR *)(GLuint, const GLchar *))IntGetProcAddress("glGetFragDataIndex");
if(!_ptrc_glGetFragDataIndex) numFailed++;
_ptrc_glGetQueryObjecti64v = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint64 *))IntGetProcAddress("glGetQueryObjecti64v");
if(!_ptrc_glGetQueryObjecti64v) numFailed++;
_ptrc_glGetQueryObjectui64v = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLuint64 *))IntGetProcAddress("glGetQueryObjectui64v");
if(!_ptrc_glGetQueryObjectui64v) numFailed++;
_ptrc_glGetSamplerParameterIiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetSamplerParameterIiv");
if(!_ptrc_glGetSamplerParameterIiv) numFailed++;
_ptrc_glGetSamplerParameterIuiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLuint *))IntGetProcAddress("glGetSamplerParameterIuiv");
if(!_ptrc_glGetSamplerParameterIuiv) numFailed++;
_ptrc_glGetSamplerParameterfv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLfloat *))IntGetProcAddress("glGetSamplerParameterfv");
if(!_ptrc_glGetSamplerParameterfv) numFailed++;
_ptrc_glGetSamplerParameteriv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint *))IntGetProcAddress("glGetSamplerParameteriv");
if(!_ptrc_glGetSamplerParameteriv) numFailed++;
_ptrc_glIsSampler = (GLboolean (CODEGEN_FUNCPTR *)(GLuint))IntGetProcAddress("glIsSampler");
if(!_ptrc_glIsSampler) numFailed++;
_ptrc_glQueryCounter = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum))IntGetProcAddress("glQueryCounter");
if(!_ptrc_glQueryCounter) numFailed++;
_ptrc_glSamplerParameterIiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, const GLint *))IntGetProcAddress("glSamplerParameterIiv");
if(!_ptrc_glSamplerParameterIiv) numFailed++;
_ptrc_glSamplerParameterIuiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, const GLuint *))IntGetProcAddress("glSamplerParameterIuiv");
if(!_ptrc_glSamplerParameterIuiv) numFailed++;
_ptrc_glSamplerParameterf = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLfloat))IntGetProcAddress("glSamplerParameterf");
if(!_ptrc_glSamplerParameterf) numFailed++;
_ptrc_glSamplerParameterfv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, const GLfloat *))IntGetProcAddress("glSamplerParameterfv");
if(!_ptrc_glSamplerParameterfv) numFailed++;
_ptrc_glSamplerParameteri = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLint))IntGetProcAddress("glSamplerParameteri");
if(!_ptrc_glSamplerParameteri) numFailed++;
_ptrc_glSamplerParameteriv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, const GLint *))IntGetProcAddress("glSamplerParameteriv");
if(!_ptrc_glSamplerParameteriv) numFailed++;
_ptrc_glVertexAttribDivisor = (void (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("glVertexAttribDivisor");
if(!_ptrc_glVertexAttribDivisor) numFailed++;
_ptrc_glVertexAttribP1ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, GLuint))IntGetProcAddress("glVertexAttribP1ui");
if(!_ptrc_glVertexAttribP1ui) numFailed++;
_ptrc_glVertexAttribP1uiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, const GLuint *))IntGetProcAddress("glVertexAttribP1uiv");
if(!_ptrc_glVertexAttribP1uiv) numFailed++;
_ptrc_glVertexAttribP2ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, GLuint))IntGetProcAddress("glVertexAttribP2ui");
if(!_ptrc_glVertexAttribP2ui) numFailed++;
_ptrc_glVertexAttribP2uiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, const GLuint *))IntGetProcAddress("glVertexAttribP2uiv");
if(!_ptrc_glVertexAttribP2uiv) numFailed++;
_ptrc_glVertexAttribP3ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, GLuint))IntGetProcAddress("glVertexAttribP3ui");
if(!_ptrc_glVertexAttribP3ui) numFailed++;
_ptrc_glVertexAttribP3uiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, const GLuint *))IntGetProcAddress("glVertexAttribP3uiv");
if(!_ptrc_glVertexAttribP3uiv) numFailed++;
_ptrc_glVertexAttribP4ui = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, GLuint))IntGetProcAddress("glVertexAttribP4ui");
if(!_ptrc_glVertexAttribP4ui) numFailed++;
_ptrc_glVertexAttribP4uiv = (void (CODEGEN_FUNCPTR *)(GLuint, GLenum, GLboolean, const GLuint *))IntGetProcAddress("glVertexAttribP4uiv");
if(!_ptrc_glVertexAttribP4uiv) numFailed++;
return numFailed;
}

typedef int (*PFN_LOADFUNCPOINTERS)();
typedef struct ogl_StrToExtMap_s
{
char *extensionName;
int *extensionVariable;
PFN_LOADFUNCPOINTERS LoadExtension;
} ogl_StrToExtMap;

static ogl_StrToExtMap ExtensionMap[2] = {
{"GL_ARB_framebuffer_sRGB", &ogl_ext_ARB_framebuffer_sRGB, NULL},
{"GL_EXT_framebuffer_sRGB", &ogl_ext_EXT_framebuffer_sRGB, NULL},
};

static int g_extensionMapSize = 2;

static ogl_StrToExtMap *FindExtEntry(const char *extensionName)
{
int loop;
ogl_StrToExtMap *currLoc = ExtensionMap;
for(loop = 0; loop < g_extensionMapSize; ++loop, ++currLoc)
{
if(strcmp(extensionName, currLoc->extensionName) == 0)
return currLoc;
}

return NULL;
}

static void ClearExtensionVars()
{
ogl_ext_ARB_framebuffer_sRGB = ogl_LOAD_FAILED;
ogl_ext_EXT_framebuffer_sRGB = ogl_LOAD_FAILED;
}


static void LoadExtByName(const char *extensionName)
{
ogl_StrToExtMap *entry = NULL;
entry = FindExtEntry(extensionName);
if(entry)
{
if(entry->LoadExtension)
{
int numFailed = entry->LoadExtension();
if(numFailed == 0)
{
*(entry->extensionVariable) = ogl_LOAD_SUCCEEDED;
}
else
{
*(entry->extensionVariable) = ogl_LOAD_SUCCEEDED + numFailed;
}
}
else
{
*(entry->extensionVariable) = ogl_LOAD_SUCCEEDED;
}
}
}


static void ProcExtsFromExtList()
{
GLint iLoop;
GLint iNumExtensions = 0;
_ptrc_glGetIntegerv(GL_NUM_EXTENSIONS, &iNumExtensions);

for(iLoop = 0; iLoop < iNumExtensions; iLoop++)
{
const char *strExtensionName = (const char *)_ptrc_glGetStringi(GL_EXTENSIONS, iLoop);
LoadExtByName(strExtensionName);
}
}

int ogl_LoadFunctions()
{
int numFailed = 0;
ClearExtensionVars();

_ptrc_glGetIntegerv = (void (CODEGEN_FUNCPTR *)(GLenum, GLint *))IntGetProcAddress("glGetIntegerv");
if(!_ptrc_glGetIntegerv) return ogl_LOAD_FAILED;
_ptrc_glGetStringi = (const GLubyte * (CODEGEN_FUNCPTR *)(GLenum, GLuint))IntGetProcAddress("glGetStringi");
if(!_ptrc_glGetStringi) return ogl_LOAD_FAILED;

ProcExtsFromExtList();
numFailed = Load_Version_3_3();

if(numFailed == 0)
return ogl_LOAD_SUCCEEDED;
else
return ogl_LOAD_SUCCEEDED + numFailed;
}

static int g_major_version = 0;
static int g_minor_version = 0;

static void GetGLVersion()
{
glGetIntegerv(GL_MAJOR_VERSION, &g_major_version);
glGetIntegerv(GL_MINOR_VERSION, &g_minor_version);
}

int ogl_GetMajorVersion()
{
if(g_major_version == 0)
GetGLVersion();
return g_major_version;
}

int ogl_GetMinorVersion()
{
if(g_major_version == 0) //Yes, check the major version to get the minor one.
GetGLVersion();
return g_minor_version;
}

int ogl_IsVersionGEQ(int majorVersion, int minorVersion)
{
if(g_major_version == 0)
GetGLVersion();

if(majorVersion > g_major_version) return 1;
if(majorVersion < g_major_version) return 0;
if(minorVersion >= g_minor_version) return 1;
return 0;
}

#ifdef XO_PLATFORM_WIN_DESKTOP
int wgl_ext_ARB_multisample = wgl_LOAD_FAILED;
int wgl_ext_ARB_extensions_string = wgl_LOAD_FAILED;
int wgl_ext_ARB_pixel_format = wgl_LOAD_FAILED;
int wgl_ext_ARB_pixel_format_float = wgl_LOAD_FAILED;
int wgl_ext_ARB_framebuffer_sRGB = wgl_LOAD_FAILED;
int wgl_ext_ARB_create_context = wgl_LOAD_FAILED;
int wgl_ext_ARB_create_context_profile = wgl_LOAD_FAILED;
int wgl_ext_ARB_create_context_robustness = wgl_LOAD_FAILED;
int wgl_ext_EXT_swap_control = wgl_LOAD_FAILED;
int wgl_ext_EXT_pixel_format_packed_float = wgl_LOAD_FAILED;
int wgl_ext_EXT_create_context_es2_profile = wgl_LOAD_FAILED;
int wgl_ext_EXT_swap_control_tear = wgl_LOAD_FAILED;
int wgl_ext_NV_swap_group = wgl_LOAD_FAILED;

const char * (CODEGEN_FUNCPTR *_ptrc_wglGetExtensionsStringARB)(HDC) = NULL;

static int Load_ARB_extensions_string()
{
int numFailed = 0;
_ptrc_wglGetExtensionsStringARB = (const char * (CODEGEN_FUNCPTR *)(HDC))IntGetProcAddress("wglGetExtensionsStringARB");
if(!_ptrc_wglGetExtensionsStringARB) numFailed++;
return numFailed;
}

BOOL (CODEGEN_FUNCPTR *_ptrc_wglChoosePixelFormatARB)(HDC, const int *, const FLOAT *, UINT, int *, UINT *) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglGetPixelFormatAttribfvARB)(HDC, int, int, UINT, const int *, FLOAT *) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglGetPixelFormatAttribivARB)(HDC, int, int, UINT, const int *, int *) = NULL;

static int Load_ARB_pixel_format()
{
int numFailed = 0;
_ptrc_wglChoosePixelFormatARB = (BOOL (CODEGEN_FUNCPTR *)(HDC, const int *, const FLOAT *, UINT, int *, UINT *))IntGetProcAddress("wglChoosePixelFormatARB");
if(!_ptrc_wglChoosePixelFormatARB) numFailed++;
_ptrc_wglGetPixelFormatAttribfvARB = (BOOL (CODEGEN_FUNCPTR *)(HDC, int, int, UINT, const int *, FLOAT *))IntGetProcAddress("wglGetPixelFormatAttribfvARB");
if(!_ptrc_wglGetPixelFormatAttribfvARB) numFailed++;
_ptrc_wglGetPixelFormatAttribivARB = (BOOL (CODEGEN_FUNCPTR *)(HDC, int, int, UINT, const int *, int *))IntGetProcAddress("wglGetPixelFormatAttribivARB");
if(!_ptrc_wglGetPixelFormatAttribivARB) numFailed++;
return numFailed;
}

HGLRC (CODEGEN_FUNCPTR *_ptrc_wglCreateContextAttribsARB)(HDC, HGLRC, const int *) = NULL;

static int Load_ARB_create_context()
{
int numFailed = 0;
_ptrc_wglCreateContextAttribsARB = (HGLRC (CODEGEN_FUNCPTR *)(HDC, HGLRC, const int *))IntGetProcAddress("wglCreateContextAttribsARB");
if(!_ptrc_wglCreateContextAttribsARB) numFailed++;
return numFailed;
}

int (CODEGEN_FUNCPTR *_ptrc_wglGetSwapIntervalEXT)() = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglSwapIntervalEXT)(int) = NULL;

static int Load_EXT_swap_control()
{
int numFailed = 0;
_ptrc_wglGetSwapIntervalEXT = (int (CODEGEN_FUNCPTR *)())IntGetProcAddress("wglGetSwapIntervalEXT");
if(!_ptrc_wglGetSwapIntervalEXT) numFailed++;
_ptrc_wglSwapIntervalEXT = (BOOL (CODEGEN_FUNCPTR *)(int))IntGetProcAddress("wglSwapIntervalEXT");
if(!_ptrc_wglSwapIntervalEXT) numFailed++;
return numFailed;
}

BOOL (CODEGEN_FUNCPTR *_ptrc_wglBindSwapBarrierNV)(GLuint, GLuint) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglJoinSwapGroupNV)(HDC, GLuint) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglQueryFrameCountNV)(HDC, GLuint *) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglQueryMaxSwapGroupsNV)(HDC, GLuint *, GLuint *) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglQuerySwapGroupNV)(HDC, GLuint *, GLuint *) = NULL;
BOOL (CODEGEN_FUNCPTR *_ptrc_wglResetFrameCountNV)(HDC) = NULL;

static int Load_NV_swap_group()
{
int numFailed = 0;
_ptrc_wglBindSwapBarrierNV = (BOOL (CODEGEN_FUNCPTR *)(GLuint, GLuint))IntGetProcAddress("wglBindSwapBarrierNV");
if(!_ptrc_wglBindSwapBarrierNV) numFailed++;
_ptrc_wglJoinSwapGroupNV = (BOOL (CODEGEN_FUNCPTR *)(HDC, GLuint))IntGetProcAddress("wglJoinSwapGroupNV");
if(!_ptrc_wglJoinSwapGroupNV) numFailed++;
_ptrc_wglQueryFrameCountNV = (BOOL (CODEGEN_FUNCPTR *)(HDC, GLuint *))IntGetProcAddress("wglQueryFrameCountNV");
if(!_ptrc_wglQueryFrameCountNV) numFailed++;
_ptrc_wglQueryMaxSwapGroupsNV = (BOOL (CODEGEN_FUNCPTR *)(HDC, GLuint *, GLuint *))IntGetProcAddress("wglQueryMaxSwapGroupsNV");
if(!_ptrc_wglQueryMaxSwapGroupsNV) numFailed++;
_ptrc_wglQuerySwapGroupNV = (BOOL (CODEGEN_FUNCPTR *)(HDC, GLuint *, GLuint *))IntGetProcAddress("wglQuerySwapGroupNV");
if(!_ptrc_wglQuerySwapGroupNV) numFailed++;
_ptrc_wglResetFrameCountNV = (BOOL (CODEGEN_FUNCPTR *)(HDC))IntGetProcAddress("wglResetFrameCountNV");
if(!_ptrc_wglResetFrameCountNV) numFailed++;
return numFailed;
}

typedef int (*PFN_LOADFUNCPOINTERS)();
typedef struct wgl_StrToExtMap_s
{
char *extensionName;
int *extensionVariable;
PFN_LOADFUNCPOINTERS LoadExtension;
} wgl_StrToExtMap;

static wgl_StrToExtMap ExtensionMap_windesktop[13] = {
{"WGL_ARB_multisample", &wgl_ext_ARB_multisample, NULL},
{"WGL_ARB_extensions_string", &wgl_ext_ARB_extensions_string, Load_ARB_extensions_string},
{"WGL_ARB_pixel_format", &wgl_ext_ARB_pixel_format, Load_ARB_pixel_format},
{"WGL_ARB_pixel_format_float", &wgl_ext_ARB_pixel_format_float, NULL},
{"WGL_ARB_framebuffer_sRGB", &wgl_ext_ARB_framebuffer_sRGB, NULL},
{"WGL_ARB_create_context", &wgl_ext_ARB_create_context, Load_ARB_create_context},
{"WGL_ARB_create_context_profile", &wgl_ext_ARB_create_context_profile, NULL},
{"WGL_ARB_create_context_robustness", &wgl_ext_ARB_create_context_robustness, NULL},
{"WGL_EXT_swap_control", &wgl_ext_EXT_swap_control, Load_EXT_swap_control},
{"WGL_EXT_pixel_format_packed_float", &wgl_ext_EXT_pixel_format_packed_float, NULL},
{"WGL_EXT_create_context_es2_profile", &wgl_ext_EXT_create_context_es2_profile, NULL},
{"WGL_EXT_swap_control_tear", &wgl_ext_EXT_swap_control_tear, NULL},
{"WGL_NV_swap_group", &wgl_ext_NV_swap_group, Load_NV_swap_group},
};

static int g_extensionMapSize_windesktop = 13;

static wgl_StrToExtMap *FindExtEntry_windesktop(const char *extensionName)
{
int loop;
wgl_StrToExtMap *currLoc = ExtensionMap_windesktop;
for(loop = 0; loop < g_extensionMapSize_windesktop; ++loop, ++currLoc)
{
if(strcmp(extensionName, currLoc->extensionName) == 0)
return currLoc;
}

return NULL;
}

static void ClearExtensionVars_windesktop()
{
wgl_ext_ARB_multisample = wgl_LOAD_FAILED;
wgl_ext_ARB_extensions_string = wgl_LOAD_FAILED;
wgl_ext_ARB_pixel_format = wgl_LOAD_FAILED;
wgl_ext_ARB_pixel_format_float = wgl_LOAD_FAILED;
wgl_ext_ARB_framebuffer_sRGB = wgl_LOAD_FAILED;
wgl_ext_ARB_create_context = wgl_LOAD_FAILED;
wgl_ext_ARB_create_context_profile = wgl_LOAD_FAILED;
wgl_ext_ARB_create_context_robustness = wgl_LOAD_FAILED;
wgl_ext_EXT_swap_control = wgl_LOAD_FAILED;
wgl_ext_EXT_pixel_format_packed_float = wgl_LOAD_FAILED;
wgl_ext_EXT_create_context_es2_profile = wgl_LOAD_FAILED;
wgl_ext_EXT_swap_control_tear = wgl_LOAD_FAILED;
wgl_ext_NV_swap_group = wgl_LOAD_FAILED;
}


static void LoadExtByName_windesktop(const char *extensionName)
{
wgl_StrToExtMap *entry = NULL;
entry = FindExtEntry_windesktop(extensionName);
if(entry)
{
if(entry->LoadExtension)
{
int numFailed = entry->LoadExtension();
if(numFailed == 0)
{
*(entry->extensionVariable) = wgl_LOAD_SUCCEEDED;
}
else
{
*(entry->extensionVariable) = wgl_LOAD_SUCCEEDED + numFailed;
}
}
else
{
*(entry->extensionVariable) = wgl_LOAD_SUCCEEDED;
}
}
}


static void ProcExtsFromExtString(const char *strExtList)
{
size_t iExtListLen = strlen(strExtList);
const char *strExtListEnd = strExtList + iExtListLen;
const char *strCurrPos = strExtList;
char strWorkBuff[256];

while(*strCurrPos)
{
/*Get the extension at our position.*/
int iStrLen = 0;
const char *strEndStr = strchr(strCurrPos, ' ');
int iStop = 0;
if(strEndStr == NULL)
{
strEndStr = strExtListEnd;
iStop = 1;
}

iStrLen = (int)((ptrdiff_t)strEndStr - (ptrdiff_t)strCurrPos);

if(iStrLen > 255)
return;

strncpy(strWorkBuff, strCurrPos, iStrLen);
strWorkBuff[iStrLen] = '\0';

LoadExtByName_windesktop(strWorkBuff);

strCurrPos = strEndStr + 1;
if(iStop) break;
}
}

int wgl_LoadFunctions(HDC hdc)
{
ClearExtensionVars_windesktop();

_ptrc_wglGetExtensionsStringARB = (const char * (CODEGEN_FUNCPTR *)(HDC))IntGetProcAddress("wglGetExtensionsStringARB");
if(!_ptrc_wglGetExtensionsStringARB) return wgl_LOAD_FAILED;

ProcExtsFromExtString((const char *)_ptrc_wglGetExtensionsStringARB(hdc));
return wgl_LOAD_SUCCEEDED;
}


#endif
#ifdef TEMP_ASSERT
	#undef TEMP_ASSERT
	#undef ASSERT
#endif

#ifdef _MSC_VER
#pragma warning(pop) // pop of XO-AMALGAMATION-DISABLED-WARNINGS
#endif
